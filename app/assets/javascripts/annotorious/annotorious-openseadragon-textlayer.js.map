{"version":3,"file":"annotorious-openseadragon-textlayer.js","sources":["../src/labelConfigurations/transcriptionLabel.ts","../node_modules/@annotorious/formats/dist/annotorious-formats.es.js","../node_modules/svelte/src/runtime/internal/utils.js","../node_modules/svelte/src/runtime/internal/dom.js","../node_modules/svelte/src/runtime/internal/lifecycle.js","../node_modules/svelte/src/runtime/internal/scheduler.js","../node_modules/svelte/src/runtime/internal/transitions.js","../node_modules/svelte/src/runtime/internal/each.js","../node_modules/svelte/src/runtime/internal/Component.js","../node_modules/svelte/src/shared/version.js","../node_modules/svelte/src/runtime/internal/disclose-version/index.js","../src/Label/FillBoundsLabel.svelte","../src/Label/FixedPageSizeLabel.svelte","../src/Label/FixedScreenSizeLabel.svelte","../node_modules/@annotorious/annotorious/dist/annotorious.es.js","../src/ImageDimensions.ts","../src/TextLayer.svelte","../src/textLayerExtension.ts"],"sourcesContent":["import type { ImageAnnotation } from '@annotorious/annotorious';\n\nexport const transcriptionLabel = (annotation: ImageAnnotation) =>\n  annotation.bodies.find(b => b.purpose === 'transcribing')?.value;","let ht;\nconst nn = new Uint8Array(16);\nfunction en() {\n  if (!ht && (ht = typeof crypto < \"u\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !ht))\n    throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n  return ht(nn);\n}\nconst A = [];\nfor (let t = 0; t < 256; ++t)\n  A.push((t + 256).toString(16).slice(1));\nfunction on(t, n = 0) {\n  return A[t[n + 0]] + A[t[n + 1]] + A[t[n + 2]] + A[t[n + 3]] + \"-\" + A[t[n + 4]] + A[t[n + 5]] + \"-\" + A[t[n + 6]] + A[t[n + 7]] + \"-\" + A[t[n + 8]] + A[t[n + 9]] + \"-\" + A[t[n + 10]] + A[t[n + 11]] + A[t[n + 12]] + A[t[n + 13]] + A[t[n + 14]] + A[t[n + 15]];\n}\nconst rn = typeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto), _t = {\n  randomUUID: rn\n};\nfunction gt(t, n, e) {\n  if (_t.randomUUID && !n && !t)\n    return _t.randomUUID();\n  t = t || {};\n  const o = t.random || (t.rng || en)();\n  if (o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, n) {\n    e = e || 0;\n    for (let r = 0; r < 16; ++r)\n      n[e + r] = o[r];\n    return n;\n  }\n  return on(o);\n}\nvar sn = Object.defineProperty, an = (t, n, e) => n in t ? sn(t, n, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[n] = e, Ft = (t, n, e) => (an(t, typeof n != \"symbol\" ? n + \"\" : n, e), e);\nfunction et() {\n}\nfunction Lt(t, n) {\n  for (const e in n)\n    t[e] = n[e];\n  return (\n    /** @type {T & S} */\n    t\n  );\n}\nfunction zt(t) {\n  return t();\n}\nfunction Nt() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction D(t) {\n  t.forEach(zt);\n}\nfunction H(t) {\n  return typeof t == \"function\";\n}\nfunction yt(t, n) {\n  return t != t ? n == n : t !== n || t && typeof t == \"object\" || typeof t == \"function\";\n}\nfunction cn(t) {\n  return Object.keys(t).length === 0;\n}\nfunction ln(t, n, e, o) {\n  if (t) {\n    const r = Wt(t, n, e, o);\n    return t[0](r);\n  }\n}\nfunction Wt(t, n, e, o) {\n  return t[1] && o ? Lt(e.ctx.slice(), t[1](o(n))) : e.ctx;\n}\nfunction un(t, n, e, o) {\n  if (t[2] && o) {\n    const r = t[2](o(e));\n    if (n.dirty === void 0)\n      return r;\n    if (typeof r == \"object\") {\n      const s = [], i = Math.max(n.dirty.length, r.length);\n      for (let c = 0; c < i; c += 1)\n        s[c] = n.dirty[c] | r[c];\n      return s;\n    }\n    return n.dirty | r;\n  }\n  return n.dirty;\n}\nfunction pn(t, n, e, o, r, s) {\n  if (r) {\n    const i = Wt(n, e, o, s);\n    t.p(i, r);\n  }\n}\nfunction dn(t) {\n  if (t.ctx.length > 32) {\n    const n = [], e = t.ctx.length / 32;\n    for (let o = 0; o < e; o++)\n      n[o] = -1;\n    return n;\n  }\n  return -1;\n}\nfunction Gt(t) {\n  const n = {};\n  for (const e in t)\n    e[0] !== \"$\" && (n[e] = t[e]);\n  return n;\n}\nfunction mt(t) {\n  return t ?? \"\";\n}\nfunction Ut(t, n) {\n  t.appendChild(n);\n}\nfunction E(t, n, e) {\n  t.insertBefore(n, e || null);\n}\nfunction T(t) {\n  t.parentNode && t.parentNode.removeChild(t);\n}\nfunction hn(t, n) {\n  for (let e = 0; e < t.length; e += 1)\n    t[e] && t[e].d(n);\n}\nfunction I(t) {\n  return document.createElementNS(\"http://www.w3.org/2000/svg\", t);\n}\nfunction Kt(t) {\n  return document.createTextNode(t);\n}\nfunction N() {\n  return Kt(\" \");\n}\nfunction Qt() {\n  return Kt(\"\");\n}\nfunction L(t, n, e, o) {\n  return t.addEventListener(n, e, o), () => t.removeEventListener(n, e, o);\n}\nfunction a(t, n, e) {\n  e == null ? t.removeAttribute(n) : t.getAttribute(n) !== e && t.setAttribute(n, e);\n}\nfunction gn(t) {\n  return Array.from(t.childNodes);\n}\nfunction kt(t, n, e) {\n  t.classList.toggle(n, !!e);\n}\nfunction fn(t, n, { bubbles: e = !1, cancelable: o = !1 } = {}) {\n  return new CustomEvent(t, { detail: n, bubbles: e, cancelable: o });\n}\nlet ot;\nfunction nt(t) {\n  ot = t;\n}\nfunction mn() {\n  if (!ot)\n    throw new Error(\"Function called outside component initialization\");\n  return ot;\n}\nfunction yn() {\n  const t = mn();\n  return (n, e, { cancelable: o = !1 } = {}) => {\n    const r = t.$$.callbacks[n];\n    if (r) {\n      const s = fn(\n        /** @type {string} */\n        n,\n        e,\n        { cancelable: o }\n      );\n      return r.slice().forEach((i) => {\n        i.call(t, s);\n      }), !s.defaultPrevented;\n    }\n    return !0;\n  };\n}\nfunction R(t, n) {\n  const e = t.$$.callbacks[n.type];\n  e && e.slice().forEach((o) => o.call(this, n));\n}\nconst Z = [], Rt = [];\nlet Y = [];\nconst Dt = [], $n = /* @__PURE__ */ Promise.resolve();\nlet Pt = !1;\nfunction xn() {\n  Pt || (Pt = !0, $n.then(Jt));\n}\nfunction Ht(t) {\n  Y.push(t);\n}\nconst At = /* @__PURE__ */ new Set();\nlet J = 0;\nfunction Jt() {\n  if (J !== 0)\n    return;\n  const t = ot;\n  do {\n    try {\n      for (; J < Z.length; ) {\n        const n = Z[J];\n        J++, nt(n), wn(n.$$);\n      }\n    } catch (n) {\n      throw Z.length = 0, J = 0, n;\n    }\n    for (nt(null), Z.length = 0, J = 0; Rt.length; )\n      Rt.pop()();\n    for (let n = 0; n < Y.length; n += 1) {\n      const e = Y[n];\n      At.has(e) || (At.add(e), e());\n    }\n    Y.length = 0;\n  } while (Z.length);\n  for (; Dt.length; )\n    Dt.pop()();\n  Pt = !1, At.clear(), nt(t);\n}\nfunction wn(t) {\n  if (t.fragment !== null) {\n    t.update(), D(t.before_update);\n    const n = t.dirty;\n    t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, n), t.after_update.forEach(Ht);\n  }\n}\nfunction bn(t) {\n  const n = [], e = [];\n  Y.forEach((o) => t.indexOf(o) === -1 ? n.push(o) : e.push(o)), e.forEach((o) => o()), Y = n;\n}\nconst ft = /* @__PURE__ */ new Set();\nlet K;\nfunction Tn() {\n  K = {\n    r: 0,\n    c: [],\n    p: K\n    // parent group\n  };\n}\nfunction En() {\n  K.r || D(K.c), K = K.p;\n}\nfunction _(t, n) {\n  t && t.i && (ft.delete(t), t.i(n));\n}\nfunction G(t, n, e, o) {\n  if (t && t.o) {\n    if (ft.has(t))\n      return;\n    ft.add(t), K.c.push(() => {\n      ft.delete(t), o && (e && t.d(1), o());\n    }), t.o(n);\n  } else\n    o && o();\n}\nfunction Ct(t) {\n  return (t == null ? void 0 : t.length) !== void 0 ? t : Array.from(t);\n}\nfunction Q(t) {\n  t && t.c();\n}\nfunction V(t, n, e) {\n  const { fragment: o, after_update: r } = t.$$;\n  o && o.m(n, e), Ht(() => {\n    const s = t.$$.on_mount.map(zt).filter(H);\n    t.$$.on_destroy ? t.$$.on_destroy.push(...s) : D(s), t.$$.on_mount = [];\n  }), r.forEach(Ht);\n}\nfunction q(t, n) {\n  const e = t.$$;\n  e.fragment !== null && (bn(e.after_update), D(e.on_destroy), e.fragment && e.fragment.d(n), e.on_destroy = e.fragment = null, e.ctx = []);\n}\nfunction Sn(t, n) {\n  t.$$.dirty[0] === -1 && (Z.push(t), xn(), t.$$.dirty.fill(0)), t.$$.dirty[n / 31 | 0] |= 1 << n % 31;\n}\nfunction $t(t, n, e, o, r, s, i = null, c = [-1]) {\n  const l = ot;\n  nt(t);\n  const d = t.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props: s,\n    update: et,\n    not_equal: r,\n    bound: Nt(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(n.context || (l ? l.$$.context : [])),\n    // everything else\n    callbacks: Nt(),\n    dirty: c,\n    skip_bound: !1,\n    root: n.target || l.$$.root\n  };\n  i && i(d.root);\n  let g = !1;\n  if (d.ctx = e ? e(t, n.props || {}, (m, u, ...f) => {\n    const y = f.length ? f[0] : u;\n    return d.ctx && r(d.ctx[m], d.ctx[m] = y) && (!d.skip_bound && d.bound[m] && d.bound[m](y), g && Sn(t, m)), u;\n  }) : [], d.update(), g = !0, D(d.before_update), d.fragment = o ? o(d.ctx) : !1, n.target) {\n    if (n.hydrate) {\n      const m = gn(n.target);\n      d.fragment && d.fragment.l(m), m.forEach(T);\n    } else\n      d.fragment && d.fragment.c();\n    n.intro && _(t.$$.fragment), V(t, n.target, n.anchor), Jt();\n  }\n  nt(l);\n}\nclass xt {\n  constructor() {\n    Ft(this, \"$$\"), Ft(this, \"$$set\");\n  }\n  /** @returns {void} */\n  $destroy() {\n    q(this, 1), this.$destroy = et;\n  }\n  /**\n   * @template {Extract<keyof Events, string>} K\n   * @param {K} type\n   * @param {((e: Events[K]) => void) | null | undefined} callback\n   * @returns {() => void}\n   */\n  $on(n, e) {\n    if (!H(e))\n      return et;\n    const o = this.$$.callbacks[n] || (this.$$.callbacks[n] = []);\n    return o.push(e), () => {\n      const r = o.indexOf(e);\n      r !== -1 && o.splice(r, 1);\n    };\n  }\n  /**\n   * @param {Partial<Props>} props\n   * @returns {void}\n   */\n  $set(n) {\n    this.$$set && !cn(n) && (this.$$.skip_bound = !0, this.$$set(n), this.$$.skip_bound = !1);\n  }\n}\nconst On = \"4\";\ntypeof window < \"u\" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(On);\nvar U = /* @__PURE__ */ ((t) => (t.ELLIPSE = \"ELLIPSE\", t.POLYGON = \"POLYGON\", t.RECTANGLE = \"RECTANGLE\", t))(U || {});\nconst It = (t, n) => n, Zt = (t) => {\n  let n = 1 / 0, e = 1 / 0, o = -1 / 0, r = -1 / 0;\n  return t.forEach(([s, i]) => {\n    n = Math.min(n, s), e = Math.min(e, i), o = Math.max(o, s), r = Math.max(r, i);\n  }), { minX: n, minY: e, maxX: o, maxY: r };\n}, An = {\n  area: (t) => Math.PI * t.geometry.rx * t.geometry.ry,\n  intersects: (t, n, e) => {\n    const { cx: o, cy: r, rx: s, ry: i } = t.geometry, c = 0, l = Math.cos(c), d = Math.sin(c), g = n - o, m = e - r, u = l * g + d * m, f = d * g - l * m;\n    return u * u / (s * s) + f * f / (i * i) <= 1;\n  }\n};\nIt(U.ELLIPSE, An);\nconst Ln = {\n  area: (t) => {\n    const { points: n } = t.geometry;\n    let e = 0, o = n.length - 1;\n    for (let r = 0; r < n.length; r++)\n      e += (n[o][0] + n[r][0]) * (n[o][1] - n[r][1]), o = r;\n    return Math.abs(0.5 * e);\n  },\n  intersects: (t, n, e) => {\n    const { points: o } = t.geometry;\n    let r = !1;\n    for (let s = 0, i = o.length - 1; s < o.length; i = s++) {\n      const c = o[s][0], l = o[s][1], d = o[i][0], g = o[i][1];\n      l > e != g > e && n < (d - c) * (e - l) / (g - l) + c && (r = !r);\n    }\n    return r;\n  }\n};\nIt(U.POLYGON, Ln);\nconst Pn = {\n  area: (t) => t.geometry.w * t.geometry.h,\n  intersects: (t, n, e) => n >= t.geometry.x && n <= t.geometry.x + t.geometry.w && e >= t.geometry.y && e <= t.geometry.y + t.geometry.h\n};\nIt(U.RECTANGLE, Pn);\nconst Hn = (t, n = !1) => {\n  const e = typeof t == \"string\" ? t : t.value, o = /^(xywh)=(pixel|percent)?:?(.+?),(.+?),(.+?),(.+)*/g, r = [...e.matchAll(o)][0], [s, i, c, l, d, g, m] = r;\n  if (i !== \"xywh\")\n    throw new Error(\"Unsupported MediaFragment: \" + e);\n  if (c && c !== \"pixel\")\n    throw new Error(`Unsupported MediaFragment unit: ${c}`);\n  const [u, f, y, p] = [l, d, g, m].map(parseFloat);\n  return {\n    type: U.RECTANGLE,\n    geometry: {\n      x: u,\n      y: f,\n      w: y,\n      h: p,\n      bounds: {\n        minX: u,\n        minY: n ? f - p : f,\n        maxX: u + y,\n        maxY: n ? f : f + p\n      }\n    }\n  };\n}, Yt = \"http://www.w3.org/2000/svg\", Xt = (t) => {\n  const n = (o) => {\n    Array.from(o.attributes).forEach((r) => {\n      r.name.startsWith(\"on\") && o.removeAttribute(r.name);\n    });\n  }, e = t.getElementsByTagName(\"script\");\n  return Array.from(e).reverse().forEach((o) => o.parentNode.removeChild(o)), Array.from(t.querySelectorAll(\"*\")).forEach(n), t;\n}, In = (t) => {\n  const n = new XMLSerializer().serializeToString(t.documentElement).replace(\"<svg>\", `<svg xmlns=\"${Yt}\">`);\n  return new DOMParser().parseFromString(n, \"image/svg+xml\").documentElement;\n}, Mn = (t) => {\n  const n = new DOMParser().parseFromString(t, \"image/svg+xml\"), e = n.lookupPrefix(Yt), o = n.lookupNamespaceURI(null);\n  return e || o ? Xt(n).firstChild : Xt(In(n)).firstChild;\n}, _n = (t) => {\n  const [n, e, o] = t.match(/(<polygon points=[\"|'])([^(\"|')]*)/) || [], r = o.split(\" \").map((s) => s.split(\",\").map(parseFloat));\n  return {\n    type: U.POLYGON,\n    geometry: {\n      points: r,\n      bounds: Zt(r)\n    }\n  };\n}, Fn = (t) => {\n  const n = Mn(t), e = parseFloat(n.getAttribute(\"cx\")), o = parseFloat(n.getAttribute(\"cy\")), r = parseFloat(n.getAttribute(\"rx\")), s = parseFloat(n.getAttribute(\"ry\")), i = {\n    minX: e - r,\n    minY: o - s,\n    maxX: e + r,\n    maxY: o + s\n  };\n  return {\n    type: U.ELLIPSE,\n    geometry: {\n      cx: e,\n      cy: o,\n      rx: r,\n      ry: s,\n      bounds: i\n    }\n  };\n}, Nn = (t) => {\n  const n = typeof t == \"string\" ? t : t.value;\n  if (n.includes(\"<polygon points=\"))\n    return _n(n);\n  if (n.includes(\"<ellipse \"))\n    return Fn(n);\n  throw \"Unsupported SVG shape: \" + n;\n}, Gn = [];\nfor (let t = 0; t < 256; ++t)\n  Gn.push((t + 256).toString(16).slice(1));\ntypeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nconst Un = [];\nfor (let t = 0; t < 256; ++t)\n  Un.push((t + 256).toString(16).slice(1));\ntypeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nlet kn = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce((n, e) => (e &= 63, e < 36 ? n += e.toString(36) : e < 62 ? n += (e - 26).toString(36).toUpperCase() : e > 62 ? n += \"-\" : n += \"_\", n), \"\");\nkn();\nfunction vt(t, n, e) {\n  const o = t.slice();\n  return o[10] = n[e], o[12] = e, o;\n}\nfunction Bt(t) {\n  let n, e;\n  return n = new tt({\n    props: {\n      x: (\n        /*point*/\n        t[10][0]\n      ),\n      y: (\n        /*point*/\n        t[10][1]\n      ),\n      scale: (\n        /*viewportScale*/\n        t[3]\n      )\n    }\n  }), n.$on(\"pointerdown\", function() {\n    H(\n      /*grab*/\n      t[9](`HANDLE-${/*idx*/\n      t[12]}`)\n    ) && t[9](`HANDLE-${/*idx*/\n    t[12]}`).apply(this, arguments);\n  }), {\n    c() {\n      Q(n.$$.fragment);\n    },\n    m(o, r) {\n      V(n, o, r), e = !0;\n    },\n    p(o, r) {\n      t = o;\n      const s = {};\n      r & /*geom*/\n      16 && (s.x = /*point*/\n      t[10][0]), r & /*geom*/\n      16 && (s.y = /*point*/\n      t[10][1]), r & /*viewportScale*/\n      8 && (s.scale = /*viewportScale*/\n      t[3]), n.$set(s);\n    },\n    i(o) {\n      e || (_(n.$$.fragment, o), e = !0);\n    },\n    o(o) {\n      G(n.$$.fragment, o), e = !1;\n    },\n    d(o) {\n      q(n, o);\n    }\n  };\n}\nfunction Rn(t) {\n  let n, e, o, r, s, i, c, l, d, g, m, u = Ct(\n    /*geom*/\n    t[4].points\n  ), f = [];\n  for (let p = 0; p < u.length; p += 1)\n    f[p] = Bt(vt(t, u, p));\n  const y = (p) => G(f[p], 1, 1, () => {\n    f[p] = null;\n  });\n  return {\n    c() {\n      n = I(\"polygon\"), r = N(), s = I(\"polygon\"), c = N();\n      for (let p = 0; p < f.length; p += 1)\n        f[p].c();\n      l = Qt(), a(n, \"class\", \"a9s-outer\"), a(n, \"style\", e = /*computedStyle*/\n      t[1] ? \"display:none;\" : void 0), a(n, \"points\", o = /*geom*/\n      t[4].points.map(jt).join(\" \")), a(s, \"class\", \"a9s-inner a9s-shape-handle\"), a(\n        s,\n        \"style\",\n        /*computedStyle*/\n        t[1]\n      ), a(s, \"points\", i = /*geom*/\n      t[4].points.map(Vt).join(\" \"));\n    },\n    m(p, $) {\n      E(p, n, $), E(p, r, $), E(p, s, $), E(p, c, $);\n      for (let w = 0; w < f.length; w += 1)\n        f[w] && f[w].m(p, $);\n      E(p, l, $), d = !0, g || (m = [\n        L(n, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"SHAPE\")\n          ) && t[9](\"SHAPE\").apply(this, arguments);\n        }),\n        L(s, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"SHAPE\")\n          ) && t[9](\"SHAPE\").apply(this, arguments);\n        })\n      ], g = !0);\n    },\n    p(p, $) {\n      if (t = p, (!d || $ & /*computedStyle*/\n      2 && e !== (e = /*computedStyle*/\n      t[1] ? \"display:none;\" : void 0)) && a(n, \"style\", e), (!d || $ & /*geom*/\n      16 && o !== (o = /*geom*/\n      t[4].points.map(jt).join(\" \"))) && a(n, \"points\", o), (!d || $ & /*computedStyle*/\n      2) && a(\n        s,\n        \"style\",\n        /*computedStyle*/\n        t[1]\n      ), (!d || $ & /*geom*/\n      16 && i !== (i = /*geom*/\n      t[4].points.map(Vt).join(\" \"))) && a(s, \"points\", i), $ & /*geom, viewportScale, grab*/\n      536) {\n        u = Ct(\n          /*geom*/\n          t[4].points\n        );\n        let w;\n        for (w = 0; w < u.length; w += 1) {\n          const O = vt(t, u, w);\n          f[w] ? (f[w].p(O, $), _(f[w], 1)) : (f[w] = Bt(O), f[w].c(), _(f[w], 1), f[w].m(l.parentNode, l));\n        }\n        for (Tn(), w = u.length; w < f.length; w += 1)\n          y(w);\n        En();\n      }\n    },\n    i(p) {\n      if (!d) {\n        for (let $ = 0; $ < u.length; $ += 1)\n          _(f[$]);\n        d = !0;\n      }\n    },\n    o(p) {\n      f = f.filter(Boolean);\n      for (let $ = 0; $ < f.length; $ += 1)\n        G(f[$]);\n      d = !1;\n    },\n    d(p) {\n      p && (T(n), T(r), T(s), T(c), T(l)), hn(f, p), g = !1, D(m);\n    }\n  };\n}\nfunction Dn(t) {\n  let n, e;\n  return n = new tn({\n    props: {\n      shape: (\n        /*shape*/\n        t[0]\n      ),\n      transform: (\n        /*transform*/\n        t[2]\n      ),\n      editor: (\n        /*editor*/\n        t[5]\n      ),\n      $$slots: {\n        default: [\n          Rn,\n          ({ grab: o }) => ({ 9: o }),\n          ({ grab: o }) => o ? 512 : 0\n        ]\n      },\n      $$scope: { ctx: t }\n    }\n  }), n.$on(\n    \"change\",\n    /*change_handler*/\n    t[6]\n  ), n.$on(\n    \"grab\",\n    /*grab_handler*/\n    t[7]\n  ), n.$on(\n    \"release\",\n    /*release_handler*/\n    t[8]\n  ), {\n    c() {\n      Q(n.$$.fragment);\n    },\n    m(o, r) {\n      V(n, o, r), e = !0;\n    },\n    p(o, [r]) {\n      const s = {};\n      r & /*shape*/\n      1 && (s.shape = /*shape*/\n      o[0]), r & /*transform*/\n      4 && (s.transform = /*transform*/\n      o[2]), r & /*$$scope, geom, viewportScale, grab, computedStyle*/\n      8730 && (s.$$scope = { dirty: r, ctx: o }), n.$set(s);\n    },\n    i(o) {\n      e || (_(n.$$.fragment, o), e = !0);\n    },\n    o(o) {\n      G(n.$$.fragment, o), e = !1;\n    },\n    d(o) {\n      q(n, o);\n    }\n  };\n}\nconst jt = (t) => t.join(\",\"), Vt = (t) => t.join(\",\");\nfunction Cn(t, n, e) {\n  let o, { shape: r } = n, { computedStyle: s } = n, { transform: i } = n, { viewportScale: c = 1 } = n;\n  const l = (u, f, y) => {\n    let p;\n    const $ = u.geometry;\n    f === \"SHAPE\" ? p = $.points.map(([O, S]) => [O + y[0], S + y[1]]) : p = $.points.map(([O, S], F) => f === `HANDLE-${F}` ? [O + y[0], S + y[1]] : [O, S]);\n    const w = Zt(p);\n    return { ...u, geometry: { points: p, bounds: w } };\n  };\n  function d(u) {\n    R.call(this, t, u);\n  }\n  function g(u) {\n    R.call(this, t, u);\n  }\n  function m(u) {\n    R.call(this, t, u);\n  }\n  return t.$$set = (u) => {\n    \"shape\" in u && e(0, r = u.shape), \"computedStyle\" in u && e(1, s = u.computedStyle), \"transform\" in u && e(2, i = u.transform), \"viewportScale\" in u && e(3, c = u.viewportScale);\n  }, t.$$.update = () => {\n    t.$$.dirty & /*shape*/\n    1 && e(4, o = r.geometry);\n  }, [\n    r,\n    s,\n    i,\n    c,\n    o,\n    l,\n    d,\n    g,\n    m\n  ];\n}\nclass Xn extends xt {\n  constructor(n) {\n    super(), $t(this, n, Cn, Dn, yt, {\n      shape: 0,\n      computedStyle: 1,\n      transform: 2,\n      viewportScale: 3\n    });\n  }\n}\nconst vn = \"ontouchstart\" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;\nfunction Bn(t) {\n  let n, e, o, r, s, i;\n  return {\n    c() {\n      n = I(\"rect\"), a(n, \"class\", e = mt(`a9s-handle ${/*$$props*/\n      t[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\"), a(n, \"x\", o = /*x*/\n      t[0] - /*handleSize*/\n      t[5] / 2), a(n, \"y\", r = /*y*/\n      t[1] - /*handleSize*/\n      t[5] / 2), a(\n        n,\n        \"width\",\n        /*handleSize*/\n        t[5]\n      ), a(\n        n,\n        \"height\",\n        /*handleSize*/\n        t[5]\n      );\n    },\n    m(c, l) {\n      E(c, n, l), s || (i = L(\n        n,\n        \"pointerdown\",\n        /*pointerdown_handler_2*/\n        t[11]\n      ), s = !0);\n    },\n    p(c, l) {\n      l & /*$$props*/\n      256 && e !== (e = mt(`a9s-handle ${/*$$props*/\n      c[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\") && a(n, \"class\", e), l & /*x, handleSize*/\n      33 && o !== (o = /*x*/\n      c[0] - /*handleSize*/\n      c[5] / 2) && a(n, \"x\", o), l & /*y, handleSize*/\n      34 && r !== (r = /*y*/\n      c[1] - /*handleSize*/\n      c[5] / 2) && a(n, \"y\", r), l & /*handleSize*/\n      32 && a(\n        n,\n        \"width\",\n        /*handleSize*/\n        c[5]\n      ), l & /*handleSize*/\n      32 && a(\n        n,\n        \"height\",\n        /*handleSize*/\n        c[5]\n      );\n    },\n    d(c) {\n      c && T(n), s = !1, i();\n    }\n  };\n}\nfunction jn(t) {\n  let n, e, o, r, s, i, c, l, d;\n  return {\n    c() {\n      n = I(\"g\"), e = I(\"circle\"), r = I(\"rect\"), a(\n        e,\n        \"cx\",\n        /*x*/\n        t[0]\n      ), a(\n        e,\n        \"cy\",\n        /*y*/\n        t[1]\n      ), a(e, \"r\", o = /*radius*/\n      t[3] / /*scale*/\n      t[2]), a(e, \"class\", \"a9s-touch-halo svelte-1sgkh33\"), kt(\n        e,\n        \"touched\",\n        /*touched*/\n        t[4]\n      ), a(r, \"class\", s = mt(`a9s-handle ${/*$$props*/\n      t[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\"), a(r, \"x\", i = /*x*/\n      t[0] - /*handleSize*/\n      t[5] / 2), a(r, \"y\", c = /*y*/\n      t[1] - /*handleSize*/\n      t[5] / 2), a(\n        r,\n        \"width\",\n        /*handleSize*/\n        t[5]\n      ), a(\n        r,\n        \"height\",\n        /*handleSize*/\n        t[5]\n      ), a(n, \"class\", \"a9s-touch-handle\");\n    },\n    m(g, m) {\n      E(g, n, m), Ut(n, e), Ut(n, r), l || (d = [\n        L(\n          e,\n          \"pointerdown\",\n          /*pointerdown_handler*/\n          t[10]\n        ),\n        L(\n          e,\n          \"pointerdown\",\n          /*onPointerDown*/\n          t[6]\n        ),\n        L(\n          e,\n          \"pointerup\",\n          /*onPointerUp*/\n          t[7]\n        ),\n        L(\n          r,\n          \"pointerdown\",\n          /*pointerdown_handler_1*/\n          t[9]\n        ),\n        L(\n          r,\n          \"pointerdown\",\n          /*onPointerDown*/\n          t[6]\n        ),\n        L(\n          r,\n          \"pointerup\",\n          /*onPointerUp*/\n          t[7]\n        )\n      ], l = !0);\n    },\n    p(g, m) {\n      m & /*x*/\n      1 && a(\n        e,\n        \"cx\",\n        /*x*/\n        g[0]\n      ), m & /*y*/\n      2 && a(\n        e,\n        \"cy\",\n        /*y*/\n        g[1]\n      ), m & /*radius, scale*/\n      12 && o !== (o = /*radius*/\n      g[3] / /*scale*/\n      g[2]) && a(e, \"r\", o), m & /*touched*/\n      16 && kt(\n        e,\n        \"touched\",\n        /*touched*/\n        g[4]\n      ), m & /*$$props*/\n      256 && s !== (s = mt(`a9s-handle ${/*$$props*/\n      g[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\") && a(r, \"class\", s), m & /*x, handleSize*/\n      33 && i !== (i = /*x*/\n      g[0] - /*handleSize*/\n      g[5] / 2) && a(r, \"x\", i), m & /*y, handleSize*/\n      34 && c !== (c = /*y*/\n      g[1] - /*handleSize*/\n      g[5] / 2) && a(r, \"y\", c), m & /*handleSize*/\n      32 && a(\n        r,\n        \"width\",\n        /*handleSize*/\n        g[5]\n      ), m & /*handleSize*/\n      32 && a(\n        r,\n        \"height\",\n        /*handleSize*/\n        g[5]\n      );\n    },\n    d(g) {\n      g && T(n), l = !1, D(d);\n    }\n  };\n}\nfunction Vn(t) {\n  let n;\n  function e(r, s) {\n    return vn ? jn : Bn;\n  }\n  let o = e()(t);\n  return {\n    c() {\n      o.c(), n = Qt();\n    },\n    m(r, s) {\n      o.m(r, s), E(r, n, s);\n    },\n    p(r, [s]) {\n      o.p(r, s);\n    },\n    i: et,\n    o: et,\n    d(r) {\n      r && T(n), o.d(r);\n    }\n  };\n}\nfunction qn(t, n, e) {\n  let o, { x: r } = n, { y: s } = n, { scale: i } = n, { radius: c = 30 } = n, l = !1;\n  const d = (y) => {\n    y.pointerType === \"touch\" && e(4, l = !0);\n  }, g = () => e(4, l = !1);\n  function m(y) {\n    R.call(this, t, y);\n  }\n  function u(y) {\n    R.call(this, t, y);\n  }\n  function f(y) {\n    R.call(this, t, y);\n  }\n  return t.$$set = (y) => {\n    e(8, n = Lt(Lt({}, n), Gt(y))), \"x\" in y && e(0, r = y.x), \"y\" in y && e(1, s = y.y), \"scale\" in y && e(2, i = y.scale), \"radius\" in y && e(3, c = y.radius);\n  }, t.$$.update = () => {\n    t.$$.dirty & /*scale*/\n    4 && e(5, o = 10 / i);\n  }, n = Gt(n), [\n    r,\n    s,\n    i,\n    c,\n    l,\n    o,\n    d,\n    g,\n    n,\n    m,\n    u,\n    f\n  ];\n}\nclass tt extends xt {\n  constructor(n) {\n    super(), $t(this, n, qn, Vn, yt, { x: 0, y: 1, scale: 2, radius: 3 });\n  }\n}\nfunction zn(t) {\n  let n, e, o, r, s, i, c, l, d, g, m, u, f, y, p, $, w, O, S, F, k, C, z, P, W, rt, st, wt, M, at, it, ct, bt, X, Tt, v, Et, B, St, j, b, Ot, Mt;\n  return X = new tt({\n    props: {\n      class: \"a9s-corner-handle-topleft\",\n      x: (\n        /*geom*/\n        t[4].x\n      ),\n      y: (\n        /*geom*/\n        t[4].y\n      ),\n      scale: (\n        /*viewportScale*/\n        t[3]\n      )\n    }\n  }), X.$on(\"pointerdown\", function() {\n    H(\n      /*grab*/\n      t[9](\"TOP_LEFT\")\n    ) && t[9](\"TOP_LEFT\").apply(this, arguments);\n  }), v = new tt({\n    props: {\n      class: \"a9s-corner-handle-topright\",\n      x: (\n        /*geom*/\n        t[4].x + /*geom*/\n        t[4].w\n      ),\n      y: (\n        /*geom*/\n        t[4].y\n      ),\n      scale: (\n        /*viewportScale*/\n        t[3]\n      )\n    }\n  }), v.$on(\"pointerdown\", function() {\n    H(\n      /*grab*/\n      t[9](\"TOP_RIGHT\")\n    ) && t[9](\"TOP_RIGHT\").apply(this, arguments);\n  }), B = new tt({\n    props: {\n      class: \"a9s-corner-handle-bottomright\",\n      x: (\n        /*geom*/\n        t[4].x + /*geom*/\n        t[4].w\n      ),\n      y: (\n        /*geom*/\n        t[4].y + /*geom*/\n        t[4].h\n      ),\n      scale: (\n        /*viewportScale*/\n        t[3]\n      )\n    }\n  }), B.$on(\"pointerdown\", function() {\n    H(\n      /*grab*/\n      t[9](\"BOTTOM_RIGHT\")\n    ) && t[9](\"BOTTOM_RIGHT\").apply(this, arguments);\n  }), j = new tt({\n    props: {\n      class: \"a9s-corner-handle-bottomleft\",\n      x: (\n        /*geom*/\n        t[4].x\n      ),\n      y: (\n        /*geom*/\n        t[4].y + /*geom*/\n        t[4].h\n      ),\n      scale: (\n        /*viewportScale*/\n        t[3]\n      )\n    }\n  }), j.$on(\"pointerdown\", function() {\n    H(\n      /*grab*/\n      t[9](\"BOTTOM_LEFT\")\n    ) && t[9](\"BOTTOM_LEFT\").apply(this, arguments);\n  }), {\n    c() {\n      n = I(\"rect\"), c = N(), l = I(\"rect\"), f = N(), y = I(\"rect\"), O = N(), S = I(\"rect\"), z = N(), P = I(\"rect\"), wt = N(), M = I(\"rect\"), bt = N(), Q(X.$$.fragment), Tt = N(), Q(v.$$.fragment), Et = N(), Q(B.$$.fragment), St = N(), Q(j.$$.fragment), a(n, \"class\", \"a9s-outer\"), a(n, \"style\", e = /*computedStyle*/\n      t[1] ? \"display:none;\" : void 0), a(n, \"x\", o = /*geom*/\n      t[4].x), a(n, \"y\", r = /*geom*/\n      t[4].y), a(n, \"width\", s = /*geom*/\n      t[4].w), a(n, \"height\", i = /*geom*/\n      t[4].h), a(l, \"class\", \"a9s-inner a9s-shape-handle\"), a(\n        l,\n        \"style\",\n        /*computedStyle*/\n        t[1]\n      ), a(l, \"x\", d = /*geom*/\n      t[4].x), a(l, \"y\", g = /*geom*/\n      t[4].y), a(l, \"width\", m = /*geom*/\n      t[4].w), a(l, \"height\", u = /*geom*/\n      t[4].h), a(y, \"class\", \"a9s-edge-handle a9s-edge-handle-top\"), a(y, \"x\", p = /*geom*/\n      t[4].x), a(y, \"y\", $ = /*geom*/\n      t[4].y), a(y, \"height\", 1), a(y, \"width\", w = /*geom*/\n      t[4].w), a(S, \"class\", \"a9s-edge-handle a9s-edge-handle-right\"), a(S, \"x\", F = /*geom*/\n      t[4].x + /*geom*/\n      t[4].w), a(S, \"y\", k = /*geom*/\n      t[4].y), a(S, \"height\", C = /*geom*/\n      t[4].h), a(S, \"width\", 1), a(P, \"class\", \"a9s-edge-handle a9s-edge-handle-bottom\"), a(P, \"x\", W = /*geom*/\n      t[4].x), a(P, \"y\", rt = /*geom*/\n      t[4].y + /*geom*/\n      t[4].h), a(P, \"height\", 1), a(P, \"width\", st = /*geom*/\n      t[4].w), a(M, \"class\", \"a9s-edge-handle a9s-edge-handle-left\"), a(M, \"x\", at = /*geom*/\n      t[4].x), a(M, \"y\", it = /*geom*/\n      t[4].y), a(M, \"height\", ct = /*geom*/\n      t[4].h), a(M, \"width\", 1);\n    },\n    m(x, h) {\n      E(x, n, h), E(x, c, h), E(x, l, h), E(x, f, h), E(x, y, h), E(x, O, h), E(x, S, h), E(x, z, h), E(x, P, h), E(x, wt, h), E(x, M, h), E(x, bt, h), V(X, x, h), E(x, Tt, h), V(v, x, h), E(x, Et, h), V(B, x, h), E(x, St, h), V(j, x, h), b = !0, Ot || (Mt = [\n        L(n, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"SHAPE\")\n          ) && t[9](\"SHAPE\").apply(this, arguments);\n        }),\n        L(l, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"SHAPE\")\n          ) && t[9](\"SHAPE\").apply(this, arguments);\n        }),\n        L(y, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"TOP\")\n          ) && t[9](\"TOP\").apply(this, arguments);\n        }),\n        L(S, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"RIGHT\")\n          ) && t[9](\"RIGHT\").apply(this, arguments);\n        }),\n        L(P, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"BOTTOM\")\n          ) && t[9](\"BOTTOM\").apply(this, arguments);\n        }),\n        L(M, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"LEFT\")\n          ) && t[9](\"LEFT\").apply(this, arguments);\n        })\n      ], Ot = !0);\n    },\n    p(x, h) {\n      t = x, (!b || h & /*computedStyle*/\n      2 && e !== (e = /*computedStyle*/\n      t[1] ? \"display:none;\" : void 0)) && a(n, \"style\", e), (!b || h & /*geom*/\n      16 && o !== (o = /*geom*/\n      t[4].x)) && a(n, \"x\", o), (!b || h & /*geom*/\n      16 && r !== (r = /*geom*/\n      t[4].y)) && a(n, \"y\", r), (!b || h & /*geom*/\n      16 && s !== (s = /*geom*/\n      t[4].w)) && a(n, \"width\", s), (!b || h & /*geom*/\n      16 && i !== (i = /*geom*/\n      t[4].h)) && a(n, \"height\", i), (!b || h & /*computedStyle*/\n      2) && a(\n        l,\n        \"style\",\n        /*computedStyle*/\n        t[1]\n      ), (!b || h & /*geom*/\n      16 && d !== (d = /*geom*/\n      t[4].x)) && a(l, \"x\", d), (!b || h & /*geom*/\n      16 && g !== (g = /*geom*/\n      t[4].y)) && a(l, \"y\", g), (!b || h & /*geom*/\n      16 && m !== (m = /*geom*/\n      t[4].w)) && a(l, \"width\", m), (!b || h & /*geom*/\n      16 && u !== (u = /*geom*/\n      t[4].h)) && a(l, \"height\", u), (!b || h & /*geom*/\n      16 && p !== (p = /*geom*/\n      t[4].x)) && a(y, \"x\", p), (!b || h & /*geom*/\n      16 && $ !== ($ = /*geom*/\n      t[4].y)) && a(y, \"y\", $), (!b || h & /*geom*/\n      16 && w !== (w = /*geom*/\n      t[4].w)) && a(y, \"width\", w), (!b || h & /*geom*/\n      16 && F !== (F = /*geom*/\n      t[4].x + /*geom*/\n      t[4].w)) && a(S, \"x\", F), (!b || h & /*geom*/\n      16 && k !== (k = /*geom*/\n      t[4].y)) && a(S, \"y\", k), (!b || h & /*geom*/\n      16 && C !== (C = /*geom*/\n      t[4].h)) && a(S, \"height\", C), (!b || h & /*geom*/\n      16 && W !== (W = /*geom*/\n      t[4].x)) && a(P, \"x\", W), (!b || h & /*geom*/\n      16 && rt !== (rt = /*geom*/\n      t[4].y + /*geom*/\n      t[4].h)) && a(P, \"y\", rt), (!b || h & /*geom*/\n      16 && st !== (st = /*geom*/\n      t[4].w)) && a(P, \"width\", st), (!b || h & /*geom*/\n      16 && at !== (at = /*geom*/\n      t[4].x)) && a(M, \"x\", at), (!b || h & /*geom*/\n      16 && it !== (it = /*geom*/\n      t[4].y)) && a(M, \"y\", it), (!b || h & /*geom*/\n      16 && ct !== (ct = /*geom*/\n      t[4].h)) && a(M, \"height\", ct);\n      const lt = {};\n      h & /*geom*/\n      16 && (lt.x = /*geom*/\n      t[4].x), h & /*geom*/\n      16 && (lt.y = /*geom*/\n      t[4].y), h & /*viewportScale*/\n      8 && (lt.scale = /*viewportScale*/\n      t[3]), X.$set(lt);\n      const ut = {};\n      h & /*geom*/\n      16 && (ut.x = /*geom*/\n      t[4].x + /*geom*/\n      t[4].w), h & /*geom*/\n      16 && (ut.y = /*geom*/\n      t[4].y), h & /*viewportScale*/\n      8 && (ut.scale = /*viewportScale*/\n      t[3]), v.$set(ut);\n      const pt = {};\n      h & /*geom*/\n      16 && (pt.x = /*geom*/\n      t[4].x + /*geom*/\n      t[4].w), h & /*geom*/\n      16 && (pt.y = /*geom*/\n      t[4].y + /*geom*/\n      t[4].h), h & /*viewportScale*/\n      8 && (pt.scale = /*viewportScale*/\n      t[3]), B.$set(pt);\n      const dt = {};\n      h & /*geom*/\n      16 && (dt.x = /*geom*/\n      t[4].x), h & /*geom*/\n      16 && (dt.y = /*geom*/\n      t[4].y + /*geom*/\n      t[4].h), h & /*viewportScale*/\n      8 && (dt.scale = /*viewportScale*/\n      t[3]), j.$set(dt);\n    },\n    i(x) {\n      b || (_(X.$$.fragment, x), _(v.$$.fragment, x), _(B.$$.fragment, x), _(j.$$.fragment, x), b = !0);\n    },\n    o(x) {\n      G(X.$$.fragment, x), G(v.$$.fragment, x), G(B.$$.fragment, x), G(j.$$.fragment, x), b = !1;\n    },\n    d(x) {\n      x && (T(n), T(c), T(l), T(f), T(y), T(O), T(S), T(z), T(P), T(wt), T(M), T(bt), T(Tt), T(Et), T(St)), q(X, x), q(v, x), q(B, x), q(j, x), Ot = !1, D(Mt);\n    }\n  };\n}\nfunction Wn(t) {\n  let n, e;\n  return n = new tn({\n    props: {\n      shape: (\n        /*shape*/\n        t[0]\n      ),\n      transform: (\n        /*transform*/\n        t[2]\n      ),\n      editor: (\n        /*editor*/\n        t[5]\n      ),\n      $$slots: {\n        default: [\n          zn,\n          ({ grab: o }) => ({ 9: o }),\n          ({ grab: o }) => o ? 512 : 0\n        ]\n      },\n      $$scope: { ctx: t }\n    }\n  }), n.$on(\n    \"grab\",\n    /*grab_handler*/\n    t[6]\n  ), n.$on(\n    \"change\",\n    /*change_handler*/\n    t[7]\n  ), n.$on(\n    \"release\",\n    /*release_handler*/\n    t[8]\n  ), {\n    c() {\n      Q(n.$$.fragment);\n    },\n    m(o, r) {\n      V(n, o, r), e = !0;\n    },\n    p(o, [r]) {\n      const s = {};\n      r & /*shape*/\n      1 && (s.shape = /*shape*/\n      o[0]), r & /*transform*/\n      4 && (s.transform = /*transform*/\n      o[2]), r & /*$$scope, geom, viewportScale, grab, computedStyle*/\n      1562 && (s.$$scope = { dirty: r, ctx: o }), n.$set(s);\n    },\n    i(o) {\n      e || (_(n.$$.fragment, o), e = !0);\n    },\n    o(o) {\n      G(n.$$.fragment, o), e = !1;\n    },\n    d(o) {\n      q(n, o);\n    }\n  };\n}\nfunction Kn(t, n, e) {\n  let o, { shape: r } = n, { computedStyle: s } = n, { transform: i } = n, { viewportScale: c = 1 } = n;\n  const l = (u, f, y) => {\n    const p = u.geometry.bounds;\n    let [$, w] = [p.minX, p.minY], [O, S] = [p.maxX, p.maxY];\n    const [F, k] = y;\n    if (f === \"SHAPE\")\n      $ += F, O += F, w += k, S += k;\n    else {\n      switch (f) {\n        case \"TOP\":\n        case \"TOP_LEFT\":\n        case \"TOP_RIGHT\": {\n          w += k;\n          break;\n        }\n        case \"BOTTOM\":\n        case \"BOTTOM_LEFT\":\n        case \"BOTTOM_RIGHT\": {\n          S += k;\n          break;\n        }\n      }\n      switch (f) {\n        case \"LEFT\":\n        case \"TOP_LEFT\":\n        case \"BOTTOM_LEFT\": {\n          $ += F;\n          break;\n        }\n        case \"RIGHT\":\n        case \"TOP_RIGHT\":\n        case \"BOTTOM_RIGHT\": {\n          O += F;\n          break;\n        }\n      }\n    }\n    const C = Math.min($, O), z = Math.min(w, S), P = Math.abs(O - $), W = Math.abs(S - w);\n    return {\n      ...u,\n      geometry: {\n        x: C,\n        y: z,\n        w: P,\n        h: W,\n        bounds: {\n          minX: C,\n          minY: z,\n          maxX: C + P,\n          maxY: z + W\n        }\n      }\n    };\n  };\n  function d(u) {\n    R.call(this, t, u);\n  }\n  function g(u) {\n    R.call(this, t, u);\n  }\n  function m(u) {\n    R.call(this, t, u);\n  }\n  return t.$$set = (u) => {\n    \"shape\" in u && e(0, r = u.shape), \"computedStyle\" in u && e(1, s = u.computedStyle), \"transform\" in u && e(2, i = u.transform), \"viewportScale\" in u && e(3, c = u.viewportScale);\n  }, t.$$.update = () => {\n    t.$$.dirty & /*shape*/\n    1 && e(4, o = r.geometry);\n  }, [\n    r,\n    s,\n    i,\n    c,\n    o,\n    l,\n    d,\n    g,\n    m\n  ];\n}\nclass Qn extends xt {\n  constructor(n) {\n    super(), $t(this, n, Kn, Wn, yt, {\n      shape: 0,\n      computedStyle: 1,\n      transform: 2,\n      viewportScale: 3\n    });\n  }\n}\nU.RECTANGLE, U.POLYGON;\nconst Jn = (t) => ({}), qt = (t) => ({ grab: (\n  /*onGrab*/\n  t[0]\n) });\nfunction Zn(t) {\n  let n, e, o, r;\n  const s = (\n    /*#slots*/\n    t[7].default\n  ), i = ln(\n    s,\n    t,\n    /*$$scope*/\n    t[6],\n    qt\n  );\n  return {\n    c() {\n      n = I(\"g\"), i && i.c(), a(n, \"class\", \"a9s-annotation selected\");\n    },\n    m(c, l) {\n      E(c, n, l), i && i.m(n, null), e = !0, o || (r = [\n        L(\n          n,\n          \"pointerup\",\n          /*onRelease*/\n          t[2]\n        ),\n        L(\n          n,\n          \"pointermove\",\n          /*onPointerMove*/\n          t[1]\n        )\n      ], o = !0);\n    },\n    p(c, [l]) {\n      i && i.p && (!e || l & /*$$scope*/\n      64) && pn(\n        i,\n        s,\n        c,\n        /*$$scope*/\n        c[6],\n        e ? un(\n          s,\n          /*$$scope*/\n          c[6],\n          l,\n          Jn\n        ) : dn(\n          /*$$scope*/\n          c[6]\n        ),\n        qt\n      );\n    },\n    i(c) {\n      e || (_(i, c), e = !0);\n    },\n    o(c) {\n      G(i, c), e = !1;\n    },\n    d(c) {\n      c && T(n), i && i.d(c), o = !1, D(r);\n    }\n  };\n}\nfunction Yn(t, n, e) {\n  let { $$slots: o = {}, $$scope: r } = n;\n  const s = yn();\n  let { shape: i } = n, { editor: c } = n, { transform: l } = n, d, g, m;\n  const u = (p) => ($) => {\n    d = p, g = l.elementToImage($.offsetX, $.offsetY), m = i, $.target.setPointerCapture($.pointerId), s(\"grab\", $);\n  }, f = (p) => {\n    if (d) {\n      const [$, w] = l.elementToImage(p.offsetX, p.offsetY), O = [$ - g[0], w - g[1]];\n      e(3, i = c(m, d, O)), s(\"change\", i);\n    }\n  }, y = (p) => {\n    p.target.releasePointerCapture(p.pointerId), d = void 0, m = i, s(\"release\", p);\n  };\n  return t.$$set = (p) => {\n    \"shape\" in p && e(3, i = p.shape), \"editor\" in p && e(4, c = p.editor), \"transform\" in p && e(5, l = p.transform), \"$$scope\" in p && e(6, r = p.$$scope);\n  }, [u, f, y, i, c, l, r, o];\n}\nclass tn extends xt {\n  constructor(n) {\n    super(), $t(this, n, Yn, Zn, yt, { shape: 3, editor: 4, transform: 5 });\n  }\n}\nnavigator.userAgent.indexOf(\"Mac OS X\");\nconst te = (t) => {\n  const n = [];\n  let e = 0;\n  const o = t.querySelectorAll(\"String\");\n  for (const r of o) {\n    const s = r.getAttribute(\"ID\") || gt(), i = r.getAttribute(\"CONTENT\"), c = parseFloat(r.getAttribute(\"HPOS\")), l = parseFloat(r.getAttribute(\"VPOS\")), d = parseFloat(r.getAttribute(\"WIDTH\")), g = parseFloat(r.getAttribute(\"HEIGHT\")), m = c + d, u = l + g;\n    e += g, n.push({\n      id: s,\n      bodies: [{\n        id: s,\n        annotation: s,\n        purpose: \"transcribing\",\n        value: i\n      }],\n      target: {\n        annotation: s,\n        selector: {\n          type: U.RECTANGLE,\n          geometry: {\n            bounds: { minX: c, minY: l, maxX: m, maxY: u },\n            x: c,\n            y: l,\n            w: d,\n            h: g\n          }\n        }\n      }\n    });\n  }\n  return { annotations: n, averageHeight: e / o.length };\n}, ne = (t) => {\n  const n = [];\n  let e = 0;\n  const r = new DOMParser().parseFromString(t, \"application/xml\"), s = r.querySelector(\"Page\"), i = r.querySelectorAll(\"TextLine\");\n  for (const m of i) {\n    const { annotations: u, averageHeight: f } = te(m);\n    e += f, n.push(...u);\n  }\n  const c = s.getAttribute(\"ID\"), l = parseFloat(s.getAttribute(\"HEIGHT\")), d = parseFloat(s.getAttribute(\"WIDTH\")), g = e / i.length;\n  return { annotations: n, metadata: { id: c, height: l, width: d, averageLineHeight: g } };\n}, ee = (t) => t.reduce(\n  (n, e) => {\n    const { on: o, resource: r } = e;\n    let s;\n    if (o.selector[\"@type\"] === \"oa:FragmentSelector\") {\n      const i = e[\"@id\"];\n      s = {\n        id: i,\n        target: {\n          annotation: i,\n          selector: Hn(o.selector.value)\n        },\n        bodies: [{\n          id: gt(),\n          annotation: i,\n          purpose: \"transcribing\",\n          value: r.chars\n        }]\n      };\n    } else if (o.selector[\"@type\"] === \"oa:SvgSelector\") {\n      const i = Nn(o.selector.value);\n      if (i) {\n        const c = e[\"@id\"] || gt();\n        s = {\n          id: c,\n          target: {\n            annotation: c,\n            selector: {\n              type: i.type,\n              geometry: { ...i.geometry }\n            }\n          },\n          bodies: [{\n            id: gt(),\n            annotation: c,\n            purpose: \"transcribing\",\n            value: r.chars\n          }]\n        };\n      }\n    }\n    return s ? {\n      parsed: [...n.parsed, s],\n      failed: n.failed\n    } : {\n      parsed: n.parsed,\n      failed: [...n.failed, e]\n    };\n  },\n  { parsed: [], failed: [] }\n);\nexport {\n  ne as parseALTO,\n  ee as parseAnnotations\n};\n//# sourceMappingURL=annotorious-formats.es.js.map\n","/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import { contenteditable_truthy_values, has_prop } from './utils.js';\n\nimport { ResizeObserverSingleton } from './ResizeObserverSingleton.js';\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\n\n/**\n * @returns {void}\n */\nexport function start_hydrating() {\n\tis_hydrating = true;\n}\n\n/**\n * @returns {void}\n */\nexport function end_hydrating() {\n\tis_hydrating = false;\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {(index: number) => number} key\n * @param {number} value\n * @returns {number}\n */\nfunction upper_bound(low, high, key, value) {\n\t// Return first index of value larger than input value in the range [low, high)\n\twhile (low < high) {\n\t\tconst mid = low + ((high - low) >> 1);\n\t\tif (key(mid) <= value) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\treturn low;\n}\n\n/**\n * @param {NodeEx} target\n * @returns {void}\n */\nfunction init_hydrate(target) {\n\tif (target.hydrate_init) return;\n\ttarget.hydrate_init = true;\n\t// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n\n\tlet children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);\n\t// If target is <head>, there may be children without claim_order\n\tif (target.nodeName === 'HEAD') {\n\t\tconst my_children = [];\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst node = children[i];\n\t\t\tif (node.claim_order !== undefined) {\n\t\t\t\tmy_children.push(node);\n\t\t\t}\n\t\t}\n\t\tchildren = my_children;\n\t}\n\t/*\n\t * Reorder claimed children optimally.\n\t * We can reorder claimed children optimally by finding the longest subsequence of\n\t * nodes that are already claimed in order and only moving the rest. The longest\n\t * subsequence of nodes that are claimed in order can be found by\n\t * computing the longest increasing subsequence of .claim_order values.\n\t *\n\t * This algorithm is optimal in generating the least amount of reorder operations\n\t * possible.\n\t *\n\t * Proof:\n\t * We know that, given a set of reordering operations, the nodes that do not move\n\t * always form an increasing subsequence, since they do not move among each other\n\t * meaning that they must be already ordered among each other. Thus, the maximal\n\t * set of nodes that do not move form a longest increasing subsequence.\n\t */\n\t// Compute longest increasing subsequence\n\t// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n\tconst m = new Int32Array(children.length + 1);\n\t// Predecessor indices + 1\n\tconst p = new Int32Array(children.length);\n\tm[0] = -1;\n\tlet longest = 0;\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst current = children[i].claim_order;\n\t\t// Find the largest subsequence length such that it ends in a value less than our current value\n\t\t// upper_bound returns first greater value, so we subtract one\n\t\t// with fast path for when we are on the current longest subsequence\n\t\tconst seq_len =\n\t\t\t(longest > 0 && children[m[longest]].claim_order <= current\n\t\t\t\t? longest + 1\n\t\t\t\t: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;\n\t\tp[i] = m[seq_len] + 1;\n\t\tconst new_len = seq_len + 1;\n\t\t// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n\t\tm[new_len] = i;\n\t\tlongest = Math.max(new_len, longest);\n\t}\n\t// The longest increasing subsequence of nodes (initially reversed)\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst lis = [];\n\t// The rest of the nodes, nodes that will be moved\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst to_move = [];\n\tlet last = children.length - 1;\n\tfor (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n\t\tlis.push(children[cur - 1]);\n\t\tfor (; last >= cur; last--) {\n\t\t\tto_move.push(children[last]);\n\t\t}\n\t\tlast--;\n\t}\n\tfor (; last >= 0; last--) {\n\t\tto_move.push(children[last]);\n\t}\n\tlis.reverse();\n\t// We sort the nodes being moved to guarantee that their insertion order matches the claim order\n\tto_move.sort((a, b) => a.claim_order - b.claim_order);\n\t// Finally, we move the nodes\n\tfor (let i = 0, j = 0; i < to_move.length; i++) {\n\t\twhile (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\n\t\t\tj++;\n\t\t}\n\t\tconst anchor = j < lis.length ? lis[j] : null;\n\t\ttarget.insertBefore(to_move[i], anchor);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nexport function append(target, node) {\n\ttarget.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n * @returns {void}\n */\nexport function append_styles(target, style_sheet_id, styles) {\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tappend_stylesheet(append_styles_to, style);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {ShadowRoot | Document}\n */\nexport function get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn node.ownerDocument;\n}\n\n/**\n * @param {Node} node\n * @returns {CSSStyleSheet}\n */\nexport function append_empty_stylesheet(node) {\n\tconst style_element = element('style');\n\t// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\n\t// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\n\t// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\n\t// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\n\t// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\n\tstyle_element.textContent = '/* empty */';\n\tappend_stylesheet(get_root_for_style(node), style_element);\n\treturn style_element.sheet;\n}\n\n/**\n * @param {ShadowRoot | Document} node\n * @param {HTMLStyleElement} style\n * @returns {CSSStyleSheet}\n */\nfunction append_stylesheet(node, style) {\n\tappend(/** @type {Document} */ (node).head || node, style);\n\treturn style.sheet;\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @returns {void}\n */\nexport function append_hydration(target, node) {\n\tif (is_hydrating) {\n\t\tinit_hydrate(target);\n\t\tif (\n\t\t\ttarget.actual_end_child === undefined ||\n\t\t\t(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)\n\t\t) {\n\t\t\ttarget.actual_end_child = target.firstChild;\n\t\t}\n\t\t// Skip nodes of undefined ordering\n\t\twhile (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\n\t\t\ttarget.actual_end_child = target.actual_end_child.nextSibling;\n\t\t}\n\t\tif (node !== target.actual_end_child) {\n\t\t\t// We only insert if the ordering of this node should be modified or the parent node is not target\n\t\t\tif (node.claim_order !== undefined || node.parentNode !== target) {\n\t\t\t\ttarget.insertBefore(node, target.actual_end_child);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.actual_end_child = node.nextSibling;\n\t\t}\n\t} else if (node.parentNode !== target || node.nextSibling !== null) {\n\t\ttarget.appendChild(node);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nexport function insert(target, node, anchor) {\n\ttarget.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @param {NodeEx} [anchor]\n * @returns {void}\n */\nexport function insert_hydration(target, node, anchor) {\n\tif (is_hydrating && !anchor) {\n\t\tappend_hydration(target, node);\n\t} else if (node.parentNode !== target || node.nextSibling != anchor) {\n\t\ttarget.insertBefore(node, anchor || null);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nexport function detach(node) {\n\tif (node.parentNode) {\n\t\tnode.parentNode.removeChild(node);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function destroy_each(iterations, detaching) {\n\tfor (let i = 0; i < iterations.length; i += 1) {\n\t\tif (iterations[i]) iterations[i].d(detaching);\n\t}\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element(name) {\n\treturn document.createElement(name);\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @param {string} is\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element_is(name, is) {\n\treturn document.createElement(name, { is });\n}\n\n/**\n * @template T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K[]} exclude\n * @returns {Pick<T, Exclude<keyof T, K>>}\n */\nexport function object_without_properties(obj, exclude) {\n\tconst target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});\n\tfor (const k in obj) {\n\t\tif (\n\t\t\thas_prop(obj, k) &&\n\t\t\t// @ts-ignore\n\t\t\texclude.indexOf(k) === -1\n\t\t) {\n\t\t\t// @ts-ignore\n\t\t\ttarget[k] = obj[k];\n\t\t}\n\t}\n\treturn target;\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nexport function svg_element(name) {\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nexport function text(data) {\n\treturn document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nexport function space() {\n\treturn text(' ');\n}\n\n/**\n * @returns {Text} */\nexport function empty() {\n\treturn text('');\n}\n\n/**\n * @param {string} content\n * @returns {Comment}\n */\nexport function comment(content) {\n\treturn document.createComment(content);\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nexport function listen(node, event, handler, options) {\n\tnode.addEventListener(event, handler, options);\n\treturn () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function prevent_default(fn) {\n\treturn function (event) {\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_immediate_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function self(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.target === this) fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function trusted(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.isTrusted) fn.call(this, event);\n\t};\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nexport function attr(node, attribute, value) {\n\tif (value == null) node.removeAttribute(attribute);\n\telse if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_attributes(node, attributes) {\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\tfor (const key in attributes) {\n\t\tif (attributes[key] == null) {\n\t\t\tnode.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\tnode.style.cssText = attributes[key];\n\t\t} else if (key === '__value') {\n\t\t\t/** @type {any} */ (node).value = node[key] = attributes[key];\n\t\t} else if (\n\t\t\tdescriptors[key] &&\n\t\t\tdescriptors[key].set &&\n\t\t\talways_set_through_set_attribute.indexOf(key) === -1\n\t\t) {\n\t\t\tnode[key] = attributes[key];\n\t\t} else {\n\t\t\tattr(node, key, attributes[key]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_svg_attributes(node, attributes) {\n\tfor (const key in attributes) {\n\t\tattr(node, key, attributes[key]);\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} data_map\n * @returns {void}\n */\nexport function set_custom_element_data_map(node, data_map) {\n\tObject.keys(data_map).forEach((key) => {\n\t\tset_custom_element_data(node, key, data_map[key]);\n\t});\n}\n\n/**\n * @returns {void} */\nexport function set_custom_element_data(node, prop, value) {\n\tconst lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first\n\tif (lower in node) {\n\t\tnode[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;\n\t} else if (prop in node) {\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n\t} else {\n\t\tattr(node, prop, value);\n\t}\n}\n\n/**\n * @param {string} tag\n */\nexport function set_dynamic_element_data(tag) {\n\treturn /-/.test(tag) ? set_custom_element_data_map : set_attributes;\n}\n\n/**\n * @returns {void}\n */\nexport function xlink_attr(node, attribute, value) {\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @returns {string}\n */\nexport function get_svelte_dataset(node) {\n\treturn node.dataset.svelteH;\n}\n\n/**\n * @returns {unknown[]} */\nexport function get_binding_group_value(group, __value, checked) {\n\tconst value = new Set();\n\tfor (let i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) value.add(group[i].__value);\n\t}\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement[]} group\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\n */\nexport function init_binding_group(group) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\treturn {\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\t_inputs.forEach((input) => group.push(input));\n\t\t},\n\t\t/* remove */ r() {\n\t\t\t_inputs.forEach((input) => group.splice(group.indexOf(input), 1));\n\t\t}\n\t};\n}\n\n/**\n * @param {number[]} indexes\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\n */\nexport function init_binding_group_dynamic(group, indexes) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _group = get_binding_group(group);\n\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\n\tfunction get_binding_group(group) {\n\t\tfor (let i = 0; i < indexes.length; i++) {\n\t\t\tgroup = group[indexes[i]] = group[indexes[i]] || [];\n\t\t}\n\t\treturn group;\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction push() {\n\t\t_inputs.forEach((input) => _group.push(input));\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction remove() {\n\t\t_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));\n\t}\n\treturn {\n\t\t/* update */ u(new_indexes) {\n\t\t\tindexes = new_indexes;\n\t\t\tconst new_group = get_binding_group(group);\n\t\t\tif (new_group !== _group) {\n\t\t\t\tremove();\n\t\t\t\t_group = new_group;\n\t\t\t\tpush();\n\t\t\t}\n\t\t},\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\tpush();\n\t\t},\n\t\t/* remove */ r: remove\n\t};\n}\n\n/** @returns {number} */\nexport function to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/** @returns {any[]} */\nexport function time_ranges_to_array(ranges) {\n\tconst array = [];\n\tfor (let i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nexport function children(element) {\n\treturn Array.from(element.childNodes);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {void}\n */\nfunction init_claim_info(nodes) {\n\tif (nodes.claim_info === undefined) {\n\t\tnodes.claim_info = { last_index: 0, total_claimed: 0 };\n\t}\n}\n\n/**\n * @template {ChildNodeEx} R\n * @param {ChildNodeArray} nodes\n * @param {(node: ChildNodeEx) => node is R} predicate\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\n * @param {() => R} create_node\n * @param {boolean} dont_update_last_index\n * @returns {R}\n */\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\n\t// Try to find nodes in an order such that we lengthen the longest increasing subsequence\n\tinit_claim_info(nodes);\n\tconst result_node = (() => {\n\t\t// We first try to find an element after the previous one\n\t\tfor (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// Otherwise, we try to find one before\n\t\t// We iterate in reverse so that we don't go too far back\n\t\tfor (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t} else if (replacement === undefined) {\n\t\t\t\t\t// Since we spliced before the last_index, we decrease it\n\t\t\t\t\tnodes.claim_info.last_index--;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// If we can't find any matching node, we create a new one\n\t\treturn create_node();\n\t})();\n\tresult_node.claim_order = nodes.claim_info.total_claimed;\n\tnodes.claim_info.total_claimed += 1;\n\treturn result_node;\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @param {(name: string) => Element | SVGElement} create_element\n * @returns {Element | SVGElement}\n */\nfunction claim_element_base(nodes, name, attributes, create_element) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Element | SVGElement} */\n\t\t(node) => node.nodeName === name,\n\t\t/** @param {Element} node */\n\t\t(node) => {\n\t\t\tconst remove = [];\n\t\t\tfor (let j = 0; j < node.attributes.length; j++) {\n\t\t\t\tconst attribute = node.attributes[j];\n\t\t\t\tif (!attributes[attribute.name]) {\n\t\t\t\t\tremove.push(attribute.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove.forEach((v) => node.removeAttribute(v));\n\t\t\treturn undefined;\n\t\t},\n\t\t() => create_element(name)\n\t);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_svg_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, svg_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Text}\n */\nexport function claim_text(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Text} */\n\t\t(node) => node.nodeType === 3,\n\t\t/** @param {Text} node */\n\t\t(node) => {\n\t\t\tconst data_str = '' + data;\n\t\t\tif (node.data.startsWith(data_str)) {\n\t\t\t\tif (node.data.length !== data_str.length) {\n\t\t\t\t\treturn node.splitText(data_str.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.data = data_str;\n\t\t\t}\n\t\t},\n\t\t() => text(data),\n\t\ttrue // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n\t);\n}\n\n/**\n * @returns {Text} */\nexport function claim_space(nodes) {\n\treturn claim_text(nodes, ' ');\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Comment}\n */\nexport function claim_comment(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Comment} */\n\t\t(node) => node.nodeType === 8,\n\t\t/** @param {Comment} node */\n\t\t(node) => {\n\t\t\tnode.data = '' + data;\n\t\t\treturn undefined;\n\t\t},\n\t\t() => comment(data),\n\t\ttrue\n\t);\n}\n\nfunction get_comment_idx(nodes, text, start) {\n\tfor (let i = start; i < nodes.length; i += 1) {\n\t\tconst node = nodes[i];\n\t\tif (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * @param {boolean} is_svg\n * @returns {HtmlTagHydration}\n */\nexport function claim_html_tag(nodes, is_svg) {\n\t// find html opening tag\n\tconst start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\n\tconst end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\n\tif (start_index === -1 || end_index === -1) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\n\tinit_claim_info(nodes);\n\tconst html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n\tdetach(html_tag_nodes[0]);\n\tdetach(html_tag_nodes[html_tag_nodes.length - 1]);\n\tconst claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n\tif (claimed_nodes.length === 0) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\tfor (const n of claimed_nodes) {\n\t\tn.claim_order = nodes.claim_info.total_claimed;\n\t\tnodes.claim_info.total_claimed += 1;\n\t}\n\treturn new HtmlTagHydration(is_svg, claimed_nodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data(text, data) {\n\tdata = '' + data;\n\tif (text.data === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data_contenteditable(text, data) {\n\tdata = '' + data;\n\tif (text.wholeText === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nexport function set_data_maybe_contenteditable(text, data, attr_value) {\n\tif (~contenteditable_truthy_values.indexOf(attr_value)) {\n\t\tset_data_contenteditable(text, data);\n\t} else {\n\t\tset_data(text, data);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_input_value(input, value) {\n\tinput.value = value == null ? '' : value;\n}\n\n/**\n * @returns {void} */\nexport function set_input_type(input, type) {\n\ttry {\n\t\tinput.type = type;\n\t} catch (e) {\n\t\t// do nothing\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_style(node, key, value, important) {\n\tif (value == null) {\n\t\tnode.style.removeProperty(key);\n\t} else {\n\t\tnode.style.setProperty(key, value, important ? 'important' : '');\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_option(select, value, mounting) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\tif (option.__value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_options(select, value) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\toption.selected = ~value.indexOf(option.__value);\n\t}\n}\n\nexport function select_value(select) {\n\tconst selected_option = select.querySelector(':checked');\n\treturn selected_option && selected_option.__value;\n}\n\nexport function select_multiple_value(select) {\n\treturn [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nexport function is_crossorigin() {\n\tif (crossorigin === undefined) {\n\t\tcrossorigin = false;\n\t\ttry {\n\t\t\tif (typeof window !== 'undefined' && window.parent) {\n\t\t\t\tvoid window.parent.document;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tcrossorigin = true;\n\t\t}\n\t}\n\treturn crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nexport function add_iframe_resize_listener(node, fn) {\n\tconst computed_style = getComputedStyle(node);\n\tif (computed_style.position === 'static') {\n\t\tnode.style.position = 'relative';\n\t}\n\tconst iframe = element('iframe');\n\tiframe.setAttribute(\n\t\t'style',\n\t\t'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n\t\t\t'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'\n\t);\n\tiframe.setAttribute('aria-hidden', 'true');\n\tiframe.tabIndex = -1;\n\tconst crossorigin = is_crossorigin();\n\n\t/**\n\t * @type {() => void}\n\t */\n\tlet unsubscribe;\n\tif (crossorigin) {\n\t\tiframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n\t\tunsubscribe = listen(\n\t\t\twindow,\n\t\t\t'message',\n\t\t\t/** @param {MessageEvent} event */ (event) => {\n\t\t\t\tif (event.source === iframe.contentWindow) fn();\n\t\t\t}\n\t\t);\n\t} else {\n\t\tiframe.src = 'about:blank';\n\t\tiframe.onload = () => {\n\t\t\tunsubscribe = listen(iframe.contentWindow, 'resize', fn);\n\t\t\t// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n\t\t\t// see https://github.com/sveltejs/svelte/issues/4233\n\t\t\tfn();\n\t\t};\n\t}\n\tappend(node, iframe);\n\treturn () => {\n\t\tif (crossorigin) {\n\t\t\tunsubscribe();\n\t\t} else if (unsubscribe && iframe.contentWindow) {\n\t\t\tunsubscribe();\n\t\t}\n\t\tdetach(iframe);\n\t};\n}\nexport const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box'\n});\nexport const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box'\n});\nexport const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(\n\t{ box: 'device-pixel-content-box' }\n);\nexport { ResizeObserverSingleton };\n\n/**\n * @returns {void} */\nexport function toggle_class(element, name, toggle) {\n\t// The `!!` is required because an `undefined` flag means flipping the current state.\n\telement.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nexport function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * @param {string} selector\n * @param {HTMLElement} parent\n * @returns {ChildNodeArray}\n */\nexport function query_selector_all(selector, parent = document.body) {\n\treturn Array.from(parent.querySelectorAll(selector));\n}\n\n/**\n * @param {string} nodeId\n * @param {HTMLElement} head\n * @returns {any[]}\n */\nexport function head_selector(nodeId, head) {\n\tconst result = [];\n\tlet started = 0;\n\tfor (const node of head.childNodes) {\n\t\tif (node.nodeType === 8 /* comment node */) {\n\t\t\tconst comment = node.textContent.trim();\n\t\t\tif (comment === `HEAD_${nodeId}_END`) {\n\t\t\t\tstarted -= 1;\n\t\t\t\tresult.push(node);\n\t\t\t} else if (comment === `HEAD_${nodeId}_START`) {\n\t\t\t\tstarted += 1;\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t} else if (started > 0) {\n\t\t\tresult.push(node);\n\t\t}\n\t}\n\treturn result;\n}\n/** */\nexport class HtmlTag {\n\t/**\n\t * @private\n\t * @default false\n\t */\n\tis_svg = false;\n\t/** parent for creating node */\n\te = undefined;\n\t/** html tag nodes */\n\tn = undefined;\n\t/** target */\n\tt = undefined;\n\t/** anchor */\n\ta = undefined;\n\tconstructor(is_svg = false) {\n\t\tthis.is_svg = is_svg;\n\t\tthis.e = this.n = null;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tthis.h(html);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @param {HTMLElement | SVGElement} target\n\t * @param {HTMLElement | SVGElement} anchor\n\t * @returns {void}\n\t */\n\tm(html, target, anchor = null) {\n\t\tif (!this.e) {\n\t\t\tif (this.is_svg)\n\t\t\t\tthis.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));\n\t\t\t/** #7364  target for <template> may be provided as #document-fragment(11) */ else\n\t\t\t\tthis.e = element(\n\t\t\t\t\t/** @type {keyof HTMLElementTagNameMap} */ (\n\t\t\t\t\t\ttarget.nodeType === 11 ? 'TEMPLATE' : target.nodeName\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tthis.t =\n\t\t\t\ttarget.tagName !== 'TEMPLATE'\n\t\t\t\t\t? target\n\t\t\t\t\t: /** @type {HTMLTemplateElement} */ (target).content;\n\t\t\tthis.c(html);\n\t\t}\n\t\tthis.i(anchor);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\th(html) {\n\t\tthis.e.innerHTML = html;\n\t\tthis.n = Array.from(\n\t\t\tthis.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert(this.t, this.n[i], anchor);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tp(html) {\n\t\tthis.d();\n\t\tthis.h(html);\n\t\tthis.i(this.a);\n\t}\n\n\t/**\n\t * @returns {void} */\n\td() {\n\t\tthis.n.forEach(detach);\n\t}\n}\n\nexport class HtmlTagHydration extends HtmlTag {\n\t/** @type {Element[]} hydration claimed nodes */\n\tl = undefined;\n\n\tconstructor(is_svg = false, claimed_nodes) {\n\t\tsuper(is_svg);\n\t\tthis.e = this.n = null;\n\t\tthis.l = claimed_nodes;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tif (this.l) {\n\t\t\tthis.n = this.l;\n\t\t} else {\n\t\t\tsuper.c(html);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert_hydration(this.t, this.n[i], anchor);\n\t\t}\n\t}\n}\n\n/**\n * @param {NamedNodeMap} attributes\n * @returns {{}}\n */\nexport function attribute_to_object(attributes) {\n\tconst result = {};\n\tfor (const attribute of attributes) {\n\t\tresult[attribute.name] = attribute.value;\n\t}\n\treturn result;\n}\n\nconst escaped = {\n\t'\"': '&quot;',\n\t'&': '&amp;',\n\t'<': '&lt;'\n};\n\nconst regex_attribute_characters_to_escape = /[\"&<]/g;\n\n/**\n * Note that the attribute itself should be surrounded in double quotes\n * @param {any} attribute\n */\nfunction escape_attribute(attribute) {\n\treturn String(attribute).replace(regex_attribute_characters_to_escape, (match) => escaped[match]);\n}\n\n/**\n * @param {Record<string, string>} attributes\n */\nexport function stringify_spread(attributes) {\n\tlet str = ' ';\n\tfor (const key in attributes) {\n\t\tif (attributes[key] != null) {\n\t\t\tstr += `${key}=\"${escape_attribute(attributes[key])}\" `;\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {{}}\n */\nexport function get_custom_elements_slots(element) {\n\tconst result = {};\n\telement.childNodes.forEach(\n\t\t/** @param {Element} node */ (node) => {\n\t\t\tresult[node.slot || 'default'] = true;\n\t\t}\n\t);\n\treturn result;\n}\n\nexport function construct_svelte_component(component, props) {\n\treturn new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n","import { custom_event } from './dom.js';\n\nexport let current_component;\n\n/** @returns {void} */\nexport function set_current_component(component) {\n\tcurrent_component = component;\n}\n\nexport function get_current_component() {\n\tif (!current_component) throw new Error('Function called outside component initialization');\n\treturn current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tget_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tget_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tget_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tget_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component = get_current_component();\n\treturn (type, detail, { cancelable = false } = {}) => {\n\t\tconst callbacks = component.$$.callbacks[type];\n\t\tif (callbacks) {\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = custom_event(/** @type {string} */ (type), detail, { cancelable });\n\t\t\tcallbacks.slice().forEach((fn) => {\n\t\t\t\tfn.call(component, event);\n\t\t\t});\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_current_component().$$.context.set(key, context);\n\treturn context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\treturn get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\treturn get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nexport function bubble(component, event) {\n\tconst callbacks = component.$$.callbacks[event.type];\n\tif (callbacks) {\n\t\t// @ts-ignore\n\t\tcallbacks.slice().forEach((fn) => fn.call(this, event));\n\t}\n}\n","import { run_all } from './utils.js';\nimport { current_component, set_current_component } from './lifecycle.js';\n\nexport const dirty_components = [];\nexport const intros = { enabled: false };\nexport const binding_callbacks = [];\n\nlet render_callbacks = [];\n\nconst flush_callbacks = [];\n\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\n\nlet update_scheduled = false;\n\n/** @returns {void} */\nexport function schedule_update() {\n\tif (!update_scheduled) {\n\t\tupdate_scheduled = true;\n\t\tresolved_promise.then(flush);\n\t}\n}\n\n/** @returns {Promise<void>} */\nexport function tick() {\n\tschedule_update();\n\treturn resolved_promise;\n}\n\n/** @returns {void} */\nexport function add_render_callback(fn) {\n\trender_callbacks.push(fn);\n}\n\n/** @returns {void} */\nexport function add_flush_callback(fn) {\n\tflush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\n\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nexport function flush() {\n\t// Do not reenter flush while dirty components are updated, as this can\n\t// result in an infinite loop. Instead, let the inner flush handle it.\n\t// Reentrancy is ok afterwards for bindings etc.\n\tif (flushidx !== 0) {\n\t\treturn;\n\t}\n\tconst saved_component = current_component;\n\tdo {\n\t\t// first, call beforeUpdate functions\n\t\t// and update components\n\t\ttry {\n\t\t\twhile (flushidx < dirty_components.length) {\n\t\t\t\tconst component = dirty_components[flushidx];\n\t\t\t\tflushidx++;\n\t\t\t\tset_current_component(component);\n\t\t\t\tupdate(component.$$);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// reset dirty state to not end up in a deadlocked state and then rethrow\n\t\t\tdirty_components.length = 0;\n\t\t\tflushidx = 0;\n\t\t\tthrow e;\n\t\t}\n\t\tset_current_component(null);\n\t\tdirty_components.length = 0;\n\t\tflushidx = 0;\n\t\twhile (binding_callbacks.length) binding_callbacks.pop()();\n\t\t// then, once components are updated, call\n\t\t// afterUpdate functions. This may cause\n\t\t// subsequent updates...\n\t\tfor (let i = 0; i < render_callbacks.length; i += 1) {\n\t\t\tconst callback = render_callbacks[i];\n\t\t\tif (!seen_callbacks.has(callback)) {\n\t\t\t\t// ...so guard against infinite loops\n\t\t\t\tseen_callbacks.add(callback);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t\trender_callbacks.length = 0;\n\t} while (dirty_components.length);\n\twhile (flush_callbacks.length) {\n\t\tflush_callbacks.pop()();\n\t}\n\tupdate_scheduled = false;\n\tseen_callbacks.clear();\n\tset_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n\tif ($$.fragment !== null) {\n\t\t$$.update();\n\t\trun_all($$.before_update);\n\t\tconst dirty = $$.dirty;\n\t\t$$.dirty = [-1];\n\t\t$$.fragment && $$.fragment.p($$.ctx, dirty);\n\t\t$$.after_update.forEach(add_render_callback);\n\t}\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function flush_render_callbacks(fns) {\n\tconst filtered = [];\n\tconst targets = [];\n\trender_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));\n\ttargets.forEach((c) => c());\n\trender_callbacks = filtered;\n}\n","import { identity as linear, is_function, noop, run_all } from './utils.js';\nimport { now } from './environment.js';\nimport { loop } from './loop.js';\nimport { create_rule, delete_rule } from './style_manager.js';\nimport { custom_event } from './dom.js';\nimport { add_render_callback } from './scheduler.js';\n\n/**\n * @type {Promise<void> | null}\n */\nlet promise;\n\n/**\n * @returns {Promise<void>}\n */\nfunction wait() {\n\tif (!promise) {\n\t\tpromise = Promise.resolve();\n\t\tpromise.then(() => {\n\t\t\tpromise = null;\n\t\t});\n\t}\n\treturn promise;\n}\n\n/**\n * @param {Element} node\n * @param {INTRO | OUTRO | boolean} direction\n * @param {'start' | 'end'} kind\n * @returns {void}\n */\nfunction dispatch(node, direction, kind) {\n\tnode.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\n\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nexport function group_outros() {\n\toutros = {\n\t\tr: 0,\n\t\tc: [],\n\t\tp: outros // parent group\n\t};\n}\n\n/**\n * @returns {void} */\nexport function check_outros() {\n\tif (!outros.r) {\n\t\trun_all(outros.c);\n\t}\n\toutros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nexport function transition_in(block, local) {\n\tif (block && block.i) {\n\t\toutroing.delete(block);\n\t\tblock.i(local);\n\t}\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nexport function transition_out(block, local, detach, callback) {\n\tif (block && block.o) {\n\t\tif (outroing.has(block)) return;\n\t\toutroing.add(block);\n\t\toutros.c.push(() => {\n\t\t\toutroing.delete(block);\n\t\t\tif (callback) {\n\t\t\t\tif (detach) block.d(1);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\tblock.o(local);\n\t} else if (callback) {\n\t\tcallback();\n\t}\n}\n\n/**\n * @type {import('../transition/public.js').TransitionConfig}\n */\nconst null_transition = { duration: 0 };\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\n */\nexport function create_in_transition(node, fn, params) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'in' };\n\tlet config = fn(node, params, options);\n\tlet running = false;\n\tlet animation_name;\n\tlet task;\n\tlet uid = 0;\n\n\t/**\n\t * @returns {void} */\n\tfunction cleanup() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\t\tif (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n\t\ttick(0, 1);\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tif (task) task.abort();\n\t\trunning = true;\n\t\tadd_render_callback(() => dispatch(node, true, 'start'));\n\t\ttask = loop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(1, 0);\n\t\t\t\t\tdispatch(node, true, 'end');\n\t\t\t\t\tcleanup();\n\t\t\t\t\treturn (running = false);\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\tlet started = false;\n\treturn {\n\t\tstart() {\n\t\t\tif (started) return;\n\t\t\tstarted = true;\n\t\t\tdelete_rule(node);\n\t\t\tif (is_function(config)) {\n\t\t\t\tconfig = config(options);\n\t\t\t\twait().then(go);\n\t\t\t} else {\n\t\t\t\tgo();\n\t\t\t}\n\t\t},\n\t\tinvalidate() {\n\t\t\tstarted = false;\n\t\t},\n\t\tend() {\n\t\t\tif (running) {\n\t\t\t\tcleanup();\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ end(reset: any): void; }}\n */\nexport function create_out_transition(node, fn, params) {\n\t/** @type {TransitionOptions} */\n\tconst options = { direction: 'out' };\n\tlet config = fn(node, params, options);\n\tlet running = true;\n\tlet animation_name;\n\tconst group = outros;\n\tgroup.r += 1;\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\tif (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tadd_render_callback(() => dispatch(node, false, 'start'));\n\n\t\tif ('inert' in node) {\n\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\tnode.inert = true;\n\t\t}\n\n\t\tloop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(0, 1);\n\t\t\t\t\tdispatch(node, false, 'end');\n\t\t\t\t\tif (!--group.r) {\n\t\t\t\t\t\t// this will result in `end()` being called,\n\t\t\t\t\t\t// so we don't need to clean up here\n\t\t\t\t\t\trun_all(group.c);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(1 - t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\n\tif (is_function(config)) {\n\t\twait().then(() => {\n\t\t\t// @ts-ignore\n\t\t\tconfig = config(options);\n\t\t\tgo();\n\t\t});\n\t} else {\n\t\tgo();\n\t}\n\n\treturn {\n\t\tend(reset) {\n\t\t\tif (reset && 'inert' in node) {\n\t\t\t\tnode.inert = original_inert_value;\n\t\t\t}\n\t\t\tif (reset && config.tick) {\n\t\t\t\tconfig.tick(1, 0);\n\t\t\t}\n\t\t\tif (running) {\n\t\t\t\tif (animation_name) delete_rule(node, animation_name);\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @param {boolean} intro\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\n */\nexport function create_bidirectional_transition(node, fn, params, intro) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'both' };\n\tlet config = fn(node, params, options);\n\tlet t = intro ? 0 : 1;\n\n\t/**\n\t * @type {Program | null} */\n\tlet running_program = null;\n\n\t/**\n\t * @type {PendingProgram | null} */\n\tlet pending_program = null;\n\tlet animation_name = null;\n\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction clear_animation() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @param {PendingProgram} program\n\t * @param {number} duration\n\t * @returns {Program}\n\t */\n\tfunction init(program, duration) {\n\t\tconst d = /** @type {Program['d']} */ (program.b - t);\n\t\tduration *= Math.abs(d);\n\t\treturn {\n\t\t\ta: t,\n\t\t\tb: program.b,\n\t\t\td,\n\t\t\tduration,\n\t\t\tstart: program.start,\n\t\t\tend: program.start + duration,\n\t\t\tgroup: program.group\n\t\t};\n\t}\n\n\t/**\n\t * @param {INTRO | OUTRO} b\n\t * @returns {void}\n\t */\n\tfunction go(b) {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\t/**\n\t\t * @type {PendingProgram} */\n\t\tconst program = {\n\t\t\tstart: now() + delay,\n\t\t\tb\n\t\t};\n\n\t\tif (!b) {\n\t\t\t// @ts-ignore todo: improve typings\n\t\t\tprogram.group = outros;\n\t\t\toutros.r += 1;\n\t\t}\n\n\t\tif ('inert' in node) {\n\t\t\tif (b) {\n\t\t\t\tif (original_inert_value !== undefined) {\n\t\t\t\t\t// aborted/reversed outro — restore previous inert value\n\t\t\t\t\tnode.inert = original_inert_value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\t\tnode.inert = true;\n\t\t\t}\n\t\t}\n\n\t\tif (running_program || pending_program) {\n\t\t\tpending_program = program;\n\t\t} else {\n\t\t\t// if this is an intro, and there's a delay, we need to do\n\t\t\t// an initial tick and/or apply CSS animation immediately\n\t\t\tif (css) {\n\t\t\t\tclear_animation();\n\t\t\t\tanimation_name = create_rule(node, t, b, duration, delay, easing, css);\n\t\t\t}\n\t\t\tif (b) tick(0, 1);\n\t\t\trunning_program = init(program, duration);\n\t\t\tadd_render_callback(() => dispatch(node, b, 'start'));\n\t\t\tloop((now) => {\n\t\t\t\tif (pending_program && now > pending_program.start) {\n\t\t\t\t\trunning_program = init(pending_program, duration);\n\t\t\t\t\tpending_program = null;\n\t\t\t\t\tdispatch(node, running_program.b, 'start');\n\t\t\t\t\tif (css) {\n\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\tanimation_name = create_rule(\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tt,\n\t\t\t\t\t\t\trunning_program.b,\n\t\t\t\t\t\t\trunning_program.duration,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\teasing,\n\t\t\t\t\t\t\tconfig.css\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (running_program) {\n\t\t\t\t\tif (now >= running_program.end) {\n\t\t\t\t\t\ttick((t = running_program.b), 1 - t);\n\t\t\t\t\t\tdispatch(node, running_program.b, 'end');\n\t\t\t\t\t\tif (!pending_program) {\n\t\t\t\t\t\t\t// we're done\n\t\t\t\t\t\t\tif (running_program.b) {\n\t\t\t\t\t\t\t\t// intro — we can tidy up immediately\n\t\t\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// outro — needs to be coordinated\n\t\t\t\t\t\t\t\tif (!--running_program.group.r) run_all(running_program.group.c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trunning_program = null;\n\t\t\t\t\t} else if (now >= running_program.start) {\n\t\t\t\t\t\tconst p = now - running_program.start;\n\t\t\t\t\t\tt = running_program.a + running_program.d * easing(p / running_program.duration);\n\t\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!(running_program || pending_program);\n\t\t\t});\n\t\t}\n\t}\n\treturn {\n\t\trun(b) {\n\t\t\tif (is_function(config)) {\n\t\t\t\twait().then(() => {\n\t\t\t\t\tconst opts = { direction: b ? 'in' : 'out' };\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconfig = config(opts);\n\t\t\t\t\tgo(b);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tgo(b);\n\t\t\t}\n\t\t},\n\t\tend() {\n\t\t\tclear_animation();\n\t\t\trunning_program = pending_program = null;\n\t\t}\n\t};\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n","import { transition_in, transition_out } from './transitions.js';\nimport { run_all } from './utils.js';\n\n// general each functions:\n\nexport function ensure_array_like(array_like_or_iterator) {\n\treturn array_like_or_iterator?.length !== undefined\n\t\t? array_like_or_iterator\n\t\t: Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nexport function destroy_block(block, lookup) {\n\tblock.d(1);\n\tlookup.delete(block.key);\n}\n\n/** @returns {void} */\nexport function outro_and_destroy_block(block, lookup) {\n\ttransition_out(block, 1, 1, () => {\n\t\tlookup.delete(block.key);\n\t});\n}\n\n/** @returns {void} */\nexport function fix_and_destroy_block(block, lookup) {\n\tblock.f();\n\tdestroy_block(block, lookup);\n}\n\n/** @returns {void} */\nexport function fix_and_outro_and_destroy_block(block, lookup) {\n\tblock.f();\n\toutro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nexport function update_keyed_each(\n\told_blocks,\n\tdirty,\n\tget_key,\n\tdynamic,\n\tctx,\n\tlist,\n\tlookup,\n\tnode,\n\tdestroy,\n\tcreate_each_block,\n\tnext,\n\tget_context\n) {\n\tlet o = old_blocks.length;\n\tlet n = list.length;\n\tlet i = o;\n\tconst old_indexes = {};\n\twhile (i--) old_indexes[old_blocks[i].key] = i;\n\tconst new_blocks = [];\n\tconst new_lookup = new Map();\n\tconst deltas = new Map();\n\tconst updates = [];\n\ti = n;\n\twhile (i--) {\n\t\tconst child_ctx = get_context(ctx, list, i);\n\t\tconst key = get_key(child_ctx);\n\t\tlet block = lookup.get(key);\n\t\tif (!block) {\n\t\t\tblock = create_each_block(key, child_ctx);\n\t\t\tblock.c();\n\t\t} else if (dynamic) {\n\t\t\t// defer updates until all the DOM shuffling is done\n\t\t\tupdates.push(() => block.p(child_ctx, dirty));\n\t\t}\n\t\tnew_lookup.set(key, (new_blocks[i] = block));\n\t\tif (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n\t}\n\tconst will_move = new Set();\n\tconst did_move = new Set();\n\t/** @returns {void} */\n\tfunction insert(block) {\n\t\ttransition_in(block, 1);\n\t\tblock.m(node, next);\n\t\tlookup.set(block.key, block);\n\t\tnext = block.first;\n\t\tn--;\n\t}\n\twhile (o && n) {\n\t\tconst new_block = new_blocks[n - 1];\n\t\tconst old_block = old_blocks[o - 1];\n\t\tconst new_key = new_block.key;\n\t\tconst old_key = old_block.key;\n\t\tif (new_block === old_block) {\n\t\t\t// do nothing\n\t\t\tnext = new_block.first;\n\t\t\to--;\n\t\t\tn--;\n\t\t} else if (!new_lookup.has(old_key)) {\n\t\t\t// remove old block\n\t\t\tdestroy(old_block, lookup);\n\t\t\to--;\n\t\t} else if (!lookup.has(new_key) || will_move.has(new_key)) {\n\t\t\tinsert(new_block);\n\t\t} else if (did_move.has(old_key)) {\n\t\t\to--;\n\t\t} else if (deltas.get(new_key) > deltas.get(old_key)) {\n\t\t\tdid_move.add(new_key);\n\t\t\tinsert(new_block);\n\t\t} else {\n\t\t\twill_move.add(old_key);\n\t\t\to--;\n\t\t}\n\t}\n\twhile (o--) {\n\t\tconst old_block = old_blocks[o];\n\t\tif (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n\t}\n\twhile (n) insert(new_blocks[n - 1]);\n\trun_all(updates);\n\treturn new_blocks;\n}\n\n/** @returns {void} */\nexport function validate_each_keys(ctx, list, get_context, get_key) {\n\tconst keys = new Map();\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst key = get_key(get_context(ctx, list, i));\n\t\tif (keys.has(key)) {\n\t\t\tlet value = '';\n\t\t\ttry {\n\t\t\t\tvalue = `with value '${String(key)}' `;\n\t\t\t} catch (e) {\n\t\t\t\t// can't stringify\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} ${value}are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n","import {\n\tadd_render_callback,\n\tflush,\n\tflush_render_callbacks,\n\tschedule_update,\n\tdirty_components\n} from './scheduler.js';\nimport { current_component, set_current_component } from './lifecycle.js';\nimport { blank_object, is_empty, is_function, run, run_all, noop } from './utils.js';\nimport {\n\tchildren,\n\tdetach,\n\tstart_hydrating,\n\tend_hydrating,\n\tget_custom_elements_slots,\n\tinsert,\n\telement,\n\tattr\n} from './dom.js';\nimport { transition_in } from './transitions.js';\n\n/** @returns {void} */\nexport function bind(component, name, callback) {\n\tconst index = component.$$.props[name];\n\tif (index !== undefined) {\n\t\tcomponent.$$.bound[index] = callback;\n\t\tcallback(component.$$.ctx[index]);\n\t}\n}\n\n/** @returns {void} */\nexport function create_component(block) {\n\tblock && block.c();\n}\n\n/** @returns {void} */\nexport function claim_component(block, parent_nodes) {\n\tblock && block.l(parent_nodes);\n}\n\n/** @returns {void} */\nexport function mount_component(component, target, anchor) {\n\tconst { fragment, after_update } = component.$$;\n\tfragment && fragment.m(target, anchor);\n\t// onMount happens before the initial afterUpdate\n\tadd_render_callback(() => {\n\t\tconst new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n\t\t// if the component was destroyed immediately\n\t\t// it will update the `$$.on_destroy` reference to `null`.\n\t\t// the destructured on_destroy may still reference to the old array\n\t\tif (component.$$.on_destroy) {\n\t\t\tcomponent.$$.on_destroy.push(...new_on_destroy);\n\t\t} else {\n\t\t\t// Edge case - component was destroyed immediately,\n\t\t\t// most likely as a result of a binding initialising\n\t\t\trun_all(new_on_destroy);\n\t\t}\n\t\tcomponent.$$.on_mount = [];\n\t});\n\tafter_update.forEach(add_render_callback);\n}\n\n/** @returns {void} */\nexport function destroy_component(component, detaching) {\n\tconst $$ = component.$$;\n\tif ($$.fragment !== null) {\n\t\tflush_render_callbacks($$.after_update);\n\t\trun_all($$.on_destroy);\n\t\t$$.fragment && $$.fragment.d(detaching);\n\t\t// TODO null out other refs, including component.$$ (but need to\n\t\t// preserve final state?)\n\t\t$$.on_destroy = $$.fragment = null;\n\t\t$$.ctx = [];\n\t}\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n\tif (component.$$.dirty[0] === -1) {\n\t\tdirty_components.push(component);\n\t\tschedule_update();\n\t\tcomponent.$$.dirty.fill(0);\n\t}\n\tcomponent.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nexport function init(\n\tcomponent,\n\toptions,\n\tinstance,\n\tcreate_fragment,\n\tnot_equal,\n\tprops,\n\tappend_styles = null,\n\tdirty = [-1]\n) {\n\tconst parent_component = current_component;\n\tset_current_component(component);\n\t/** @type {import('./private.js').T$$} */\n\tconst $$ = (component.$$ = {\n\t\tfragment: null,\n\t\tctx: [],\n\t\t// state\n\t\tprops,\n\t\tupdate: noop,\n\t\tnot_equal,\n\t\tbound: blank_object(),\n\t\t// lifecycle\n\t\ton_mount: [],\n\t\ton_destroy: [],\n\t\ton_disconnect: [],\n\t\tbefore_update: [],\n\t\tafter_update: [],\n\t\tcontext: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n\t\t// everything else\n\t\tcallbacks: blank_object(),\n\t\tdirty,\n\t\tskip_bound: false,\n\t\troot: options.target || parent_component.$$.root\n\t});\n\tappend_styles && append_styles($$.root);\n\tlet ready = false;\n\t$$.ctx = instance\n\t\t? instance(component, options.props || {}, (i, ret, ...rest) => {\n\t\t\t\tconst value = rest.length ? rest[0] : ret;\n\t\t\t\tif ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n\t\t\t\t\tif (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n\t\t\t\t\tif (ready) make_dirty(component, i);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t  })\n\t\t: [];\n\t$$.update();\n\tready = true;\n\trun_all($$.before_update);\n\t// `false` as a special case of no DOM component\n\t$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\tif (options.target) {\n\t\tif (options.hydrate) {\n\t\t\tstart_hydrating();\n\t\t\t// TODO: what is the correct type here?\n\t\t\t// @ts-expect-error\n\t\t\tconst nodes = children(options.target);\n\t\t\t$$.fragment && $$.fragment.l(nodes);\n\t\t\tnodes.forEach(detach);\n\t\t} else {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t$$.fragment && $$.fragment.c();\n\t\t}\n\t\tif (options.intro) transition_in(component.$$.fragment);\n\t\tmount_component(component, options.target, options.anchor);\n\t\tend_hydrating();\n\t\tflush();\n\t}\n\tset_current_component(parent_component);\n}\n\nexport let SvelteElement;\n\nif (typeof HTMLElement === 'function') {\n\tSvelteElement = class extends HTMLElement {\n\t\t/** The Svelte component constructor */\n\t\t$$ctor;\n\t\t/** Slots */\n\t\t$$s;\n\t\t/** The Svelte component instance */\n\t\t$$c;\n\t\t/** Whether or not the custom element is connected */\n\t\t$$cn = false;\n\t\t/** Component props data */\n\t\t$$d = {};\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\n\t\t$$r = false;\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n\t\t$$p_d = {};\n\t\t/** @type {Record<string, Function[]>} Event listeners */\n\t\t$$l = {};\n\t\t/** @type {Map<Function, Function>} Event listener unsubscribe functions */\n\t\t$$l_u = new Map();\n\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\n\t\t\tsuper();\n\t\t\tthis.$$ctor = $$componentCtor;\n\t\t\tthis.$$s = $$slots;\n\t\t\tif (use_shadow_dom) {\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t}\n\t\t}\n\n\t\taddEventListener(type, listener, options) {\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\n\t\t\t// browser event, this fires twice - we can't avoid that.\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\n\t\t\tthis.$$l[type].push(listener);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t}\n\t\t\tsuper.addEventListener(type, listener, options);\n\t\t}\n\n\t\tremoveEventListener(type, listener, options) {\n\t\t\tsuper.removeEventListener(type, listener, options);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\n\t\t\t\tif (unsub) {\n\t\t\t\t\tunsub();\n\t\t\t\t\tthis.$$l_u.delete(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync connectedCallback() {\n\t\t\tthis.$$cn = true;\n\t\t\tif (!this.$$c) {\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tif (!this.$$cn || this.$$c) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfunction create_slot(name) {\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tlet node;\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\tc: function create() {\n\t\t\t\t\t\t\t\tnode = element('slot');\n\t\t\t\t\t\t\t\tif (name !== 'default') {\n\t\t\t\t\t\t\t\t\tattr(node, 'name', name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {HTMLElement} target\n\t\t\t\t\t\t\t * @param {HTMLElement} [anchor]\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tm: function mount(target, anchor) {\n\t\t\t\t\t\t\t\tinsert(target, node, anchor);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\td: function destroy(detaching) {\n\t\t\t\t\t\t\t\tif (detaching) {\n\t\t\t\t\t\t\t\t\tdetach(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tconst $$slots = {};\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\n\t\t\t\tfor (const name of this.$$s) {\n\t\t\t\t\tif (name in existing_slots) {\n\t\t\t\t\t\t$$slots[name] = [create_slot(name)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const attribute of this.attributes) {\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\n\t\t\t\t\tif (!(name in this.$$d)) {\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Port over props that were set programmatically before ce was initialized\n\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\tif (!(key in this.$$d) && this[key] !== undefined) {\n\t\t\t\t\t\tthis.$$d[key] = this[key]; // don't transform, these were set through JavaScript\n\t\t\t\t\t\tdelete this[key]; // remove the property that shadows the getter/setter\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$c = new this.$$ctor({\n\t\t\t\t\ttarget: this.shadowRoot || this,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...this.$$d,\n\t\t\t\t\t\t$$slots,\n\t\t\t\t\t\t$$scope: {\n\t\t\t\t\t\t\tctx: []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reflect component props as attributes\n\t\t\t\tconst reflect_attributes = () => {\n\t\t\t\t\tthis.$$r = true;\n\t\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\t\tthis.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n\t\t\t\t\t\tif (this.$$p_d[key].reflect) {\n\t\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tthis.$$d[key],\n\t\t\t\t\t\t\t\tthis.$$p_d,\n\t\t\t\t\t\t\t\t'toAttribute'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (attribute_value == null) {\n\t\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.$$r = false;\n\t\t\t\t};\n\t\t\t\tthis.$$c.$$.after_update.push(reflect_attributes);\n\t\t\t\treflect_attributes(); // once initially because after_update is added too late for first render\n\n\t\t\t\tfor (const type in this.$$l) {\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$l = {};\n\t\t\t}\n\t\t}\n\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n\t\t// and setting attributes through setAttribute etc, this is helpful\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\n\t\t\tif (this.$$r) return;\n\t\t\tattr = this.$$g_p(attr);\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.$$cn = false;\n\t\t\t// In a microtask, because this could be a move within the DOM\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tif (!this.$$cn) {\n\t\t\t\t\tthis.$$c.$destroy();\n\t\t\t\t\tthis.$$c = undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t$$g_p(attribute_name) {\n\t\t\treturn (\n\t\t\t\tObject.keys(this.$$p_d).find(\n\t\t\t\t\t(key) =>\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\n\t\t\t\t) || attribute_name\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n\tconst type = props_definition[prop]?.type;\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n\tif (!transform || !props_definition[prop]) {\n\t\treturn value;\n\t} else if (transform === 'toAttribute') {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value ? '' : null;\n\t\t\tcase 'Number':\n\t\t\t\treturn value == null ? null : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value && JSON.parse(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value; // conversion already handled above\n\t\t\tcase 'Number':\n\t\t\t\treturn value != null ? +value : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nexport function create_custom_element(\n\tComponent,\n\tprops_definition,\n\tslots,\n\taccessors,\n\tuse_shadow_dom,\n\textend\n) {\n\tlet Class = class extends SvelteElement {\n\t\tconstructor() {\n\t\t\tsuper(Component, slots, use_shadow_dom);\n\t\t\tthis.$$p_d = props_definition;\n\t\t}\n\t\tstatic get observedAttributes() {\n\t\t\treturn Object.keys(props_definition).map((key) =>\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\n\t\t\t);\n\t\t}\n\t};\n\tObject.keys(props_definition).forEach((prop) => {\n\t\tObject.defineProperty(Class.prototype, prop, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\n\t\t\t\tthis.$$d[prop] = value;\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\n\t\t\t}\n\t\t});\n\t});\n\taccessors.forEach((accessor) => {\n\t\tObject.defineProperty(Class.prototype, accessor, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c?.[accessor];\n\t\t\t}\n\t\t});\n\t});\n\tif (extend) {\n\t\t// @ts-expect-error - assigning here is fine\n\t\tClass = extend(Class);\n\t}\n\tComponent.element = /** @type {any} */ (Class);\n\treturn Class;\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nexport class SvelteComponent {\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$ = undefined;\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$set = undefined;\n\n\t/** @returns {void} */\n\t$destroy() {\n\t\tdestroy_component(this, 1);\n\t\tthis.$destroy = noop;\n\t}\n\n\t/**\n\t * @template {Extract<keyof Events, string>} K\n\t * @param {K} type\n\t * @param {((e: Events[K]) => void) | null | undefined} callback\n\t * @returns {() => void}\n\t */\n\t$on(type, callback) {\n\t\tif (!is_function(callback)) {\n\t\t\treturn noop;\n\t\t}\n\t\tconst callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n\t\tcallbacks.push(callback);\n\t\treturn () => {\n\t\t\tconst index = callbacks.indexOf(callback);\n\t\t\tif (index !== -1) callbacks.splice(index, 1);\n\t\t};\n\t}\n\n\t/**\n\t * @param {Partial<Props>} props\n\t * @returns {void}\n\t */\n\t$set(props) {\n\t\tif (this.$$set && !is_empty(props)) {\n\t\t\tthis.$$.skip_bound = true;\n\t\t\tthis.$$set(props);\n\t\t\tthis.$$.skip_bound = false;\n\t\t}\n\t}\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '4.2.12';\nexport const PUBLIC_VERSION = '4';\n","import { PUBLIC_VERSION } from '../../../shared/version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);\n","<script lang=\"ts\">\n  import type { ImageAnnotation } from '@annotorious/annotorious';\n  import type { TextLayerOpts } from '../Types';\n\n  let ref: HTMLSpanElement;\n\n  /** props **/\n  export let annotation: ImageAnnotation;\n  export let opts: TextLayerOpts;\n\n  $: b = annotation.target.selector.geometry.bounds;\n\n  $: left = b.minX;\n  $: top = b.minY;\n  $: width = b.maxX - b.minX;\n  $: height = b.maxY - b.minY;\n\n  $: scaleX = ref ? width / ref.offsetWidth : 1;\n  $: scaleY = ref ? height / ref.offsetHeight : 1;\n\n  $: label = opts.label(annotation);\n</script>\n\n{#if label}\n  <div \n    class=\"annotation\"\n    style={`left:${left}px; top:${top}px; width: ${width}px; height: ${height}px; transform: scale(${scaleX}, ${scaleY})`}>\n    <span bind:this={ref}>\n      {label}\n    </span>&nbsp;<!-- ensures spaces between words on copy and paste! -->\n  </div>\n{/if}","<script lang=\"ts\">\n  import type { ImageAnnotation } from '@annotorious/annotorious';\n  import type { TextLayerOpts } from '../Types';\n\n  let ref: HTMLSpanElement;\n\n  /** props **/\n  export let annotation: ImageAnnotation;\n  export let opts: TextLayerOpts;\n\n  $: b = annotation.target.selector.geometry.bounds;\n\n  $: size =  ref ? [ref.offsetWidth, ref.offsetHeight] : [0, 0];\n\n  const getStyle = (size: number[]) => {\n    const offsetX = (opts.offsetX || 0);\n    const offsetY = (opts.offsetY || 0);\n\n    if (opts.position === 'center') {\n      const w = b.maxX - b.minX;\n      const cx = b.minX + w / 2 - size[0] / 2;\n\n      const h = b.maxY - b.minY;\n      const cy = b.minY + h / 2 - size[1] / 2;\n\n      return `left:${cx + offsetX}px; top:${cy + offsetY}px;`;\n    } else if (opts.position === 'topleft') {\n      return `left:${b.minX + offsetX}px; top:${b.minY + offsetY}px;`;\n    } else {\n      return `left:${b.minX + offsetX}px; top:${b.maxY + offsetY}px;`;\n    }\n  }\n\n  $: label = opts.label(annotation);\n</script>\n\n{#if label}\n  <div \n    class=\"annotation\"\n    style={getStyle(size)}>\n    <span bind:this={ref}>\n      {label}\n    </span>&nbsp;<!-- ensures spaces between words on copy and paste! -->\n  </div>\n{/if}","<script lang=\"ts\">\n  import type { ImageAnnotation } from '@annotorious/annotorious';\n  import type { TextLayerOpts } from '../Types';\n\n  /** props **/\n  export let annotation: ImageAnnotation;\n  export let opts: TextLayerOpts;\n  export let scale: number;\n  export let imageSize: [number, number];\n\n  $: b = annotation.target.selector.geometry.bounds;\n\n  $: x = b.minX;\n  $: y = opts.position === 'topleft' ? b.minY : b.maxY;\n\n  const getStyle = (x: number, y: number, scale: number) => {\n    const offsetX = (opts.offsetX || 0) / scale;\n    const offsetY = (opts.offsetY || 0) / scale;\n\n    if (opts.position === 'topleft') {\n      const bottom = imageSize[1] - y;\n      return `left:${x + offsetX}px; bottom:${bottom}px; transform: scale(${1 / scale})`;\n    } else {\n      return `left:${x + offsetX}px; top:${y + offsetY}px; transform: scale(${1 / scale})`;\n    }\n  }\n\n  $: label = opts.label(annotation);\n</script>\n\n{#if label}\n  <div \n    class=\"annotation\"\n    style={getStyle(x, y, scale)}>\n    <span>\n      {label}\n    </span>&nbsp;<!-- ensures spaces between words on copy and paste! -->\n  </div>\n{/if}","var nn = Object.defineProperty;\nvar on = (e, t, n) => t in e ? nn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;\nvar Ke = (e, t, n) => (on(e, typeof t != \"symbol\" ? t + \"\" : t, n), n);\nfunction V() {\n}\nfunction nt(e, t) {\n  for (const n in t)\n    e[n] = t[n];\n  return (\n    /** @type {T & S} */\n    e\n  );\n}\nfunction Nt(e) {\n  return e();\n}\nfunction dt() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction ae(e) {\n  e.forEach(Nt);\n}\nfunction q(e) {\n  return typeof e == \"function\";\n}\nfunction W(e, t) {\n  return e != e ? t == t : e !== t || e && typeof e == \"object\" || typeof e == \"function\";\n}\nfunction sn(e) {\n  return Object.keys(e).length === 0;\n}\nfunction Vt(e, ...t) {\n  if (e == null) {\n    for (const o of t)\n      o(void 0);\n    return V;\n  }\n  const n = e.subscribe(...t);\n  return n.unsubscribe ? () => n.unsubscribe() : n;\n}\nfunction ht(e, t, n) {\n  e.$$.on_destroy.push(Vt(t, n));\n}\nfunction rn(e, t, n, o) {\n  if (e) {\n    const i = Gt(e, t, n, o);\n    return e[0](i);\n  }\n}\nfunction Gt(e, t, n, o) {\n  return e[1] && o ? nt(n.ctx.slice(), e[1](o(t))) : n.ctx;\n}\nfunction ln(e, t, n, o) {\n  if (e[2] && o) {\n    const i = e[2](o(n));\n    if (t.dirty === void 0)\n      return i;\n    if (typeof i == \"object\") {\n      const s = [], r = Math.max(t.dirty.length, i.length);\n      for (let l = 0; l < r; l += 1)\n        s[l] = t.dirty[l] | i[l];\n      return s;\n    }\n    return t.dirty | i;\n  }\n  return t.dirty;\n}\nfunction an(e, t, n, o, i, s) {\n  if (i) {\n    const r = Gt(t, n, o, s);\n    e.p(r, i);\n  }\n}\nfunction cn(e) {\n  if (e.ctx.length > 32) {\n    const t = [], n = e.ctx.length / 32;\n    for (let o = 0; o < n; o++)\n      t[o] = -1;\n    return t;\n  }\n  return -1;\n}\nfunction gt(e) {\n  const t = {};\n  for (const n in e)\n    n[0] !== \"$\" && (t[n] = e[n]);\n  return t;\n}\nfunction Ge(e) {\n  return e ?? \"\";\n}\nconst fn = typeof window < \"u\" ? window : typeof globalThis < \"u\" ? globalThis : (\n  // @ts-ignore Node typings have this\n  global\n);\nfunction se(e, t) {\n  e.appendChild(t);\n}\nfunction B(e, t, n) {\n  e.insertBefore(t, n || null);\n}\nfunction k(e) {\n  e.parentNode && e.parentNode.removeChild(e);\n}\nfunction rt(e, t) {\n  for (let n = 0; n < e.length; n += 1)\n    e[n] && e[n].d(t);\n}\nfunction U(e) {\n  return document.createElementNS(\"http://www.w3.org/2000/svg\", e);\n}\nfunction zt(e) {\n  return document.createTextNode(e);\n}\nfunction oe() {\n  return zt(\" \");\n}\nfunction ce() {\n  return zt(\"\");\n}\nfunction F(e, t, n, o) {\n  return e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o);\n}\nfunction d(e, t, n) {\n  n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n);\n}\nfunction un(e) {\n  return Array.from(e.childNodes);\n}\nfunction ze(e, t, n) {\n  e.classList.toggle(t, !!n);\n}\nfunction dn(e, t, { bubbles: n = !1, cancelable: o = !1 } = {}) {\n  return new CustomEvent(e, { detail: t, bubbles: n, cancelable: o });\n}\nlet Ie;\nfunction Be(e) {\n  Ie = e;\n}\nfunction Ht() {\n  if (!Ie)\n    throw new Error(\"Function called outside component initialization\");\n  return Ie;\n}\nfunction Pe(e) {\n  Ht().$$.on_mount.push(e);\n}\nfunction Te() {\n  const e = Ht();\n  return (t, n, { cancelable: o = !1 } = {}) => {\n    const i = e.$$.callbacks[t];\n    if (i) {\n      const s = dn(\n        /** @type {string} */\n        t,\n        n,\n        { cancelable: o }\n      );\n      return i.slice().forEach((r) => {\n        r.call(e, s);\n      }), !s.defaultPrevented;\n    }\n    return !0;\n  };\n}\nfunction ue(e, t) {\n  const n = e.$$.callbacks[t.type];\n  n && n.slice().forEach((o) => o.call(this, t));\n}\nconst be = [], He = [];\nlet Ae = [];\nconst mt = [], hn = /* @__PURE__ */ Promise.resolve();\nlet ot = !1;\nfunction gn() {\n  ot || (ot = !0, hn.then(Ft));\n}\nfunction it(e) {\n  Ae.push(e);\n}\nconst We = /* @__PURE__ */ new Set();\nlet pe = 0;\nfunction Ft() {\n  if (pe !== 0)\n    return;\n  const e = Ie;\n  do {\n    try {\n      for (; pe < be.length; ) {\n        const t = be[pe];\n        pe++, Be(t), mn(t.$$);\n      }\n    } catch (t) {\n      throw be.length = 0, pe = 0, t;\n    }\n    for (Be(null), be.length = 0, pe = 0; He.length; )\n      He.pop()();\n    for (let t = 0; t < Ae.length; t += 1) {\n      const n = Ae[t];\n      We.has(n) || (We.add(n), n());\n    }\n    Ae.length = 0;\n  } while (be.length);\n  for (; mt.length; )\n    mt.pop()();\n  ot = !1, We.clear(), Be(e);\n}\nfunction mn(e) {\n  if (e.fragment !== null) {\n    e.update(), ae(e.before_update);\n    const t = e.dirty;\n    e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(it);\n  }\n}\nfunction pn(e) {\n  const t = [], n = [];\n  Ae.forEach((o) => e.indexOf(o) === -1 ? t.push(o) : n.push(o)), n.forEach((o) => o()), Ae = t;\n}\nconst Ve = /* @__PURE__ */ new Set();\nlet de;\nfunction re() {\n  de = {\n    r: 0,\n    c: [],\n    p: de\n    // parent group\n  };\n}\nfunction le() {\n  de.r || ae(de.c), de = de.p;\n}\nfunction P(e, t) {\n  e && e.i && (Ve.delete(e), e.i(t));\n}\nfunction C(e, t, n, o) {\n  if (e && e.o) {\n    if (Ve.has(e))\n      return;\n    Ve.add(e), de.c.push(() => {\n      Ve.delete(e), o && (n && e.d(1), o());\n    }), e.o(t);\n  } else\n    o && o();\n}\nfunction Se(e) {\n  return (e == null ? void 0 : e.length) !== void 0 ? e : Array.from(e);\n}\nfunction $(e) {\n  e && e.c();\n}\nfunction Q(e, t, n) {\n  const { fragment: o, after_update: i } = e.$$;\n  o && o.m(t, n), it(() => {\n    const s = e.$$.on_mount.map(Nt).filter(q);\n    e.$$.on_destroy ? e.$$.on_destroy.push(...s) : ae(s), e.$$.on_mount = [];\n  }), i.forEach(it);\n}\nfunction x(e, t) {\n  const n = e.$$;\n  n.fragment !== null && (pn(n.after_update), ae(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);\n}\nfunction yn(e, t) {\n  e.$$.dirty[0] === -1 && (be.push(e), gn(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;\n}\nfunction ee(e, t, n, o, i, s, r = null, l = [-1]) {\n  const a = Ie;\n  Be(e);\n  const c = e.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props: s,\n    update: V,\n    not_equal: i,\n    bound: dt(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(t.context || (a ? a.$$.context : [])),\n    // everything else\n    callbacks: dt(),\n    dirty: l,\n    skip_bound: !1,\n    root: t.target || a.$$.root\n  };\n  r && r(c.root);\n  let u = !1;\n  if (c.ctx = n ? n(e, t.props || {}, (f, h, ...g) => {\n    const m = g.length ? g[0] : h;\n    return c.ctx && i(c.ctx[f], c.ctx[f] = m) && (!c.skip_bound && c.bound[f] && c.bound[f](m), u && yn(e, f)), h;\n  }) : [], c.update(), u = !0, ae(c.before_update), c.fragment = o ? o(c.ctx) : !1, t.target) {\n    if (t.hydrate) {\n      const f = un(t.target);\n      c.fragment && c.fragment.l(f), f.forEach(k);\n    } else\n      c.fragment && c.fragment.c();\n    t.intro && P(e.$$.fragment), Q(e, t.target, t.anchor), Ft();\n  }\n  Be(a);\n}\nclass te {\n  constructor() {\n    /**\n     * ### PRIVATE API\n     *\n     * Do not use, may change at any time\n     *\n     * @type {any}\n     */\n    Ke(this, \"$$\");\n    /**\n     * ### PRIVATE API\n     *\n     * Do not use, may change at any time\n     *\n     * @type {any}\n     */\n    Ke(this, \"$$set\");\n  }\n  /** @returns {void} */\n  $destroy() {\n    x(this, 1), this.$destroy = V;\n  }\n  /**\n   * @template {Extract<keyof Events, string>} K\n   * @param {K} type\n   * @param {((e: Events[K]) => void) | null | undefined} callback\n   * @returns {() => void}\n   */\n  $on(t, n) {\n    if (!q(n))\n      return V;\n    const o = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);\n    return o.push(n), () => {\n      const i = o.indexOf(n);\n      i !== -1 && o.splice(i, 1);\n    };\n  }\n  /**\n   * @param {Partial<Props>} props\n   * @returns {void}\n   */\n  $set(t) {\n    this.$$set && !sn(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);\n  }\n}\nconst _n = \"4\";\ntypeof window < \"u\" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(_n);\nvar j = /* @__PURE__ */ ((e) => (e.ELLIPSE = \"ELLIPSE\", e.POLYGON = \"POLYGON\", e.RECTANGLE = \"RECTANGLE\", e))(j || {});\nconst lt = {}, at = (e, t) => lt[e] = t, st = (e) => lt[e.type].area(e), wn = (e, t, n) => lt[e.type].intersects(e, t, n), Fe = (e) => {\n  let t = 1 / 0, n = 1 / 0, o = -1 / 0, i = -1 / 0;\n  return e.forEach(([s, r]) => {\n    t = Math.min(t, s), n = Math.min(n, r), o = Math.max(o, s), i = Math.max(i, r);\n  }), { minX: t, minY: n, maxX: o, maxY: i };\n}, bn = {\n  area: (e) => Math.PI * e.geometry.rx * e.geometry.ry,\n  intersects: (e, t, n) => {\n    const { cx: o, cy: i, rx: s, ry: r } = e.geometry, l = 0, a = Math.cos(l), c = Math.sin(l), u = t - o, f = n - i, h = a * u + c * f, g = c * u - a * f;\n    return h * h / (s * s) + g * g / (r * r) <= 1;\n  }\n};\nat(j.ELLIPSE, bn);\nconst En = {\n  area: (e) => {\n    const { points: t } = e.geometry;\n    let n = 0, o = t.length - 1;\n    for (let i = 0; i < t.length; i++)\n      n += (t[o][0] + t[i][0]) * (t[o][1] - t[i][1]), o = i;\n    return Math.abs(0.5 * n);\n  },\n  intersects: (e, t, n) => {\n    const { points: o } = e.geometry;\n    let i = !1;\n    for (let s = 0, r = o.length - 1; s < o.length; r = s++) {\n      const l = o[s][0], a = o[s][1], c = o[r][0], u = o[r][1];\n      a > n != u > n && t < (c - l) * (n - a) / (u - a) + l && (i = !i);\n    }\n    return i;\n  }\n};\nat(j.POLYGON, En);\nconst An = {\n  area: (e) => e.geometry.w * e.geometry.h,\n  intersects: (e, t, n) => t >= e.geometry.x && t <= e.geometry.x + e.geometry.w && n >= e.geometry.y && n <= e.geometry.y + e.geometry.h\n};\nat(j.RECTANGLE, An);\nconst Sn = (e, t = !1) => {\n  const n = typeof e == \"string\" ? e : e.value, o = /^(xywh)=(pixel|percent)?:?(.+?),(.+?),(.+?),(.+)*/g, i = [...n.matchAll(o)][0], [s, r, l, a, c, u, f] = i;\n  if (r !== \"xywh\")\n    throw new Error(\"Unsupported MediaFragment: \" + n);\n  if (l && l !== \"pixel\")\n    throw new Error(`Unsupported MediaFragment unit: ${l}`);\n  const [h, g, m, _] = [a, c, u, f].map(parseFloat);\n  return {\n    type: j.RECTANGLE,\n    geometry: {\n      x: h,\n      y: g,\n      w: m,\n      h: _,\n      bounds: {\n        minX: h,\n        minY: t ? g - _ : g,\n        maxX: h + m,\n        maxY: t ? g : g + _\n      }\n    }\n  };\n}, Tn = (e) => {\n  const { x: t, y: n, w: o, h: i } = e;\n  return {\n    type: \"FragmentSelector\",\n    conformsTo: \"http://www.w3.org/TR/media-frags/\",\n    value: `xywh=pixel:${t},${n},${o},${i}`\n  };\n}, jt = \"http://www.w3.org/2000/svg\", pt = (e) => {\n  const t = (o) => {\n    Array.from(o.attributes).forEach((i) => {\n      i.name.startsWith(\"on\") && o.removeAttribute(i.name);\n    });\n  }, n = e.getElementsByTagName(\"script\");\n  return Array.from(n).reverse().forEach((o) => o.parentNode.removeChild(o)), Array.from(e.querySelectorAll(\"*\")).forEach(t), e;\n}, Mn = (e) => {\n  const o = new XMLSerializer().serializeToString(e.documentElement).replace(\"<svg>\", `<svg xmlns=\"${jt}\">`);\n  return new DOMParser().parseFromString(o, \"image/svg+xml\").documentElement;\n}, vn = (e) => {\n  const n = new DOMParser().parseFromString(e, \"image/svg+xml\"), o = n.lookupPrefix(jt), i = n.lookupNamespaceURI(null);\n  return o || i ? pt(n).firstChild : pt(Mn(n)).firstChild;\n}, Ln = (e) => {\n  const [t, n, o] = e.match(/(<polygon points=[\"|'])([^(\"|')]*)/) || [], i = o.split(\" \").map((s) => s.split(\",\").map(parseFloat));\n  return {\n    type: j.POLYGON,\n    geometry: {\n      points: i,\n      bounds: Fe(i)\n    }\n  };\n}, kn = (e) => {\n  const t = vn(e), n = parseFloat(t.getAttribute(\"cx\")), o = parseFloat(t.getAttribute(\"cy\")), i = parseFloat(t.getAttribute(\"rx\")), s = parseFloat(t.getAttribute(\"ry\")), r = {\n    minX: n - i,\n    minY: o - s,\n    maxX: n + i,\n    maxY: o + s\n  };\n  return {\n    type: j.ELLIPSE,\n    geometry: {\n      cx: n,\n      cy: o,\n      rx: i,\n      ry: s,\n      bounds: r\n    }\n  };\n}, On = (e) => {\n  const t = typeof e == \"string\" ? e : e.value;\n  if (t.includes(\"<polygon points=\"))\n    return Ln(t);\n  if (t.includes(\"<ellipse \"))\n    return kn(t);\n  throw \"Unsupported SVG shape: \" + t;\n}, Bn = (e) => {\n  let t;\n  if (e.type === j.POLYGON) {\n    const n = e.geometry, { points: o } = n;\n    t = `<svg><polygon points=\"${o.map((i) => i.join(\",\")).join(\" \")}\" /></svg>`;\n  } else if (e.type === j.ELLIPSE) {\n    const n = e.geometry;\n    t = `<svg><ellipse cx=\"${n.cx}\" cy=\"${n.cy}\" rx=\"${n.rx}\" ry=\"${n.ry}\" /></svg>`;\n  }\n  if (t)\n    return { type: \"SvgSelector\", value: t };\n  throw `Unsupported shape type: ${e.type}`;\n};\nlet Re;\nconst In = new Uint8Array(16);\nfunction Pn() {\n  if (!Re && (Re = typeof crypto < \"u\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Re))\n    throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n  return Re(In);\n}\nconst K = [];\nfor (let e = 0; e < 256; ++e)\n  K.push((e + 256).toString(16).slice(1));\nfunction Yn(e, t = 0) {\n  return K[e[t + 0]] + K[e[t + 1]] + K[e[t + 2]] + K[e[t + 3]] + \"-\" + K[e[t + 4]] + K[e[t + 5]] + \"-\" + K[e[t + 6]] + K[e[t + 7]] + \"-\" + K[e[t + 8]] + K[e[t + 9]] + \"-\" + K[e[t + 10]] + K[e[t + 11]] + K[e[t + 12]] + K[e[t + 13]] + K[e[t + 14]] + K[e[t + 15]];\n}\nconst Dn = typeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto), yt = {\n  randomUUID: Dn\n};\nfunction qt(e, t, n) {\n  if (yt.randomUUID && !t && !e)\n    return yt.randomUUID();\n  e = e || {};\n  const o = e.random || (e.rng || Pn)();\n  if (o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, t) {\n    n = n || 0;\n    for (let i = 0; i < 16; ++i)\n      t[n + i] = o[i];\n    return t;\n  }\n  return Yn(o);\n}\nvar _t = Object.prototype.hasOwnProperty;\nfunction he(e, t) {\n  var n, o;\n  if (e === t)\n    return !0;\n  if (e && t && (n = e.constructor) === t.constructor) {\n    if (n === Date)\n      return e.getTime() === t.getTime();\n    if (n === RegExp)\n      return e.toString() === t.toString();\n    if (n === Array) {\n      if ((o = e.length) === t.length)\n        for (; o-- && he(e[o], t[o]); )\n          ;\n      return o === -1;\n    }\n    if (!n || typeof e == \"object\") {\n      o = 0;\n      for (n in e)\n        if (_t.call(e, n) && ++o && !_t.call(t, n) || !(n in t) || !he(e[n], t[n]))\n          return !1;\n      return Object.keys(t).length === o;\n    }\n  }\n  return e !== e && t !== t;\n}\nfunction Je() {\n}\nfunction Xn(e, t) {\n  return e != e ? t == t : e !== t || e && typeof e == \"object\" || typeof e == \"function\";\n}\nconst ye = [];\nfunction ct(e, t = Je) {\n  let n;\n  const o = /* @__PURE__ */ new Set();\n  function i(l) {\n    if (Xn(e, l) && (e = l, n)) {\n      const a = !ye.length;\n      for (const c of o)\n        c[1](), ye.push(c, e);\n      if (a) {\n        for (let c = 0; c < ye.length; c += 2)\n          ye[c][0](ye[c + 1]);\n        ye.length = 0;\n      }\n    }\n  }\n  function s(l) {\n    i(l(e));\n  }\n  function r(l, a = Je) {\n    const c = [l, a];\n    return o.add(c), o.size === 1 && (n = t(i, s) || Je), l(e), () => {\n      o.delete(c), o.size === 0 && n && (n(), n = null);\n    };\n  }\n  return { set: i, update: s, subscribe: r };\n}\nconst Cn = (e) => {\n  const { subscribe: t, set: n } = ct();\n  let o;\n  return t((i) => o = i), e.observe(({ changes: i }) => {\n    if (o) {\n      (i.deleted || []).some((r) => r.id === o) && n(void 0);\n      const s = (i.updated || []).find(({ oldValue: r }) => r.id === o);\n      s && n(s.newValue.id);\n    }\n  }), {\n    get current() {\n      return o;\n    },\n    subscribe: t,\n    set: n\n  };\n};\nvar Kt = /* @__PURE__ */ ((e) => (e.EDIT = \"EDIT\", e.SELECT = \"SELECT\", e.NONE = \"NONE\", e))(Kt || {});\nconst Ze = { selected: [] }, Rn = (e, t = \"EDIT\") => {\n  const { subscribe: n, set: o } = ct(Ze);\n  let i = Ze;\n  n((f) => i = f);\n  const s = () => o(Ze), r = () => {\n    var f;\n    return ((f = i.selected) == null ? void 0 : f.length) === 0;\n  }, l = (f) => {\n    if (i.selected.length === 0)\n      return !1;\n    const h = typeof f == \"string\" ? f : f.id;\n    return i.selected.some((g) => g.id === h);\n  }, a = (f, h) => {\n    const g = e.getAnnotation(f);\n    if (g) {\n      const m = Un(g, t);\n      o(m === \"EDIT\" ? { selected: [{ id: f, editable: !0 }], pointerEvent: h } : m === \"SELECT\" ? { selected: [{ id: f }], pointerEvent: h } : { selected: [], pointerEvent: h });\n    } else\n      console.warn(\"Invalid selection: \" + f);\n  }, c = (f, h = !0) => {\n    const g = Array.isArray(f) ? f : [f], m = g.map((_) => e.getAnnotation(_)).filter(Boolean);\n    o({ selected: m.map(({ id: _ }) => ({ id: _, editable: h })) }), m.length !== g.length && console.warn(\"Invalid selection\", f);\n  }, u = (f) => {\n    if (i.selected.length === 0)\n      return !1;\n    const { selected: h } = i;\n    h.filter(({ id: g }) => f.includes(g)).length > 0 && o({ selected: h.filter(({ id: g }) => !f.includes(g)) });\n  };\n  return e.observe(({ changes: f }) => u((f.deleted || []).map((h) => h.id))), {\n    clear: s,\n    clickSelect: a,\n    get selected() {\n      return i ? [...i.selected] : null;\n    },\n    get pointerEvent() {\n      return i ? i.pointerEvent : null;\n    },\n    isEmpty: r,\n    isSelected: l,\n    setSelected: c,\n    subscribe: n\n  };\n}, Un = (e, t) => typeof t == \"function\" ? t(e) || \"EDIT\" : t || \"EDIT\", Nn = [];\nfor (let e = 0; e < 256; ++e)\n  Nn.push((e + 256).toString(16).slice(1));\ntypeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nconst Vn = (e, t) => {\n  const n = new Set(e.bodies.map((o) => o.id));\n  return t.bodies.filter((o) => !n.has(o.id));\n}, Gn = (e, t) => {\n  const n = new Set(t.bodies.map((o) => o.id));\n  return e.bodies.filter((o) => !n.has(o.id));\n}, zn = (e, t) => t.bodies.map((n) => {\n  const o = e.bodies.find((i) => i.id === n.id);\n  return { newBody: n, oldBody: o && !he(o, n) ? o : void 0 };\n}).filter(({ oldBody: n }) => n).map(({ oldBody: n, newBody: o }) => ({ oldBody: n, newBody: o })), Hn = (e, t) => !he(e.target, t.target), Wt = (e, t) => {\n  const n = Vn(e, t), o = Gn(e, t), i = zn(e, t);\n  return {\n    oldValue: e,\n    newValue: t,\n    bodiesCreated: n.length > 0 ? n : void 0,\n    bodiesDeleted: o.length > 0 ? o : void 0,\n    bodiesUpdated: i.length > 0 ? i : void 0,\n    targetUpdated: Hn(e, t) ? { oldTarget: e.target, newTarget: t.target } : void 0\n  };\n};\nvar G = /* @__PURE__ */ ((e) => (e.LOCAL = \"LOCAL\", e.REMOTE = \"REMOTE\", e))(G || {});\nconst Fn = (e, t) => {\n  var n, o;\n  const { changes: i, origin: s } = t;\n  if (!(!e.options.origin || e.options.origin === s))\n    return !1;\n  if (e.options.ignore) {\n    const { ignore: r } = e.options, l = (a) => a && a.length > 0;\n    if (!(l(i.created) || l(i.deleted))) {\n      const a = (n = i.updated) == null ? void 0 : n.some((u) => l(u.bodiesCreated) || l(u.bodiesDeleted) || l(u.bodiesUpdated)), c = (o = i.updated) == null ? void 0 : o.some((u) => u.targetUpdated);\n      if (r === \"BODY_ONLY\" && a && !c || r === \"TARGET_ONLY\" && c && !a)\n        return !1;\n    }\n  }\n  if (e.options.annotations) {\n    const r = /* @__PURE__ */ new Set([\n      ...(i.created || []).map((l) => l.id),\n      ...(i.deleted || []).map((l) => l.id),\n      ...(i.updated || []).map(({ oldValue: l }) => l.id)\n    ]);\n    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((l) => r.has(l));\n  } else\n    return !0;\n}, jn = (e, t) => {\n  const n = new Set((e.created || []).map((f) => f.id)), o = new Set((e.updated || []).map(({ newValue: f }) => f.id)), i = new Set((t.created || []).map((f) => f.id)), s = new Set((t.deleted || []).map((f) => f.id)), r = new Set((t.updated || []).map(({ oldValue: f }) => f.id)), l = new Set((t.updated || []).filter(({ oldValue: f }) => n.has(f.id) || o.has(f.id)).map(({ oldValue: f }) => f.id)), a = [\n    ...(e.created || []).filter((f) => !s.has(f.id)).map((f) => r.has(f.id) ? t.updated.find(({ oldValue: h }) => h.id === f.id).newValue : f),\n    ...t.created || []\n  ], c = [\n    ...(e.deleted || []).filter((f) => !i.has(f.id)),\n    ...(t.deleted || []).filter((f) => !n.has(f.id))\n  ], u = [\n    ...(e.updated || []).filter(({ newValue: f }) => !s.has(f.id)).map((f) => {\n      const { oldValue: h, newValue: g } = f;\n      if (r.has(g.id)) {\n        const m = t.updated.find((_) => _.oldValue.id === g.id).newValue;\n        return Wt(h, m);\n      } else\n        return f;\n    }),\n    ...(t.updated || []).filter(({ oldValue: f }) => !l.has(f.id))\n  ];\n  return { created: a, deleted: c, updated: u };\n}, qn = (e) => e.id !== void 0, Kn = () => {\n  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = [], o = (p, T = {}) => n.push({ onChange: p, options: T }), i = (p) => {\n    const T = n.findIndex((S) => S.onChange == p);\n    T > -1 && n.splice(T, 1);\n  }, s = (p, T) => {\n    const S = {\n      origin: p,\n      changes: {\n        created: T.created || [],\n        updated: T.updated || [],\n        deleted: T.deleted || []\n      },\n      state: [...e.values()]\n    };\n    n.forEach((M) => {\n      Fn(M, S) && M.onChange(S);\n    });\n  }, r = (p, T = G.LOCAL) => {\n    if (e.get(p.id))\n      throw Error(`Cannot add annotation ${p.id} - exists already`);\n    e.set(p.id, p), p.bodies.forEach((S) => t.set(S.id, p.id)), s(T, { created: [p] });\n  }, l = (p, T) => {\n    const S = typeof p == \"string\" ? T : p, M = typeof p == \"string\" ? p : p.id, O = e.get(M);\n    if (O) {\n      const X = Wt(O, S);\n      return M === S.id ? e.set(M, S) : (e.delete(M), e.set(S.id, S)), O.bodies.forEach((Z) => t.delete(Z.id)), S.bodies.forEach((Z) => t.set(Z.id, S.id)), X;\n    } else\n      console.warn(`Cannot update annotation ${M} - does not exist`);\n  }, a = (p, T = G.LOCAL, S = G.LOCAL) => {\n    const M = qn(T) ? S : T, O = l(p, T);\n    O && s(M, { updated: [O] });\n  }, c = (p, T = G.LOCAL) => {\n    const S = p.reduce((M, O) => {\n      const X = l(O);\n      return X ? [...M, X] : M;\n    }, []);\n    S.length > 0 && s(T, { updated: S });\n  }, u = (p, T = G.LOCAL) => {\n    const S = e.get(p.annotation);\n    if (S) {\n      const M = {\n        ...S,\n        bodies: [...S.bodies, p]\n      };\n      e.set(S.id, M), t.set(p.id, M.id), s(T, { updated: [{\n        oldValue: S,\n        newValue: M,\n        bodiesCreated: [p]\n      }] });\n    } else\n      console.warn(`Attempt to add body to missing annotation: ${p.annotation}`);\n  }, f = () => [...e.values()], h = (p = G.LOCAL) => {\n    const T = [...e.values()];\n    e.clear(), t.clear(), s(p, { deleted: T });\n  }, g = (p, T = !0, S = G.LOCAL) => {\n    if (T) {\n      const M = [...e.values()];\n      e.clear(), t.clear(), p.forEach((O) => {\n        e.set(O.id, O), O.bodies.forEach((X) => t.set(X.id, O.id));\n      }), s(S, { created: p, deleted: M });\n    } else {\n      const M = p.reduce((O, X) => {\n        const Z = e.get(X.id);\n        return Z ? [...O, Z] : O;\n      }, []);\n      if (M.length > 0)\n        throw Error(`Bulk insert would overwrite the following annotations: ${M.map((O) => O.id).join(\", \")}`);\n      p.forEach((O) => {\n        e.set(O.id, O), O.bodies.forEach((X) => t.set(X.id, O.id));\n      }), s(S, { created: p });\n    }\n  }, m = (p) => {\n    const T = typeof p == \"string\" ? p : p.id, S = e.get(T);\n    if (S)\n      return e.delete(T), S.bodies.forEach((M) => t.delete(M.id)), S;\n    console.warn(`Attempt to delete missing annotation: ${T}`);\n  }, _ = (p, T = G.LOCAL) => {\n    const S = m(p);\n    S && s(T, { deleted: [S] });\n  }, w = (p, T = G.LOCAL) => {\n    const S = p.reduce((M, O) => {\n      const X = m(O);\n      return X ? [...M, X] : M;\n    }, []);\n    S.length > 0 && s(T, { deleted: S });\n  }, y = (p, T = G.LOCAL) => {\n    const S = e.get(p.annotation);\n    if (S) {\n      const M = S.bodies.find((O) => O.id === p.id);\n      if (M) {\n        t.delete(M.id);\n        const O = {\n          ...S,\n          bodies: S.bodies.filter((X) => X.id !== p.id)\n        };\n        e.set(S.id, O), s(T, { updated: [{\n          oldValue: S,\n          newValue: O,\n          bodiesDeleted: [M]\n        }] });\n      } else\n        console.warn(`Attempt to delete missing body ${p.id} from annotation ${p.annotation}`);\n    } else\n      console.warn(`Attempt to delete body from missing annotation ${p.annotation}`);\n  }, E = (p) => {\n    const T = e.get(p);\n    return T ? { ...T } : void 0;\n  }, b = (p) => {\n    const T = t.get(p);\n    if (T) {\n      const S = E(T).bodies.find((M) => M.id === p);\n      if (S)\n        return S;\n      console.error(`Store integrity error: body ${p} in index, but not in annotation`);\n    } else\n      console.warn(`Attempt to retrieve missing body: ${p}`);\n  }, A = (p, T) => {\n    if (p.annotation !== T.annotation)\n      throw \"Annotation integrity violation: annotation ID must be the same when updating bodies\";\n    const S = e.get(p.annotation);\n    if (S) {\n      const M = S.bodies.find((X) => X.id === p.id), O = {\n        ...S,\n        bodies: S.bodies.map((X) => X.id === M.id ? T : X)\n      };\n      return e.set(S.id, O), M.id !== T.id && (t.delete(M.id), t.set(T.id, O.id)), {\n        oldValue: S,\n        newValue: O,\n        bodiesUpdated: [{ oldBody: M, newBody: T }]\n      };\n    } else\n      console.warn(`Attempt to add body to missing annotation ${p.annotation}`);\n  }, L = (p, T, S = G.LOCAL) => {\n    const M = A(p, T);\n    M && s(S, { updated: [M] });\n  }, D = (p, T = G.LOCAL) => {\n    const S = p.map((M) => A({ id: M.id, annotation: M.annotation }, M)).filter(Boolean);\n    s(T, { updated: S });\n  }, R = (p) => {\n    const T = e.get(p.annotation);\n    if (T) {\n      const S = {\n        ...T,\n        target: {\n          ...T.target,\n          ...p\n        }\n      };\n      return e.set(T.id, S), {\n        oldValue: T,\n        newValue: S,\n        targetUpdated: {\n          oldTarget: T.target,\n          newTarget: p\n        }\n      };\n    } else\n      console.warn(`Attempt to update target on missing annotation: ${p.annotation}`);\n  };\n  return {\n    addAnnotation: r,\n    addBody: u,\n    all: f,\n    bulkAddAnnotation: g,\n    bulkDeleteAnnotation: w,\n    bulkUpdateAnnotation: c,\n    bulkUpdateBodies: D,\n    bulkUpdateTargets: (p, T = G.LOCAL) => {\n      const S = p.map((M) => R(M)).filter(Boolean);\n      S.length > 0 && s(T, { updated: S });\n    },\n    clear: h,\n    deleteAnnotation: _,\n    deleteBody: y,\n    getAnnotation: E,\n    getBody: b,\n    observe: o,\n    unobserve: i,\n    updateAnnotation: a,\n    updateBody: L,\n    updateTarget: (p, T = G.LOCAL) => {\n      const S = R(p);\n      S && s(T, { updated: [S] });\n    }\n  };\n}, Wn = (e) => ({\n  ...e,\n  subscribe: (t) => {\n    const n = (o) => t(o.state);\n    return e.observe(n), t(e.all()), () => e.unobserve(n);\n  }\n});\nlet Jn = () => ({\n  emit(e, ...t) {\n    for (let n = 0, o = this.events[e] || [], i = o.length; n < i; n++)\n      o[n](...t);\n  },\n  events: {},\n  on(e, t) {\n    var n;\n    return ((n = this.events)[e] || (n[e] = [])).push(t), () => {\n      var o;\n      this.events[e] = (o = this.events[e]) == null ? void 0 : o.filter((i) => t !== i);\n    };\n  }\n});\nconst Zn = 250, Qn = (e) => {\n  const t = Jn(), n = [];\n  let o = -1, i = !1, s = 0;\n  const r = (g) => {\n    if (!i) {\n      const { changes: m } = g, _ = performance.now();\n      if (_ - s > Zn)\n        n.splice(o + 1), n.push(m), o = n.length - 1;\n      else {\n        const w = n.length - 1;\n        n[w] = jn(n[w], m);\n      }\n      s = _;\n    }\n    i = !1;\n  };\n  e.observe(r, { origin: G.LOCAL });\n  const l = (g) => g && g.length > 0 && e.bulkDeleteAnnotation(g), a = (g) => g && g.length > 0 && e.bulkAddAnnotation(g, !1), c = (g) => g && g.length > 0 && e.bulkUpdateAnnotation(g.map(({ oldValue: m }) => m)), u = (g) => g && g.length > 0 && e.bulkUpdateAnnotation(g.map(({ newValue: m }) => m)), f = (g) => g && g.length > 0 && e.bulkAddAnnotation(g, !1), h = (g) => g && g.length > 0 && e.bulkDeleteAnnotation(g);\n  return {\n    canRedo: () => n.length - 1 > o,\n    canUndo: () => o > -1,\n    destroy: () => e.unobserve(r),\n    on: (g, m) => t.on(g, m),\n    redo: () => {\n      if (n.length - 1 > o) {\n        i = !0;\n        const { created: g, updated: m, deleted: _ } = n[o + 1];\n        a(g), u(m), h(_), t.emit(\"redo\", n[o + 1]), o += 1;\n      }\n    },\n    undo: () => {\n      if (o > -1) {\n        i = !0;\n        const { created: g, updated: m, deleted: _ } = n[o];\n        l(g), c(m), f(_), t.emit(\"undo\", n[o]), o -= 1;\n      }\n    }\n  };\n}, xn = () => {\n  const { subscribe: e, set: t } = ct([]);\n  return {\n    subscribe: e,\n    set: t\n  };\n}, $n = (e, t, n, o) => {\n  const { store: i, selection: s, hover: r, viewport: l } = e, a = /* @__PURE__ */ new Map();\n  let c = [], u, f;\n  const h = (y, E) => {\n    a.has(y) ? a.get(y).push(E) : a.set(y, [E]);\n  }, g = (y, E) => {\n    const b = a.get(y);\n    b && b.indexOf(E) > 0 && b.splice(b.indexOf(E), 1);\n  }, m = (y, E, b) => {\n    a.has(y) && setTimeout(() => {\n      a.get(y).forEach((A) => {\n        if (n) {\n          const L = Array.isArray(E) ? E.map((R) => n.serialize(R)) : n.serialize(E), D = b ? b instanceof PointerEvent ? b : n.serialize(b) : void 0;\n          A(L, D);\n        } else\n          A(E, b);\n      });\n    }, 1);\n  }, _ = () => {\n    const { selected: y } = s, E = (y || []).map(({ id: b }) => i.getAnnotation(b));\n    E.forEach((b) => {\n      const A = c.find((L) => L.id === b.id);\n      (!A || !he(A, b)) && m(\"updateAnnotation\", b, A);\n    }), c = c.map((b) => E.find(({ id: L }) => L === b.id) || b);\n  };\n  s.subscribe(({ selected: y }) => {\n    if (!(c.length === 0 && y.length === 0)) {\n      if (c.length === 0 && y.length > 0)\n        c = y.map(({ id: E }) => i.getAnnotation(E));\n      else if (c.length > 0 && y.length === 0)\n        c.forEach((E) => {\n          const b = i.getAnnotation(E.id);\n          b && !he(b, E) && m(\"updateAnnotation\", b, E);\n        }), c = [];\n      else {\n        const E = new Set(c.map((A) => A.id)), b = new Set(y.map(({ id: A }) => A));\n        c.filter((A) => !b.has(A.id)).forEach((A) => {\n          const L = i.getAnnotation(A.id);\n          L && !he(L, A) && m(\"updateAnnotation\", L, A);\n        }), c = [\n          // Remove annotations that were deselected\n          ...c.filter((A) => b.has(A.id)),\n          // Add editable annotations that were selected\n          ...y.filter(({ id: A }) => !E.has(A)).map(({ id: A }) => i.getAnnotation(A))\n        ];\n      }\n      m(\"selectionChanged\", c);\n    }\n  }), r.subscribe((y) => {\n    !u && y ? m(\"mouseEnterAnnotation\", i.getAnnotation(y)) : u && !y ? m(\"mouseLeaveAnnotation\", i.getAnnotation(u)) : u && y && (m(\"mouseLeaveAnnotation\", i.getAnnotation(u)), m(\"mouseEnterAnnotation\", i.getAnnotation(y))), u = y;\n  }), l == null || l.subscribe((y) => m(\"viewportIntersect\", y.map((E) => i.getAnnotation(E)))), i.observe((y) => {\n    o && (f && clearTimeout(f), f = setTimeout(_, 1e3));\n    const { created: E, deleted: b } = y.changes;\n    (E || []).forEach((A) => m(\"createAnnotation\", A)), (b || []).forEach((A) => m(\"deleteAnnotation\", A)), (y.changes.updated || []).filter((A) => [\n      ...A.bodiesCreated || [],\n      ...A.bodiesDeleted || [],\n      ...A.bodiesUpdated || []\n    ].length > 0).forEach(({ oldValue: A, newValue: L }) => {\n      const D = c.find((R) => R.id === A.id) || A;\n      c = c.map((R) => R.id === A.id ? L : R), m(\"updateAnnotation\", L, D);\n    });\n  }, { origin: G.LOCAL }), i.observe((y) => {\n    if (c) {\n      const E = new Set(c.map((A) => A.id)), b = (y.changes.updated || []).filter(({ newValue: A }) => E.has(A.id)).map(({ newValue: A }) => A);\n      b.length > 0 && (c = c.map((A) => b.find((D) => D.id === A.id) || A));\n    }\n  }, { origin: G.REMOTE });\n  const w = (y) => (E) => {\n    const { created: b, deleted: A, updated: L } = E;\n    (b || []).forEach((D) => m(\"createAnnotation\", D)), (A || []).forEach((D) => m(\"deleteAnnotation\", D)), y ? (L || []).forEach((D) => m(\"updateAnnotation\", D.oldValue, D.newValue)) : (L || []).forEach((D) => m(\"updateAnnotation\", D.newValue, D.oldValue));\n  };\n  return t.on(\"undo\", w(!0)), t.on(\"redo\", w(!1)), { on: h, off: g, emit: m };\n}, eo = (e) => (t) => t.reduce((n, o) => {\n  const { parsed: i, error: s } = e.parse(o);\n  return s ? {\n    parsed: n.parsed,\n    failed: [...n.failed, o]\n  } : i ? {\n    parsed: [...n.parsed, i],\n    failed: n.failed\n  } : {\n    ...n\n  };\n}, { parsed: [], failed: [] }), to = (e, t, n) => {\n  const { store: o, selection: i } = e, s = (w) => {\n    if (n) {\n      const { parsed: y, error: E } = n.parse(w);\n      y ? o.addAnnotation(y, G.REMOTE) : console.error(E);\n    } else\n      o.addAnnotation(w, G.REMOTE);\n  }, r = () => i.clear(), l = () => o.clear(), a = (w) => {\n    const y = o.getAnnotation(w);\n    return n && y ? n.serialize(y) : y;\n  }, c = () => n ? o.all().map(n.serialize) : o.all(), u = () => {\n    var w;\n    const y = (((w = i.selected) == null ? void 0 : w.map((E) => E.id)) || []).map((E) => o.getAnnotation(E)).filter(Boolean);\n    return n ? y.map(n.serialize) : y;\n  }, f = (w) => fetch(w).then((y) => y.json()).then((y) => (g(y), y)), h = (w) => {\n    if (typeof w == \"string\") {\n      const y = o.getAnnotation(w);\n      if (o.deleteAnnotation(w), y)\n        return n ? n.serialize(y) : y;\n    } else {\n      const y = n ? n.parse(w).parsed : w;\n      if (y)\n        return o.deleteAnnotation(y), w;\n    }\n  }, g = (w) => {\n    if (n) {\n      const { parsed: y, failed: E } = eo(n)(w);\n      E.length > 0 && console.warn(`Discarded ${E.length} invalid annotations`, E), o.bulkAddAnnotation(y, !0, G.REMOTE);\n    } else\n      o.bulkAddAnnotation(w, !0, G.REMOTE);\n  }, m = (w) => {\n    w ? i.setSelected(w) : i.clear();\n  }, _ = (w) => {\n    if (n) {\n      const y = n.parse(w).parsed, E = n.serialize(o.getAnnotation(y.id));\n      return o.updateAnnotation(y), E;\n    } else {\n      const y = o.getAnnotation(w.id);\n      return o.updateAnnotation(w), y;\n    }\n  };\n  return {\n    addAnnotation: s,\n    cancelSelected: r,\n    canRedo: t.canRedo,\n    canUndo: t.canUndo,\n    clearAnnotations: l,\n    getAnnotationById: a,\n    getAnnotations: c,\n    getSelected: u,\n    loadAnnotations: f,\n    redo: t.redo,\n    removeAnnotation: h,\n    setAnnotations: g,\n    setSelected: m,\n    undo: t.undo,\n    updateAnnotation: _\n  };\n};\nlet no = (e) => crypto.getRandomValues(new Uint8Array(e)), oo = (e, t, n) => {\n  let o = (2 << Math.log(e.length - 1) / Math.LN2) - 1, i = -~(1.6 * o * t / e.length);\n  return (s = t) => {\n    let r = \"\";\n    for (; ; ) {\n      let l = n(i), a = i;\n      for (; a--; )\n        if (r += e[l[a] & o] || \"\", r.length === s)\n          return r;\n    }\n  };\n}, io = (e, t = 21) => oo(e, t, no), so = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, n) => (n &= 63, n < 36 ? t += n.toString(36) : n < 62 ? t += (n - 26).toString(36).toUpperCase() : n > 62 ? t += \"-\" : t += \"_\", t), \"\");\nconst ro = () => ({ isGuest: !0, id: io(\"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\", 20)() }), lo = (e) => {\n  const t = JSON.stringify(e);\n  let n = 0;\n  for (let o = 0, i = t.length; o < i; o++) {\n    let s = t.charCodeAt(o);\n    n = (n << 5) - n + s, n |= 0;\n  }\n  return `${n}`;\n}, Jt = (e) => e ? typeof e == \"object\" ? { ...e } : e : void 0, ao = (e, t) => (Array.isArray(e) ? e : [e]).map((n) => {\n  const { id: o, type: i, purpose: s, value: r, created: l, creator: a, ...c } = n;\n  return {\n    id: o || `temp-${lo(n)}`,\n    annotation: t,\n    type: i,\n    purpose: s,\n    value: r,\n    created: l ? new Date(l) : void 0,\n    creator: Jt(a),\n    ...c\n  };\n}), co = (e) => e.map((t) => {\n  var n, o;\n  const i = { ...t };\n  return delete i.annotation, (n = i.id) != null && n.startsWith(\"temp-\") && delete i.id, { ...i, created: (o = i.created) == null ? void 0 : o.toISOString() };\n});\nso();\nconst Pi = (e, t = !1) => ({ parse: (i) => fo(i, t), serialize: (i) => uo(i, e) }), fo = (e, t = !1) => {\n  const n = e.id || qt(), {\n    creator: o,\n    created: i,\n    modified: s,\n    body: r,\n    ...l\n  } = e, a = ao(r, n), c = Array.isArray(e.target) ? e.target[0] : e.target, u = Array.isArray(c.selector) ? c.selector[0] : c.selector, f = (u == null ? void 0 : u.type) === \"FragmentSelector\" ? Sn(u, t) : (u == null ? void 0 : u.type) === \"SvgSelector\" ? On(u) : void 0;\n  return f ? {\n    parsed: {\n      ...l,\n      id: n,\n      bodies: a,\n      target: {\n        created: i ? new Date(i) : void 0,\n        creator: Jt(o),\n        updated: s ? new Date(s) : void 0,\n        ...Array.isArray(l.target) ? l.target[0] : l.target,\n        annotation: n,\n        selector: f\n      }\n    }\n  } : {\n    error: Error(`Invalid selector: ${JSON.stringify(u)}`)\n  };\n}, uo = (e, t) => {\n  const {\n    selector: n,\n    creator: o,\n    created: i,\n    updated: s,\n    updatedBy: r,\n    // Excluded from serialization\n    ...l\n  } = e.target, a = n.type == j.RECTANGLE ? Tn(n.geometry) : Bn(n), c = {\n    ...e,\n    \"@context\": \"http://www.w3.org/ns/anno.jsonld\",\n    id: e.id,\n    type: \"Annotation\",\n    body: co(e.bodies),\n    created: i == null ? void 0 : i.toISOString(),\n    creator: o,\n    modified: s == null ? void 0 : s.toISOString(),\n    target: {\n      ...l,\n      source: t,\n      selector: a\n    }\n  };\n  return delete c.bodies, \"annotation\" in c.target && delete c.target.annotation, c;\n};\nfunction wt(e, t, n) {\n  const o = e.slice();\n  return o[10] = t[n], o[12] = n, o;\n}\nfunction bt(e) {\n  let t, n;\n  return t = new Le({\n    props: {\n      x: (\n        /*point*/\n        e[10][0]\n      ),\n      y: (\n        /*point*/\n        e[10][1]\n      ),\n      scale: (\n        /*viewportScale*/\n        e[3]\n      )\n    }\n  }), t.$on(\"pointerdown\", function() {\n    q(\n      /*grab*/\n      e[9](`HANDLE-${/*idx*/\n      e[12]}`)\n    ) && e[9](`HANDLE-${/*idx*/\n    e[12]}`).apply(this, arguments);\n  }), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, i) {\n      e = o;\n      const s = {};\n      i & /*geom*/\n      16 && (s.x = /*point*/\n      e[10][0]), i & /*geom*/\n      16 && (s.y = /*point*/\n      e[10][1]), i & /*viewportScale*/\n      8 && (s.scale = /*viewportScale*/\n      e[3]), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction ho(e) {\n  let t, n, o, i, s, r, l, a, c, u, f, h = Se(\n    /*geom*/\n    e[4].points\n  ), g = [];\n  for (let _ = 0; _ < h.length; _ += 1)\n    g[_] = bt(wt(e, h, _));\n  const m = (_) => C(g[_], 1, 1, () => {\n    g[_] = null;\n  });\n  return {\n    c() {\n      t = U(\"polygon\"), i = oe(), s = U(\"polygon\"), l = oe();\n      for (let _ = 0; _ < g.length; _ += 1)\n        g[_].c();\n      a = ce(), d(t, \"class\", \"a9s-outer\"), d(t, \"style\", n = /*computedStyle*/\n      e[1] ? \"display:none;\" : void 0), d(t, \"points\", o = /*geom*/\n      e[4].points.map(Et).join(\" \")), d(s, \"class\", \"a9s-inner a9s-shape-handle\"), d(\n        s,\n        \"style\",\n        /*computedStyle*/\n        e[1]\n      ), d(s, \"points\", r = /*geom*/\n      e[4].points.map(At).join(\" \"));\n    },\n    m(_, w) {\n      B(_, t, w), B(_, i, w), B(_, s, w), B(_, l, w);\n      for (let y = 0; y < g.length; y += 1)\n        g[y] && g[y].m(_, w);\n      B(_, a, w), c = !0, u || (f = [\n        F(t, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"SHAPE\")\n          ) && e[9](\"SHAPE\").apply(this, arguments);\n        }),\n        F(s, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"SHAPE\")\n          ) && e[9](\"SHAPE\").apply(this, arguments);\n        })\n      ], u = !0);\n    },\n    p(_, w) {\n      if (e = _, (!c || w & /*computedStyle*/\n      2 && n !== (n = /*computedStyle*/\n      e[1] ? \"display:none;\" : void 0)) && d(t, \"style\", n), (!c || w & /*geom*/\n      16 && o !== (o = /*geom*/\n      e[4].points.map(Et).join(\" \"))) && d(t, \"points\", o), (!c || w & /*computedStyle*/\n      2) && d(\n        s,\n        \"style\",\n        /*computedStyle*/\n        e[1]\n      ), (!c || w & /*geom*/\n      16 && r !== (r = /*geom*/\n      e[4].points.map(At).join(\" \"))) && d(s, \"points\", r), w & /*geom, viewportScale, grab*/\n      536) {\n        h = Se(\n          /*geom*/\n          e[4].points\n        );\n        let y;\n        for (y = 0; y < h.length; y += 1) {\n          const E = wt(e, h, y);\n          g[y] ? (g[y].p(E, w), P(g[y], 1)) : (g[y] = bt(E), g[y].c(), P(g[y], 1), g[y].m(a.parentNode, a));\n        }\n        for (re(), y = h.length; y < g.length; y += 1)\n          m(y);\n        le();\n      }\n    },\n    i(_) {\n      if (!c) {\n        for (let w = 0; w < h.length; w += 1)\n          P(g[w]);\n        c = !0;\n      }\n    },\n    o(_) {\n      g = g.filter(Boolean);\n      for (let w = 0; w < g.length; w += 1)\n        C(g[w]);\n      c = !1;\n    },\n    d(_) {\n      _ && (k(t), k(i), k(s), k(l), k(a)), rt(g, _), u = !1, ae(f);\n    }\n  };\n}\nfunction go(e) {\n  let t, n;\n  return t = new Qt({\n    props: {\n      shape: (\n        /*shape*/\n        e[0]\n      ),\n      transform: (\n        /*transform*/\n        e[2]\n      ),\n      editor: (\n        /*editor*/\n        e[5]\n      ),\n      $$slots: {\n        default: [\n          ho,\n          ({ grab: o }) => ({ 9: o }),\n          ({ grab: o }) => o ? 512 : 0\n        ]\n      },\n      $$scope: { ctx: e }\n    }\n  }), t.$on(\n    \"change\",\n    /*change_handler*/\n    e[6]\n  ), t.$on(\n    \"grab\",\n    /*grab_handler*/\n    e[7]\n  ), t.$on(\n    \"release\",\n    /*release_handler*/\n    e[8]\n  ), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, [i]) {\n      const s = {};\n      i & /*shape*/\n      1 && (s.shape = /*shape*/\n      o[0]), i & /*transform*/\n      4 && (s.transform = /*transform*/\n      o[2]), i & /*$$scope, geom, viewportScale, grab, computedStyle*/\n      8730 && (s.$$scope = { dirty: i, ctx: o }), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nconst Et = (e) => e.join(\",\"), At = (e) => e.join(\",\");\nfunction mo(e, t, n) {\n  let o, { shape: i } = t, { computedStyle: s } = t, { transform: r } = t, { viewportScale: l = 1 } = t;\n  const a = (h, g, m) => {\n    let _;\n    const w = h.geometry;\n    g === \"SHAPE\" ? _ = w.points.map(([E, b]) => [E + m[0], b + m[1]]) : _ = w.points.map(([E, b], A) => g === `HANDLE-${A}` ? [E + m[0], b + m[1]] : [E, b]);\n    const y = Fe(_);\n    return { ...h, geometry: { points: _, bounds: y } };\n  };\n  function c(h) {\n    ue.call(this, e, h);\n  }\n  function u(h) {\n    ue.call(this, e, h);\n  }\n  function f(h) {\n    ue.call(this, e, h);\n  }\n  return e.$$set = (h) => {\n    \"shape\" in h && n(0, i = h.shape), \"computedStyle\" in h && n(1, s = h.computedStyle), \"transform\" in h && n(2, r = h.transform), \"viewportScale\" in h && n(3, l = h.viewportScale);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*shape*/\n    1 && n(4, o = i.geometry);\n  }, [\n    i,\n    s,\n    r,\n    l,\n    o,\n    a,\n    c,\n    u,\n    f\n  ];\n}\nclass po extends te {\n  constructor(t) {\n    super(), ee(this, t, mo, go, W, {\n      shape: 0,\n      computedStyle: 1,\n      transform: 2,\n      viewportScale: 3\n    });\n  }\n}\nconst Qe = (e, t) => {\n  const n = Math.abs(t[0] - e[0]), o = Math.abs(t[1] - e[1]);\n  return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2));\n}, _e = [];\nfunction yo(e, t = V) {\n  let n;\n  const o = /* @__PURE__ */ new Set();\n  function i(l) {\n    if (W(e, l) && (e = l, n)) {\n      const a = !_e.length;\n      for (const c of o)\n        c[1](), _e.push(c, e);\n      if (a) {\n        for (let c = 0; c < _e.length; c += 2)\n          _e[c][0](_e[c + 1]);\n        _e.length = 0;\n      }\n    }\n  }\n  function s(l) {\n    i(l(e));\n  }\n  function r(l, a = V) {\n    const c = [l, a];\n    return o.add(c), o.size === 1 && (n = t(i, s) || V), l(e), () => {\n      o.delete(c), o.size === 0 && n && (n(), n = null);\n    };\n  }\n  return { set: i, update: s, subscribe: r };\n}\nconst _o = (e, t) => {\n  const { naturalWidth: n, naturalHeight: o } = e;\n  if (!n && !o) {\n    const { width: i, height: s } = e;\n    t.setAttribute(\"viewBox\", `0 0 ${i} ${s}`), e.addEventListener(\"load\", (r) => {\n      const l = r.target;\n      t.setAttribute(\"viewBox\", `0 0 ${l.naturalWidth} ${l.naturalHeight}`);\n    });\n  } else\n    t.setAttribute(\"viewBox\", `0 0 ${n} ${o}`);\n}, wo = (e, t) => {\n  _o(e, t);\n  const { subscribe: n, set: o } = yo(1);\n  let i;\n  return window.ResizeObserver && (i = new ResizeObserver(() => {\n    const r = t.getBoundingClientRect(), { width: l, height: a } = t.viewBox.baseVal, c = Math.max(\n      r.width / l,\n      r.height / a\n    );\n    o(c);\n  }), i.observe(t.parentElement)), { destroy: () => {\n    i && i.disconnect();\n  }, subscribe: n };\n}, bo = \"ontouchstart\" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;\nfunction Eo(e) {\n  let t, n, o, i, s, r;\n  return {\n    c() {\n      t = U(\"rect\"), d(t, \"class\", n = Ge(`a9s-handle ${/*$$props*/\n      e[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\"), d(t, \"x\", o = /*x*/\n      e[0] - /*handleSize*/\n      e[5] / 2), d(t, \"y\", i = /*y*/\n      e[1] - /*handleSize*/\n      e[5] / 2), d(\n        t,\n        \"width\",\n        /*handleSize*/\n        e[5]\n      ), d(\n        t,\n        \"height\",\n        /*handleSize*/\n        e[5]\n      );\n    },\n    m(l, a) {\n      B(l, t, a), s || (r = F(\n        t,\n        \"pointerdown\",\n        /*pointerdown_handler_2*/\n        e[11]\n      ), s = !0);\n    },\n    p(l, a) {\n      a & /*$$props*/\n      256 && n !== (n = Ge(`a9s-handle ${/*$$props*/\n      l[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\") && d(t, \"class\", n), a & /*x, handleSize*/\n      33 && o !== (o = /*x*/\n      l[0] - /*handleSize*/\n      l[5] / 2) && d(t, \"x\", o), a & /*y, handleSize*/\n      34 && i !== (i = /*y*/\n      l[1] - /*handleSize*/\n      l[5] / 2) && d(t, \"y\", i), a & /*handleSize*/\n      32 && d(\n        t,\n        \"width\",\n        /*handleSize*/\n        l[5]\n      ), a & /*handleSize*/\n      32 && d(\n        t,\n        \"height\",\n        /*handleSize*/\n        l[5]\n      );\n    },\n    d(l) {\n      l && k(t), s = !1, r();\n    }\n  };\n}\nfunction Ao(e) {\n  let t, n, o, i, s, r, l, a, c;\n  return {\n    c() {\n      t = U(\"g\"), n = U(\"circle\"), i = U(\"rect\"), d(\n        n,\n        \"cx\",\n        /*x*/\n        e[0]\n      ), d(\n        n,\n        \"cy\",\n        /*y*/\n        e[1]\n      ), d(n, \"r\", o = /*radius*/\n      e[3] / /*scale*/\n      e[2]), d(n, \"class\", \"a9s-touch-halo svelte-1sgkh33\"), ze(\n        n,\n        \"touched\",\n        /*touched*/\n        e[4]\n      ), d(i, \"class\", s = Ge(`a9s-handle ${/*$$props*/\n      e[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\"), d(i, \"x\", r = /*x*/\n      e[0] - /*handleSize*/\n      e[5] / 2), d(i, \"y\", l = /*y*/\n      e[1] - /*handleSize*/\n      e[5] / 2), d(\n        i,\n        \"width\",\n        /*handleSize*/\n        e[5]\n      ), d(\n        i,\n        \"height\",\n        /*handleSize*/\n        e[5]\n      ), d(t, \"class\", \"a9s-touch-handle\");\n    },\n    m(u, f) {\n      B(u, t, f), se(t, n), se(t, i), a || (c = [\n        F(\n          n,\n          \"pointerdown\",\n          /*pointerdown_handler*/\n          e[10]\n        ),\n        F(\n          n,\n          \"pointerdown\",\n          /*onPointerDown*/\n          e[6]\n        ),\n        F(\n          n,\n          \"pointerup\",\n          /*onPointerUp*/\n          e[7]\n        ),\n        F(\n          i,\n          \"pointerdown\",\n          /*pointerdown_handler_1*/\n          e[9]\n        ),\n        F(\n          i,\n          \"pointerdown\",\n          /*onPointerDown*/\n          e[6]\n        ),\n        F(\n          i,\n          \"pointerup\",\n          /*onPointerUp*/\n          e[7]\n        )\n      ], a = !0);\n    },\n    p(u, f) {\n      f & /*x*/\n      1 && d(\n        n,\n        \"cx\",\n        /*x*/\n        u[0]\n      ), f & /*y*/\n      2 && d(\n        n,\n        \"cy\",\n        /*y*/\n        u[1]\n      ), f & /*radius, scale*/\n      12 && o !== (o = /*radius*/\n      u[3] / /*scale*/\n      u[2]) && d(n, \"r\", o), f & /*touched*/\n      16 && ze(\n        n,\n        \"touched\",\n        /*touched*/\n        u[4]\n      ), f & /*$$props*/\n      256 && s !== (s = Ge(`a9s-handle ${/*$$props*/\n      u[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\") && d(i, \"class\", s), f & /*x, handleSize*/\n      33 && r !== (r = /*x*/\n      u[0] - /*handleSize*/\n      u[5] / 2) && d(i, \"x\", r), f & /*y, handleSize*/\n      34 && l !== (l = /*y*/\n      u[1] - /*handleSize*/\n      u[5] / 2) && d(i, \"y\", l), f & /*handleSize*/\n      32 && d(\n        i,\n        \"width\",\n        /*handleSize*/\n        u[5]\n      ), f & /*handleSize*/\n      32 && d(\n        i,\n        \"height\",\n        /*handleSize*/\n        u[5]\n      );\n    },\n    d(u) {\n      u && k(t), a = !1, ae(c);\n    }\n  };\n}\nfunction So(e) {\n  let t;\n  function n(s, r) {\n    return bo ? Ao : Eo;\n  }\n  let i = n()(e);\n  return {\n    c() {\n      i.c(), t = ce();\n    },\n    m(s, r) {\n      i.m(s, r), B(s, t, r);\n    },\n    p(s, [r]) {\n      i.p(s, r);\n    },\n    i: V,\n    o: V,\n    d(s) {\n      s && k(t), i.d(s);\n    }\n  };\n}\nfunction To(e, t, n) {\n  let o, { x: i } = t, { y: s } = t, { scale: r } = t, { radius: l = 30 } = t, a = !1;\n  const c = (m) => {\n    m.pointerType === \"touch\" && n(4, a = !0);\n  }, u = () => n(4, a = !1);\n  function f(m) {\n    ue.call(this, e, m);\n  }\n  function h(m) {\n    ue.call(this, e, m);\n  }\n  function g(m) {\n    ue.call(this, e, m);\n  }\n  return e.$$set = (m) => {\n    n(8, t = nt(nt({}, t), gt(m))), \"x\" in m && n(0, i = m.x), \"y\" in m && n(1, s = m.y), \"scale\" in m && n(2, r = m.scale), \"radius\" in m && n(3, l = m.radius);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*scale*/\n    4 && n(5, o = 10 / r);\n  }, t = gt(t), [\n    i,\n    s,\n    r,\n    l,\n    a,\n    o,\n    c,\n    u,\n    t,\n    f,\n    h,\n    g\n  ];\n}\nclass Le extends te {\n  constructor(t) {\n    super(), ee(this, t, To, So, W, { x: 0, y: 1, scale: 2, radius: 3 });\n  }\n}\nfunction Mo(e) {\n  let t, n, o, i, s, r, l, a, c, u, f, h, g, m, _, w, y, E, b, A, L, D, R, p, T, S, M, O, X, Z, ge, me, Me, ie, I, z, H, J, fe, ne, N, qe, ut;\n  return ie = new Le({\n    props: {\n      class: \"a9s-corner-handle-topleft\",\n      x: (\n        /*geom*/\n        e[4].x\n      ),\n      y: (\n        /*geom*/\n        e[4].y\n      ),\n      scale: (\n        /*viewportScale*/\n        e[3]\n      )\n    }\n  }), ie.$on(\"pointerdown\", function() {\n    q(\n      /*grab*/\n      e[9](\"TOP_LEFT\")\n    ) && e[9](\"TOP_LEFT\").apply(this, arguments);\n  }), z = new Le({\n    props: {\n      class: \"a9s-corner-handle-topright\",\n      x: (\n        /*geom*/\n        e[4].x + /*geom*/\n        e[4].w\n      ),\n      y: (\n        /*geom*/\n        e[4].y\n      ),\n      scale: (\n        /*viewportScale*/\n        e[3]\n      )\n    }\n  }), z.$on(\"pointerdown\", function() {\n    q(\n      /*grab*/\n      e[9](\"TOP_RIGHT\")\n    ) && e[9](\"TOP_RIGHT\").apply(this, arguments);\n  }), J = new Le({\n    props: {\n      class: \"a9s-corner-handle-bottomright\",\n      x: (\n        /*geom*/\n        e[4].x + /*geom*/\n        e[4].w\n      ),\n      y: (\n        /*geom*/\n        e[4].y + /*geom*/\n        e[4].h\n      ),\n      scale: (\n        /*viewportScale*/\n        e[3]\n      )\n    }\n  }), J.$on(\"pointerdown\", function() {\n    q(\n      /*grab*/\n      e[9](\"BOTTOM_RIGHT\")\n    ) && e[9](\"BOTTOM_RIGHT\").apply(this, arguments);\n  }), ne = new Le({\n    props: {\n      class: \"a9s-corner-handle-bottomleft\",\n      x: (\n        /*geom*/\n        e[4].x\n      ),\n      y: (\n        /*geom*/\n        e[4].y + /*geom*/\n        e[4].h\n      ),\n      scale: (\n        /*viewportScale*/\n        e[3]\n      )\n    }\n  }), ne.$on(\"pointerdown\", function() {\n    q(\n      /*grab*/\n      e[9](\"BOTTOM_LEFT\")\n    ) && e[9](\"BOTTOM_LEFT\").apply(this, arguments);\n  }), {\n    c() {\n      t = U(\"rect\"), l = oe(), a = U(\"rect\"), g = oe(), m = U(\"rect\"), E = oe(), b = U(\"rect\"), R = oe(), p = U(\"rect\"), O = oe(), X = U(\"rect\"), Me = oe(), $(ie.$$.fragment), I = oe(), $(z.$$.fragment), H = oe(), $(J.$$.fragment), fe = oe(), $(ne.$$.fragment), d(t, \"class\", \"a9s-outer\"), d(t, \"style\", n = /*computedStyle*/\n      e[1] ? \"display:none;\" : void 0), d(t, \"x\", o = /*geom*/\n      e[4].x), d(t, \"y\", i = /*geom*/\n      e[4].y), d(t, \"width\", s = /*geom*/\n      e[4].w), d(t, \"height\", r = /*geom*/\n      e[4].h), d(a, \"class\", \"a9s-inner a9s-shape-handle\"), d(\n        a,\n        \"style\",\n        /*computedStyle*/\n        e[1]\n      ), d(a, \"x\", c = /*geom*/\n      e[4].x), d(a, \"y\", u = /*geom*/\n      e[4].y), d(a, \"width\", f = /*geom*/\n      e[4].w), d(a, \"height\", h = /*geom*/\n      e[4].h), d(m, \"class\", \"a9s-edge-handle a9s-edge-handle-top\"), d(m, \"x\", _ = /*geom*/\n      e[4].x), d(m, \"y\", w = /*geom*/\n      e[4].y), d(m, \"height\", 1), d(m, \"width\", y = /*geom*/\n      e[4].w), d(b, \"class\", \"a9s-edge-handle a9s-edge-handle-right\"), d(b, \"x\", A = /*geom*/\n      e[4].x + /*geom*/\n      e[4].w), d(b, \"y\", L = /*geom*/\n      e[4].y), d(b, \"height\", D = /*geom*/\n      e[4].h), d(b, \"width\", 1), d(p, \"class\", \"a9s-edge-handle a9s-edge-handle-bottom\"), d(p, \"x\", T = /*geom*/\n      e[4].x), d(p, \"y\", S = /*geom*/\n      e[4].y + /*geom*/\n      e[4].h), d(p, \"height\", 1), d(p, \"width\", M = /*geom*/\n      e[4].w), d(X, \"class\", \"a9s-edge-handle a9s-edge-handle-left\"), d(X, \"x\", Z = /*geom*/\n      e[4].x), d(X, \"y\", ge = /*geom*/\n      e[4].y), d(X, \"height\", me = /*geom*/\n      e[4].h), d(X, \"width\", 1);\n    },\n    m(Y, v) {\n      B(Y, t, v), B(Y, l, v), B(Y, a, v), B(Y, g, v), B(Y, m, v), B(Y, E, v), B(Y, b, v), B(Y, R, v), B(Y, p, v), B(Y, O, v), B(Y, X, v), B(Y, Me, v), Q(ie, Y, v), B(Y, I, v), Q(z, Y, v), B(Y, H, v), Q(J, Y, v), B(Y, fe, v), Q(ne, Y, v), N = !0, qe || (ut = [\n        F(t, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"SHAPE\")\n          ) && e[9](\"SHAPE\").apply(this, arguments);\n        }),\n        F(a, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"SHAPE\")\n          ) && e[9](\"SHAPE\").apply(this, arguments);\n        }),\n        F(m, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"TOP\")\n          ) && e[9](\"TOP\").apply(this, arguments);\n        }),\n        F(b, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"RIGHT\")\n          ) && e[9](\"RIGHT\").apply(this, arguments);\n        }),\n        F(p, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"BOTTOM\")\n          ) && e[9](\"BOTTOM\").apply(this, arguments);\n        }),\n        F(X, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"LEFT\")\n          ) && e[9](\"LEFT\").apply(this, arguments);\n        })\n      ], qe = !0);\n    },\n    p(Y, v) {\n      e = Y, (!N || v & /*computedStyle*/\n      2 && n !== (n = /*computedStyle*/\n      e[1] ? \"display:none;\" : void 0)) && d(t, \"style\", n), (!N || v & /*geom*/\n      16 && o !== (o = /*geom*/\n      e[4].x)) && d(t, \"x\", o), (!N || v & /*geom*/\n      16 && i !== (i = /*geom*/\n      e[4].y)) && d(t, \"y\", i), (!N || v & /*geom*/\n      16 && s !== (s = /*geom*/\n      e[4].w)) && d(t, \"width\", s), (!N || v & /*geom*/\n      16 && r !== (r = /*geom*/\n      e[4].h)) && d(t, \"height\", r), (!N || v & /*computedStyle*/\n      2) && d(\n        a,\n        \"style\",\n        /*computedStyle*/\n        e[1]\n      ), (!N || v & /*geom*/\n      16 && c !== (c = /*geom*/\n      e[4].x)) && d(a, \"x\", c), (!N || v & /*geom*/\n      16 && u !== (u = /*geom*/\n      e[4].y)) && d(a, \"y\", u), (!N || v & /*geom*/\n      16 && f !== (f = /*geom*/\n      e[4].w)) && d(a, \"width\", f), (!N || v & /*geom*/\n      16 && h !== (h = /*geom*/\n      e[4].h)) && d(a, \"height\", h), (!N || v & /*geom*/\n      16 && _ !== (_ = /*geom*/\n      e[4].x)) && d(m, \"x\", _), (!N || v & /*geom*/\n      16 && w !== (w = /*geom*/\n      e[4].y)) && d(m, \"y\", w), (!N || v & /*geom*/\n      16 && y !== (y = /*geom*/\n      e[4].w)) && d(m, \"width\", y), (!N || v & /*geom*/\n      16 && A !== (A = /*geom*/\n      e[4].x + /*geom*/\n      e[4].w)) && d(b, \"x\", A), (!N || v & /*geom*/\n      16 && L !== (L = /*geom*/\n      e[4].y)) && d(b, \"y\", L), (!N || v & /*geom*/\n      16 && D !== (D = /*geom*/\n      e[4].h)) && d(b, \"height\", D), (!N || v & /*geom*/\n      16 && T !== (T = /*geom*/\n      e[4].x)) && d(p, \"x\", T), (!N || v & /*geom*/\n      16 && S !== (S = /*geom*/\n      e[4].y + /*geom*/\n      e[4].h)) && d(p, \"y\", S), (!N || v & /*geom*/\n      16 && M !== (M = /*geom*/\n      e[4].w)) && d(p, \"width\", M), (!N || v & /*geom*/\n      16 && Z !== (Z = /*geom*/\n      e[4].x)) && d(X, \"x\", Z), (!N || v & /*geom*/\n      16 && ge !== (ge = /*geom*/\n      e[4].y)) && d(X, \"y\", ge), (!N || v & /*geom*/\n      16 && me !== (me = /*geom*/\n      e[4].h)) && d(X, \"height\", me);\n      const Ye = {};\n      v & /*geom*/\n      16 && (Ye.x = /*geom*/\n      e[4].x), v & /*geom*/\n      16 && (Ye.y = /*geom*/\n      e[4].y), v & /*viewportScale*/\n      8 && (Ye.scale = /*viewportScale*/\n      e[3]), ie.$set(Ye);\n      const De = {};\n      v & /*geom*/\n      16 && (De.x = /*geom*/\n      e[4].x + /*geom*/\n      e[4].w), v & /*geom*/\n      16 && (De.y = /*geom*/\n      e[4].y), v & /*viewportScale*/\n      8 && (De.scale = /*viewportScale*/\n      e[3]), z.$set(De);\n      const Xe = {};\n      v & /*geom*/\n      16 && (Xe.x = /*geom*/\n      e[4].x + /*geom*/\n      e[4].w), v & /*geom*/\n      16 && (Xe.y = /*geom*/\n      e[4].y + /*geom*/\n      e[4].h), v & /*viewportScale*/\n      8 && (Xe.scale = /*viewportScale*/\n      e[3]), J.$set(Xe);\n      const Ce = {};\n      v & /*geom*/\n      16 && (Ce.x = /*geom*/\n      e[4].x), v & /*geom*/\n      16 && (Ce.y = /*geom*/\n      e[4].y + /*geom*/\n      e[4].h), v & /*viewportScale*/\n      8 && (Ce.scale = /*viewportScale*/\n      e[3]), ne.$set(Ce);\n    },\n    i(Y) {\n      N || (P(ie.$$.fragment, Y), P(z.$$.fragment, Y), P(J.$$.fragment, Y), P(ne.$$.fragment, Y), N = !0);\n    },\n    o(Y) {\n      C(ie.$$.fragment, Y), C(z.$$.fragment, Y), C(J.$$.fragment, Y), C(ne.$$.fragment, Y), N = !1;\n    },\n    d(Y) {\n      Y && (k(t), k(l), k(a), k(g), k(m), k(E), k(b), k(R), k(p), k(O), k(X), k(Me), k(I), k(H), k(fe)), x(ie, Y), x(z, Y), x(J, Y), x(ne, Y), qe = !1, ae(ut);\n    }\n  };\n}\nfunction vo(e) {\n  let t, n;\n  return t = new Qt({\n    props: {\n      shape: (\n        /*shape*/\n        e[0]\n      ),\n      transform: (\n        /*transform*/\n        e[2]\n      ),\n      editor: (\n        /*editor*/\n        e[5]\n      ),\n      $$slots: {\n        default: [\n          Mo,\n          ({ grab: o }) => ({ 9: o }),\n          ({ grab: o }) => o ? 512 : 0\n        ]\n      },\n      $$scope: { ctx: e }\n    }\n  }), t.$on(\n    \"grab\",\n    /*grab_handler*/\n    e[6]\n  ), t.$on(\n    \"change\",\n    /*change_handler*/\n    e[7]\n  ), t.$on(\n    \"release\",\n    /*release_handler*/\n    e[8]\n  ), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, [i]) {\n      const s = {};\n      i & /*shape*/\n      1 && (s.shape = /*shape*/\n      o[0]), i & /*transform*/\n      4 && (s.transform = /*transform*/\n      o[2]), i & /*$$scope, geom, viewportScale, grab, computedStyle*/\n      1562 && (s.$$scope = { dirty: i, ctx: o }), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction Lo(e, t, n) {\n  let o, { shape: i } = t, { computedStyle: s } = t, { transform: r } = t, { viewportScale: l = 1 } = t;\n  const a = (h, g, m) => {\n    const _ = h.geometry.bounds;\n    let [w, y] = [_.minX, _.minY], [E, b] = [_.maxX, _.maxY];\n    const [A, L] = m;\n    if (g === \"SHAPE\")\n      w += A, E += A, y += L, b += L;\n    else {\n      switch (g) {\n        case \"TOP\":\n        case \"TOP_LEFT\":\n        case \"TOP_RIGHT\": {\n          y += L;\n          break;\n        }\n        case \"BOTTOM\":\n        case \"BOTTOM_LEFT\":\n        case \"BOTTOM_RIGHT\": {\n          b += L;\n          break;\n        }\n      }\n      switch (g) {\n        case \"LEFT\":\n        case \"TOP_LEFT\":\n        case \"BOTTOM_LEFT\": {\n          w += A;\n          break;\n        }\n        case \"RIGHT\":\n        case \"TOP_RIGHT\":\n        case \"BOTTOM_RIGHT\": {\n          E += A;\n          break;\n        }\n      }\n    }\n    const D = Math.min(w, E), R = Math.min(y, b), p = Math.abs(E - w), T = Math.abs(b - y);\n    return {\n      ...h,\n      geometry: {\n        x: D,\n        y: R,\n        w: p,\n        h: T,\n        bounds: {\n          minX: D,\n          minY: R,\n          maxX: D + p,\n          maxY: R + T\n        }\n      }\n    };\n  };\n  function c(h) {\n    ue.call(this, e, h);\n  }\n  function u(h) {\n    ue.call(this, e, h);\n  }\n  function f(h) {\n    ue.call(this, e, h);\n  }\n  return e.$$set = (h) => {\n    \"shape\" in h && n(0, i = h.shape), \"computedStyle\" in h && n(1, s = h.computedStyle), \"transform\" in h && n(2, r = h.transform), \"viewportScale\" in h && n(3, l = h.viewportScale);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*shape*/\n    1 && n(4, o = i.geometry);\n  }, [\n    i,\n    s,\n    r,\n    l,\n    o,\n    a,\n    c,\n    u,\n    f\n  ];\n}\nclass ko extends te {\n  constructor(t) {\n    super(), ee(this, t, Lo, vo, W, {\n      shape: 0,\n      computedStyle: 1,\n      transform: 2,\n      viewportScale: 3\n    });\n  }\n}\nconst Zt = /* @__PURE__ */ new Map([\n  [j.RECTANGLE, ko],\n  [j.POLYGON, po]\n]), Oo = (e) => Zt.get(e.type), Bo = (e, t) => Zt.set(e, t), Io = (e) => ({}), St = (e) => ({ grab: (\n  /*onGrab*/\n  e[0]\n) });\nfunction Po(e) {\n  let t, n, o, i;\n  const s = (\n    /*#slots*/\n    e[7].default\n  ), r = rn(\n    s,\n    e,\n    /*$$scope*/\n    e[6],\n    St\n  );\n  return {\n    c() {\n      t = U(\"g\"), r && r.c(), d(t, \"class\", \"a9s-annotation selected\");\n    },\n    m(l, a) {\n      B(l, t, a), r && r.m(t, null), n = !0, o || (i = [\n        F(\n          t,\n          \"pointerup\",\n          /*onRelease*/\n          e[2]\n        ),\n        F(\n          t,\n          \"pointermove\",\n          /*onPointerMove*/\n          e[1]\n        )\n      ], o = !0);\n    },\n    p(l, [a]) {\n      r && r.p && (!n || a & /*$$scope*/\n      64) && an(\n        r,\n        s,\n        l,\n        /*$$scope*/\n        l[6],\n        n ? ln(\n          s,\n          /*$$scope*/\n          l[6],\n          a,\n          Io\n        ) : cn(\n          /*$$scope*/\n          l[6]\n        ),\n        St\n      );\n    },\n    i(l) {\n      n || (P(r, l), n = !0);\n    },\n    o(l) {\n      C(r, l), n = !1;\n    },\n    d(l) {\n      l && k(t), r && r.d(l), o = !1, ae(i);\n    }\n  };\n}\nfunction Yo(e, t, n) {\n  let { $$slots: o = {}, $$scope: i } = t;\n  const s = Te();\n  let { shape: r } = t, { editor: l } = t, { transform: a } = t, c, u, f;\n  const h = (_) => (w) => {\n    c = _, u = a.elementToImage(w.offsetX, w.offsetY), f = r, w.target.setPointerCapture(w.pointerId), s(\"grab\", w);\n  }, g = (_) => {\n    if (c) {\n      const [w, y] = a.elementToImage(_.offsetX, _.offsetY), E = [w - u[0], y - u[1]];\n      n(3, r = l(f, c, E)), s(\"change\", r);\n    }\n  }, m = (_) => {\n    _.target.releasePointerCapture(_.pointerId), c = void 0, f = r, s(\"release\", _);\n  };\n  return e.$$set = (_) => {\n    \"shape\" in _ && n(3, r = _.shape), \"editor\" in _ && n(4, l = _.editor), \"transform\" in _ && n(5, a = _.transform), \"$$scope\" in _ && n(6, i = _.$$scope);\n  }, [h, g, m, r, l, a, i, o];\n}\nclass Qt extends te {\n  constructor(t) {\n    super(), ee(this, t, Yo, Po, W, { shape: 3, editor: 4, transform: 5 });\n  }\n}\nconst je = (e, t) => {\n  const n = typeof t == \"function\" ? t(e) : t;\n  if (n) {\n    const { fill: o, fillOpacity: i } = n;\n    let s = \"\";\n    return o && (s += `fill:${o};stroke:${o};`), s += `fill-opacity:${i || \"0.25\"};`, s;\n  }\n};\nfunction Do(e, t, n) {\n  let o;\n  const i = Te();\n  let { annotation: s } = t, { editor: r } = t, { style: l } = t, { target: a } = t, { transform: c } = t, { viewportScale: u } = t, f;\n  return Pe(() => (n(6, f = new r({\n    target: a,\n    props: {\n      shape: s.target.selector,\n      computedStyle: o,\n      transform: c,\n      viewportScale: u\n    }\n  })), f.$on(\"change\", (h) => {\n    f.$$set({ shape: h.detail }), i(\"change\", h.detail);\n  }), f.$on(\"grab\", (h) => i(\"grab\", h.detail)), f.$on(\"release\", (h) => i(\"release\", h.detail)), () => {\n    f.$destroy();\n  })), e.$$set = (h) => {\n    \"annotation\" in h && n(0, s = h.annotation), \"editor\" in h && n(1, r = h.editor), \"style\" in h && n(2, l = h.style), \"target\" in h && n(3, a = h.target), \"transform\" in h && n(4, c = h.transform), \"viewportScale\" in h && n(5, u = h.viewportScale);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*annotation, style*/\n    5 && (o = je(s, l)), e.$$.dirty & /*annotation, editorComponent*/\n    65 && s && (f == null || f.$set({ shape: s.target.selector })), e.$$.dirty & /*editorComponent, transform*/\n    80 && f && f.$set({ transform: c }), e.$$.dirty & /*editorComponent, viewportScale*/\n    96 && f && f.$set({ viewportScale: u });\n  }, [s, r, l, a, c, u, f];\n}\nclass Xo extends te {\n  constructor(t) {\n    super(), ee(this, t, Do, null, W, {\n      annotation: 0,\n      editor: 1,\n      style: 2,\n      target: 3,\n      transform: 4,\n      viewportScale: 5\n    });\n  }\n}\nfunction Co(e, t, n) {\n  const o = Te();\n  let { drawingMode: i } = t, { target: s } = t, { tool: r } = t, { transform: l } = t, { viewportScale: a } = t, c;\n  return Pe(() => {\n    const u = s.closest(\"svg\"), f = [], h = (g, m, _) => {\n      u == null || u.addEventListener(g, m, _), f.push(() => u == null ? void 0 : u.removeEventListener(g, m, _));\n    };\n    return n(5, c = new r({\n      target: s,\n      props: {\n        addEventListener: h,\n        drawingMode: i,\n        transform: l,\n        viewportScale: a\n      }\n    })), c.$on(\"create\", (g) => o(\"create\", g.detail)), () => {\n      f.forEach((g) => g()), c.$destroy();\n    };\n  }), e.$$set = (u) => {\n    \"drawingMode\" in u && n(0, i = u.drawingMode), \"target\" in u && n(1, s = u.target), \"tool\" in u && n(2, r = u.tool), \"transform\" in u && n(3, l = u.transform), \"viewportScale\" in u && n(4, a = u.viewportScale);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*toolComponent, transform*/\n    40 && c && c.$set({ transform: l }), e.$$.dirty & /*toolComponent, viewportScale*/\n    48 && c && c.$set({ viewportScale: a });\n  }, [i, s, r, l, a, c];\n}\nclass Ro extends te {\n  constructor(t) {\n    super(), ee(this, t, Co, null, W, {\n      drawingMode: 0,\n      target: 1,\n      tool: 2,\n      transform: 3,\n      viewportScale: 4\n    });\n  }\n}\nfunction Tt(e) {\n  let t, n;\n  return {\n    c() {\n      t = U(\"rect\"), n = U(\"rect\"), d(t, \"class\", \"a9s-outer\"), d(\n        t,\n        \"x\",\n        /*x*/\n        e[1]\n      ), d(\n        t,\n        \"y\",\n        /*y*/\n        e[2]\n      ), d(\n        t,\n        \"width\",\n        /*w*/\n        e[3]\n      ), d(\n        t,\n        \"height\",\n        /*h*/\n        e[4]\n      ), d(n, \"class\", \"a9s-inner\"), d(\n        n,\n        \"x\",\n        /*x*/\n        e[1]\n      ), d(\n        n,\n        \"y\",\n        /*y*/\n        e[2]\n      ), d(\n        n,\n        \"width\",\n        /*w*/\n        e[3]\n      ), d(\n        n,\n        \"height\",\n        /*h*/\n        e[4]\n      );\n    },\n    m(o, i) {\n      B(o, t, i), B(o, n, i);\n    },\n    p(o, i) {\n      i & /*x*/\n      2 && d(\n        t,\n        \"x\",\n        /*x*/\n        o[1]\n      ), i & /*y*/\n      4 && d(\n        t,\n        \"y\",\n        /*y*/\n        o[2]\n      ), i & /*w*/\n      8 && d(\n        t,\n        \"width\",\n        /*w*/\n        o[3]\n      ), i & /*h*/\n      16 && d(\n        t,\n        \"height\",\n        /*h*/\n        o[4]\n      ), i & /*x*/\n      2 && d(\n        n,\n        \"x\",\n        /*x*/\n        o[1]\n      ), i & /*y*/\n      4 && d(\n        n,\n        \"y\",\n        /*y*/\n        o[2]\n      ), i & /*w*/\n      8 && d(\n        n,\n        \"width\",\n        /*w*/\n        o[3]\n      ), i & /*h*/\n      16 && d(\n        n,\n        \"height\",\n        /*h*/\n        o[4]\n      );\n    },\n    d(o) {\n      o && (k(t), k(n));\n    }\n  };\n}\nfunction Uo(e) {\n  let t, n = (\n    /*origin*/\n    e[0] && Tt(e)\n  );\n  return {\n    c() {\n      t = U(\"g\"), n && n.c(), d(t, \"class\", \"a9s-annotation a9s-rubberband\");\n    },\n    m(o, i) {\n      B(o, t, i), n && n.m(t, null);\n    },\n    p(o, [i]) {\n      /*origin*/\n      o[0] ? n ? n.p(o, i) : (n = Tt(o), n.c(), n.m(t, null)) : n && (n.d(1), n = null);\n    },\n    i: V,\n    o: V,\n    d(o) {\n      o && k(t), n && n.d();\n    }\n  };\n}\nfunction No(e, t, n) {\n  const o = Te();\n  let { addEventListener: i } = t, { drawingMode: s } = t, { transform: r } = t, l, a, c, u, f, h, g;\n  const m = (E) => {\n    const b = E;\n    l = performance.now(), s === \"drag\" && (n(0, a = r.elementToImage(b.offsetX, b.offsetY)), c = a, n(1, u = a[0]), n(2, f = a[1]), n(3, h = 1), n(4, g = 1));\n  }, _ = (E) => {\n    const b = E;\n    a && (c = r.elementToImage(b.offsetX, b.offsetY), n(1, u = Math.min(c[0], a[0])), n(2, f = Math.min(c[1], a[1])), n(3, h = Math.abs(c[0] - a[0])), n(4, g = Math.abs(c[1] - a[1])));\n  }, w = (E) => {\n    const b = E, A = performance.now() - l;\n    if (s === \"click\") {\n      if (A > 300)\n        return;\n      b.stopPropagation(), a ? y() : (n(0, a = r.elementToImage(b.offsetX, b.offsetY)), c = a, n(1, u = a[0]), n(2, f = a[1]), n(3, h = 1), n(4, g = 1));\n    } else\n      a && (A > 300 || h * g > 100 ? (b.stopPropagation(), y()) : (n(0, a = void 0), c = void 0));\n  }, y = () => {\n    if (h * g > 15) {\n      const E = {\n        type: j.RECTANGLE,\n        geometry: {\n          bounds: {\n            minX: u,\n            minY: f,\n            maxX: u + h,\n            maxY: f + g\n          },\n          x: u,\n          y: f,\n          w: h,\n          h: g\n        }\n      };\n      o(\"create\", E);\n    }\n    n(0, a = void 0), c = void 0;\n  };\n  return Pe(() => {\n    i(\"pointerdown\", m), i(\"pointermove\", _), i(\"pointerup\", w, !0);\n  }), e.$$set = (E) => {\n    \"addEventListener\" in E && n(5, i = E.addEventListener), \"drawingMode\" in E && n(6, s = E.drawingMode), \"transform\" in E && n(7, r = E.transform);\n  }, [a, u, f, h, g, i, s, r];\n}\nclass Vo extends te {\n  constructor(t) {\n    super(), ee(this, t, No, Uo, W, {\n      addEventListener: 5,\n      drawingMode: 6,\n      transform: 7\n    });\n  }\n}\nfunction xe(e) {\n  const t = e.slice(), n = (\n    /*isClosable*/\n    (t[2] ? (\n      /*points*/\n      t[0]\n    ) : [\n      .../*points*/\n      t[0],\n      /*cursor*/\n      t[1]\n    ]).map((o) => o.join(\",\")).join(\" \")\n  );\n  return t[16] = n, t;\n}\nfunction Mt(e) {\n  let t, n, o, i, s, r = (\n    /*isClosable*/\n    e[2] && vt(e)\n  );\n  return {\n    c() {\n      t = U(\"polygon\"), o = U(\"polygon\"), r && r.c(), s = ce(), d(t, \"class\", \"a9s-outer\"), d(t, \"points\", n = /*coords*/\n      e[16]), d(o, \"class\", \"a9s-inner\"), d(o, \"points\", i = /*coords*/\n      e[16]);\n    },\n    m(l, a) {\n      B(l, t, a), B(l, o, a), r && r.m(l, a), B(l, s, a);\n    },\n    p(l, a) {\n      a & /*isClosable, points, cursor*/\n      7 && n !== (n = /*coords*/\n      l[16]) && d(t, \"points\", n), a & /*isClosable, points, cursor*/\n      7 && i !== (i = /*coords*/\n      l[16]) && d(o, \"points\", i), /*isClosable*/\n      l[2] ? r ? r.p(l, a) : (r = vt(l), r.c(), r.m(s.parentNode, s)) : r && (r.d(1), r = null);\n    },\n    d(l) {\n      l && (k(t), k(o), k(s)), r && r.d(l);\n    }\n  };\n}\nfunction vt(e) {\n  let t, n, o;\n  return {\n    c() {\n      t = U(\"rect\"), d(t, \"class\", \"a9s-corner-handle\"), d(t, \"x\", n = /*points*/\n      e[0][0][0] - /*handleSize*/\n      e[3] / 2), d(t, \"y\", o = /*points*/\n      e[0][0][1] - /*handleSize*/\n      e[3] / 2), d(\n        t,\n        \"height\",\n        /*handleSize*/\n        e[3]\n      ), d(\n        t,\n        \"width\",\n        /*handleSize*/\n        e[3]\n      );\n    },\n    m(i, s) {\n      B(i, t, s);\n    },\n    p(i, s) {\n      s & /*points, handleSize*/\n      9 && n !== (n = /*points*/\n      i[0][0][0] - /*handleSize*/\n      i[3] / 2) && d(t, \"x\", n), s & /*points, handleSize*/\n      9 && o !== (o = /*points*/\n      i[0][0][1] - /*handleSize*/\n      i[3] / 2) && d(t, \"y\", o), s & /*handleSize*/\n      8 && d(\n        t,\n        \"height\",\n        /*handleSize*/\n        i[3]\n      ), s & /*handleSize*/\n      8 && d(\n        t,\n        \"width\",\n        /*handleSize*/\n        i[3]\n      );\n    },\n    d(i) {\n      i && k(t);\n    }\n  };\n}\nfunction Go(e) {\n  let t, n = (\n    /*cursor*/\n    e[1] && Mt(xe(e))\n  );\n  return {\n    c() {\n      t = U(\"g\"), n && n.c(), d(t, \"class\", \"a9s-annotation a9s-rubberband\");\n    },\n    m(o, i) {\n      B(o, t, i), n && n.m(t, null);\n    },\n    p(o, [i]) {\n      /*cursor*/\n      o[1] ? n ? n.p(xe(o), i) : (n = Mt(xe(o)), n.c(), n.m(t, null)) : n && (n.d(1), n = null);\n    },\n    i: V,\n    o: V,\n    d(o) {\n      o && k(t), n && n.d();\n    }\n  };\n}\nconst zo = 20, Ho = 1500;\nfunction Fo(e, t, n) {\n  let o;\n  const i = Te();\n  let { addEventListener: s } = t, { drawingMode: r } = t, { transform: l } = t, { viewportScale: a = 1 } = t, c, u = [], f, h, g = !1;\n  const m = (b) => {\n    const A = b, { timeStamp: L, offsetX: D, offsetY: R } = A;\n    if (c = { timeStamp: L, offsetX: D, offsetY: R }, r === \"drag\" && u.length === 0) {\n      const p = l.elementToImage(A.offsetX, A.offsetY);\n      u.push(p), n(1, f = p);\n    }\n  }, _ = (b) => {\n    const A = b;\n    if (h && clearTimeout(h), u.length > 0) {\n      if (n(1, f = l.elementToImage(A.offsetX, A.offsetY)), u.length > 2) {\n        const L = Qe(f, u[0]) * a;\n        n(2, g = L < zo);\n      }\n      A.pointerType === \"touch\" && (h = setTimeout(\n        () => {\n          y();\n        },\n        Ho\n      ));\n    }\n  }, w = (b) => {\n    const A = b;\n    if (h && clearTimeout(h), r === \"click\") {\n      const L = A.timeStamp - c.timeStamp, D = Qe([c.offsetX, c.offsetY], [A.offsetX, A.offsetY]);\n      if (L > 300 || D > 15)\n        return;\n      if (g)\n        E();\n      else if (u.length === 0) {\n        const R = l.elementToImage(A.offsetX, A.offsetY);\n        u.push(R), n(1, f = R);\n      } else\n        u.push(f);\n    } else {\n      if (u.length === 1 && Qe(u[0], f) <= 4) {\n        n(0, u = []), n(1, f = void 0);\n        return;\n      }\n      A.stopImmediatePropagation(), g ? E() : u.push(f);\n    }\n  }, y = () => {\n    if (!f)\n      return;\n    const b = [...u, f], A = {\n      type: j.POLYGON,\n      geometry: { bounds: Fe(b), points: b }\n    };\n    st(A) > 4 && (n(0, u = []), n(1, f = void 0), i(\"create\", A));\n  }, E = () => {\n    const b = {\n      type: j.POLYGON,\n      geometry: {\n        bounds: Fe(u),\n        points: [...u]\n      }\n    };\n    n(0, u = []), n(1, f = void 0), i(\"create\", b);\n  };\n  return Pe(() => {\n    s(\"pointerdown\", m, !0), s(\"pointermove\", _), s(\"pointerup\", w, !0), s(\"dblclick\", y, !0);\n  }), e.$$set = (b) => {\n    \"addEventListener\" in b && n(4, s = b.addEventListener), \"drawingMode\" in b && n(5, r = b.drawingMode), \"transform\" in b && n(6, l = b.transform), \"viewportScale\" in b && n(7, a = b.viewportScale);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*viewportScale*/\n    128 && n(3, o = 10 / a);\n  }, [\n    u,\n    f,\n    g,\n    o,\n    s,\n    r,\n    l,\n    a\n  ];\n}\nclass jo extends te {\n  constructor(t) {\n    super(), ee(this, t, Fo, Go, W, {\n      addEventListener: 4,\n      drawingMode: 5,\n      transform: 6,\n      viewportScale: 7\n    });\n  }\n}\nconst ft = /* @__PURE__ */ new Map([\n  [\"rectangle\", { tool: Vo }],\n  [\"polygon\", { tool: jo }]\n]), xt = () => [...ft.keys()], $t = (e) => ft.get(e), qo = (e, t, n) => ft.set(e, { tool: t, opts: n });\nfunction Ko(e) {\n  let t, n, o, i, s;\n  return {\n    c() {\n      t = U(\"g\"), n = U(\"ellipse\"), i = U(\"ellipse\"), d(n, \"class\", \"a9s-outer\"), d(n, \"style\", o = /*computedStyle*/\n      e[1] ? \"display:none;\" : void 0), d(\n        n,\n        \"cx\",\n        /*cx*/\n        e[2]\n      ), d(\n        n,\n        \"cy\",\n        /*cy*/\n        e[3]\n      ), d(\n        n,\n        \"rx\",\n        /*rx*/\n        e[4]\n      ), d(\n        n,\n        \"ry\",\n        /*ry*/\n        e[5]\n      ), d(i, \"class\", \"a9s-inner\"), d(\n        i,\n        \"style\",\n        /*computedStyle*/\n        e[1]\n      ), d(\n        i,\n        \"cx\",\n        /*cx*/\n        e[2]\n      ), d(\n        i,\n        \"cy\",\n        /*cy*/\n        e[3]\n      ), d(\n        i,\n        \"rx\",\n        /*rx*/\n        e[4]\n      ), d(\n        i,\n        \"ry\",\n        /*ry*/\n        e[5]\n      ), d(t, \"data-id\", s = /*annotation*/\n      e[0].id);\n    },\n    m(r, l) {\n      B(r, t, l), se(t, n), se(t, i);\n    },\n    p(r, [l]) {\n      l & /*computedStyle*/\n      2 && o !== (o = /*computedStyle*/\n      r[1] ? \"display:none;\" : void 0) && d(n, \"style\", o), l & /*computedStyle*/\n      2 && d(\n        i,\n        \"style\",\n        /*computedStyle*/\n        r[1]\n      ), l & /*annotation*/\n      1 && s !== (s = /*annotation*/\n      r[0].id) && d(t, \"data-id\", s);\n    },\n    i: V,\n    o: V,\n    d(r) {\n      r && k(t);\n    }\n  };\n}\nfunction Wo(e, t, n) {\n  let o, { annotation: i } = t, { geom: s } = t, { style: r } = t;\n  const { cx: l, cy: a, rx: c, ry: u } = s;\n  return e.$$set = (f) => {\n    \"annotation\" in f && n(0, i = f.annotation), \"geom\" in f && n(6, s = f.geom), \"style\" in f && n(7, r = f.style);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*annotation, style*/\n    129 && n(1, o = je(i, r));\n  }, [i, o, l, a, c, u, s, r];\n}\nclass Jo extends te {\n  constructor(t) {\n    super(), ee(this, t, Wo, Ko, W, { annotation: 0, geom: 6, style: 7 });\n  }\n}\nfunction Zo(e) {\n  let t, n, o, i, s;\n  return {\n    c() {\n      t = U(\"g\"), n = U(\"polygon\"), i = U(\"polygon\"), d(n, \"class\", \"a9s-outer\"), d(n, \"style\", o = /*computedStyle*/\n      e[1] ? \"display:none;\" : void 0), d(\n        n,\n        \"points\",\n        /*points*/\n        e[2].map(Qo).join(\" \")\n      ), d(i, \"class\", \"a9s-inner\"), d(\n        i,\n        \"style\",\n        /*computedStyle*/\n        e[1]\n      ), d(\n        i,\n        \"points\",\n        /*points*/\n        e[2].map(xo).join(\" \")\n      ), d(t, \"data-id\", s = /*annotation*/\n      e[0].id);\n    },\n    m(r, l) {\n      B(r, t, l), se(t, n), se(t, i);\n    },\n    p(r, [l]) {\n      l & /*computedStyle*/\n      2 && o !== (o = /*computedStyle*/\n      r[1] ? \"display:none;\" : void 0) && d(n, \"style\", o), l & /*computedStyle*/\n      2 && d(\n        i,\n        \"style\",\n        /*computedStyle*/\n        r[1]\n      ), l & /*annotation*/\n      1 && s !== (s = /*annotation*/\n      r[0].id) && d(t, \"data-id\", s);\n    },\n    i: V,\n    o: V,\n    d(r) {\n      r && k(t);\n    }\n  };\n}\nconst Qo = (e) => e.join(\",\"), xo = (e) => e.join(\",\");\nfunction $o(e, t, n) {\n  let o, { annotation: i } = t, { geom: s } = t, { style: r } = t;\n  const { points: l } = s;\n  return e.$$set = (a) => {\n    \"annotation\" in a && n(0, i = a.annotation), \"geom\" in a && n(3, s = a.geom), \"style\" in a && n(4, r = a.style);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*annotation, style*/\n    17 && n(1, o = je(i, r));\n  }, [i, o, l, s, r];\n}\nclass ei extends te {\n  constructor(t) {\n    super(), ee(this, t, $o, Zo, W, { annotation: 0, geom: 3, style: 4 });\n  }\n}\nfunction ti(e) {\n  let t, n, o, i, s;\n  return {\n    c() {\n      t = U(\"g\"), n = U(\"rect\"), i = U(\"rect\"), d(n, \"class\", \"a9s-outer\"), d(n, \"style\", o = /*computedStyle*/\n      e[5] ? \"display:none;\" : void 0), d(\n        n,\n        \"x\",\n        /*x*/\n        e[4]\n      ), d(\n        n,\n        \"y\",\n        /*y*/\n        e[3]\n      ), d(\n        n,\n        \"width\",\n        /*w*/\n        e[2]\n      ), d(\n        n,\n        \"height\",\n        /*h*/\n        e[1]\n      ), d(i, \"class\", \"a9s-inner\"), d(\n        i,\n        \"style\",\n        /*computedStyle*/\n        e[5]\n      ), d(\n        i,\n        \"x\",\n        /*x*/\n        e[4]\n      ), d(\n        i,\n        \"y\",\n        /*y*/\n        e[3]\n      ), d(\n        i,\n        \"width\",\n        /*w*/\n        e[2]\n      ), d(\n        i,\n        \"height\",\n        /*h*/\n        e[1]\n      ), d(t, \"data-id\", s = /*annotation*/\n      e[0].id);\n    },\n    m(r, l) {\n      B(r, t, l), se(t, n), se(t, i);\n    },\n    p(r, [l]) {\n      l & /*computedStyle*/\n      32 && o !== (o = /*computedStyle*/\n      r[5] ? \"display:none;\" : void 0) && d(n, \"style\", o), l & /*x*/\n      16 && d(\n        n,\n        \"x\",\n        /*x*/\n        r[4]\n      ), l & /*y*/\n      8 && d(\n        n,\n        \"y\",\n        /*y*/\n        r[3]\n      ), l & /*w*/\n      4 && d(\n        n,\n        \"width\",\n        /*w*/\n        r[2]\n      ), l & /*h*/\n      2 && d(\n        n,\n        \"height\",\n        /*h*/\n        r[1]\n      ), l & /*computedStyle*/\n      32 && d(\n        i,\n        \"style\",\n        /*computedStyle*/\n        r[5]\n      ), l & /*x*/\n      16 && d(\n        i,\n        \"x\",\n        /*x*/\n        r[4]\n      ), l & /*y*/\n      8 && d(\n        i,\n        \"y\",\n        /*y*/\n        r[3]\n      ), l & /*w*/\n      4 && d(\n        i,\n        \"width\",\n        /*w*/\n        r[2]\n      ), l & /*h*/\n      2 && d(\n        i,\n        \"height\",\n        /*h*/\n        r[1]\n      ), l & /*annotation*/\n      1 && s !== (s = /*annotation*/\n      r[0].id) && d(t, \"data-id\", s);\n    },\n    i: V,\n    o: V,\n    d(r) {\n      r && k(t);\n    }\n  };\n}\nfunction ni(e, t, n) {\n  let o, i, s, r, l, { annotation: a } = t, { geom: c } = t, { style: u } = t;\n  return e.$$set = (f) => {\n    \"annotation\" in f && n(0, a = f.annotation), \"geom\" in f && n(6, c = f.geom), \"style\" in f && n(7, u = f.style);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*annotation, style*/\n    129 && n(5, o = je(a, u)), e.$$.dirty & /*geom*/\n    64 && n(4, { x: i, y: s, w: r, h: l } = c, i, (n(3, s), n(6, c)), (n(2, r), n(6, c)), (n(1, l), n(6, c)));\n  }, [a, l, r, s, i, o, c, u];\n}\nclass oi extends te {\n  constructor(t) {\n    super(), ee(this, t, ni, ti, W, { annotation: 0, geom: 6, style: 7 });\n  }\n}\nconst Yi = {\n  elementToImage: (e, t) => [e, t]\n}, ii = (e) => ({\n  elementToImage: (t, n) => {\n    const o = e.getBoundingClientRect(), i = e.createSVGPoint();\n    i.x = t + o.x, i.y = n + o.y;\n    const { x: s, y: r } = i.matrixTransform(e.getScreenCTM().inverse());\n    return [s, r];\n  }\n}), si = 250, ri = (e, t) => {\n  const n = Te();\n  let o;\n  return { onPointerDown: () => o = performance.now(), onPointerUp: (r) => {\n    if (performance.now() - o < si) {\n      const { x: a, y: c } = li(r, e), u = t.getAt(a, c);\n      u ? n(\"click\", { originalEvent: r, annotation: u }) : n(\"click\", { originalEvent: r });\n    }\n  } };\n}, li = (e, t) => {\n  const n = t.createSVGPoint(), o = t.getBoundingClientRect(), i = e.clientX - o.x, s = e.clientY - o.y, { left: r, top: l } = t.getBoundingClientRect();\n  return n.x = i + r, n.y = s + l, n.matrixTransform(t.getScreenCTM().inverse());\n}, { Boolean: en } = fn;\nfunction Lt(e, t, n) {\n  const o = e.slice();\n  return o[30] = t[n], o;\n}\nfunction kt(e, t, n) {\n  const o = e.slice();\n  return o[33] = t[n], o;\n}\nfunction $e(e) {\n  const t = e.slice(), n = (\n    /*annotation*/\n    t[33].target.selector\n  );\n  return t[36] = n, t;\n}\nfunction Ot(e) {\n  let t = (\n    /*annotation*/\n    e[33].id\n  ), n, o, i = Bt(e);\n  return {\n    c() {\n      i.c(), n = ce();\n    },\n    m(s, r) {\n      i.m(s, r), B(s, n, r), o = !0;\n    },\n    p(s, r) {\n      r[0] & /*$store*/\n      8192 && W(t, t = /*annotation*/\n      s[33].id) ? (re(), C(i, 1, 1, V), le(), i = Bt(s), i.c(), P(i, 1), i.m(n.parentNode, n)) : i.p(s, r);\n    },\n    i(s) {\n      o || (P(i), o = !0);\n    },\n    o(s) {\n      C(i), o = !1;\n    },\n    d(s) {\n      s && k(n), i.d(s);\n    }\n  };\n}\nfunction ai(e) {\n  let t, n;\n  return t = new ei({\n    props: {\n      annotation: (\n        /*annotation*/\n        e[33]\n      ),\n      geom: (\n        /*selector*/\n        e[36].geometry\n      ),\n      style: (\n        /*style*/\n        e[1]\n      )\n    }\n  }), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, i) {\n      const s = {};\n      i[0] & /*$store*/\n      8192 && (s.annotation = /*annotation*/\n      o[33]), i[0] & /*$store*/\n      8192 && (s.geom = /*selector*/\n      o[36].geometry), i[0] & /*style*/\n      2 && (s.style = /*style*/\n      o[1]), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction ci(e) {\n  let t, n;\n  return t = new oi({\n    props: {\n      annotation: (\n        /*annotation*/\n        e[33]\n      ),\n      geom: (\n        /*selector*/\n        e[36].geometry\n      ),\n      style: (\n        /*style*/\n        e[1]\n      )\n    }\n  }), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, i) {\n      const s = {};\n      i[0] & /*$store*/\n      8192 && (s.annotation = /*annotation*/\n      o[33]), i[0] & /*$store*/\n      8192 && (s.geom = /*selector*/\n      o[36].geometry), i[0] & /*style*/\n      2 && (s.style = /*style*/\n      o[1]), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction fi(e) {\n  let t, n;\n  return t = new Jo({\n    props: {\n      annotation: (\n        /*annotation*/\n        e[33]\n      ),\n      geom: (\n        /*selector*/\n        e[36].geometry\n      ),\n      style: (\n        /*style*/\n        e[1]\n      )\n    }\n  }), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, i) {\n      const s = {};\n      i[0] & /*$store*/\n      8192 && (s.annotation = /*annotation*/\n      o[33]), i[0] & /*$store*/\n      8192 && (s.geom = /*selector*/\n      o[36].geometry), i[0] & /*style*/\n      2 && (s.style = /*style*/\n      o[1]), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction Bt(e) {\n  let t, n, o, i;\n  const s = [fi, ci, ai], r = [];\n  function l(a, c) {\n    return (\n      /*selector*/\n      a[36].type === j.ELLIPSE ? 0 : (\n        /*selector*/\n        a[36].type === j.RECTANGLE ? 1 : (\n          /*selector*/\n          a[36].type === j.POLYGON ? 2 : -1\n        )\n      )\n    );\n  }\n  return ~(t = l(e)) && (n = r[t] = s[t](e)), {\n    c() {\n      n && n.c(), o = ce();\n    },\n    m(a, c) {\n      ~t && r[t].m(a, c), B(a, o, c), i = !0;\n    },\n    p(a, c) {\n      let u = t;\n      t = l(a), t === u ? ~t && r[t].p(a, c) : (n && (re(), C(r[u], 1, 1, () => {\n        r[u] = null;\n      }), le()), ~t ? (n = r[t], n ? n.p(a, c) : (n = r[t] = s[t](a), n.c()), P(n, 1), n.m(o.parentNode, o)) : n = null);\n    },\n    i(a) {\n      i || (P(n), i = !0);\n    },\n    o(a) {\n      C(n), i = !1;\n    },\n    d(a) {\n      a && k(o), ~t && r[t].d(a);\n    }\n  };\n}\nfunction It(e) {\n  let t = !/*isEditable*/\n  e[7](\n    /*annotation*/\n    e[33]\n  ), n, o, i = t && Ot($e(e));\n  return {\n    c() {\n      i && i.c(), n = ce();\n    },\n    m(s, r) {\n      i && i.m(s, r), B(s, n, r), o = !0;\n    },\n    p(s, r) {\n      r[0] & /*isEditable, $store*/\n      8320 && (t = !/*isEditable*/\n      s[7](\n        /*annotation*/\n        s[33]\n      )), t ? i ? (i.p($e(s), r), r[0] & /*isEditable, $store*/\n      8320 && P(i, 1)) : (i = Ot($e(s)), i.c(), P(i, 1), i.m(n.parentNode, n)) : i && (re(), C(i, 1, 1, () => {\n        i = null;\n      }), le());\n    },\n    i(s) {\n      o || (P(i), o = !0);\n    },\n    o(s) {\n      C(i), o = !1;\n    },\n    d(s) {\n      s && k(n), i && i.d(s);\n    }\n  };\n}\nfunction Pt(e) {\n  let t, n, o, i;\n  const s = [di, ui], r = [];\n  function l(a, c) {\n    return (\n      /*editableAnnotations*/\n      a[6] ? 0 : (\n        /*tool*/\n        a[12] && /*drawingEnabled*/\n        a[0] ? 1 : -1\n      )\n    );\n  }\n  return ~(t = l(e)) && (n = r[t] = s[t](e)), {\n    c() {\n      n && n.c(), o = ce();\n    },\n    m(a, c) {\n      ~t && r[t].m(a, c), B(a, o, c), i = !0;\n    },\n    p(a, c) {\n      let u = t;\n      t = l(a), t === u ? ~t && r[t].p(a, c) : (n && (re(), C(r[u], 1, 1, () => {\n        r[u] = null;\n      }), le()), ~t ? (n = r[t], n ? n.p(a, c) : (n = r[t] = s[t](a), n.c()), P(n, 1), n.m(o.parentNode, o)) : n = null);\n    },\n    i(a) {\n      i || (P(n), i = !0);\n    },\n    o(a) {\n      C(n), i = !1;\n    },\n    d(a) {\n      a && k(o), ~t && r[t].d(a);\n    }\n  };\n}\nfunction ui(e) {\n  let t = (\n    /*toolName*/\n    e[2]\n  ), n, o, i = Yt(e);\n  return {\n    c() {\n      i.c(), n = ce();\n    },\n    m(s, r) {\n      i.m(s, r), B(s, n, r), o = !0;\n    },\n    p(s, r) {\n      r[0] & /*toolName*/\n      4 && W(t, t = /*toolName*/\n      s[2]) ? (re(), C(i, 1, 1, V), le(), i = Yt(s), i.c(), P(i, 1), i.m(n.parentNode, n)) : i.p(s, r);\n    },\n    i(s) {\n      o || (P(i), o = !0);\n    },\n    o(s) {\n      C(i), o = !1;\n    },\n    d(s) {\n      s && k(n), i.d(s);\n    }\n  };\n}\nfunction di(e) {\n  let t, n, o = Se(\n    /*editableAnnotations*/\n    e[6]\n  ), i = [];\n  for (let r = 0; r < o.length; r += 1)\n    i[r] = Xt(Lt(e, o, r));\n  const s = (r) => C(i[r], 1, 1, () => {\n    i[r] = null;\n  });\n  return {\n    c() {\n      for (let r = 0; r < i.length; r += 1)\n        i[r].c();\n      t = ce();\n    },\n    m(r, l) {\n      for (let a = 0; a < i.length; a += 1)\n        i[a] && i[a].m(r, l);\n      B(r, t, l), n = !0;\n    },\n    p(r, l) {\n      if (l[0] & /*editableAnnotations, drawingEl, getEditor, style, transform, $scale, onChangeSelected*/\n      803922) {\n        o = Se(\n          /*editableAnnotations*/\n          r[6]\n        );\n        let a;\n        for (a = 0; a < o.length; a += 1) {\n          const c = Lt(r, o, a);\n          i[a] ? (i[a].p(c, l), P(i[a], 1)) : (i[a] = Xt(c), i[a].c(), P(i[a], 1), i[a].m(t.parentNode, t));\n        }\n        for (re(), a = o.length; a < i.length; a += 1)\n          s(a);\n        le();\n      }\n    },\n    i(r) {\n      if (!n) {\n        for (let l = 0; l < o.length; l += 1)\n          P(i[l]);\n        n = !0;\n      }\n    },\n    o(r) {\n      i = i.filter(en);\n      for (let l = 0; l < i.length; l += 1)\n        C(i[l]);\n      n = !1;\n    },\n    d(r) {\n      r && k(t), rt(i, r);\n    }\n  };\n}\nfunction Yt(e) {\n  let t, n;\n  return t = new Ro({\n    props: {\n      target: (\n        /*drawingEl*/\n        e[4]\n      ),\n      tool: (\n        /*tool*/\n        e[12]\n      ),\n      drawingMode: (\n        /*drawingMode*/\n        e[11]\n      ),\n      transform: (\n        /*transform*/\n        e[10]\n      ),\n      viewportScale: (\n        /*$scale*/\n        e[14]\n      )\n    }\n  }), t.$on(\n    \"create\",\n    /*onSelectionCreated*/\n    e[17]\n  ), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, i) {\n      const s = {};\n      i[0] & /*drawingEl*/\n      16 && (s.target = /*drawingEl*/\n      o[4]), i[0] & /*tool*/\n      4096 && (s.tool = /*tool*/\n      o[12]), i[0] & /*drawingMode*/\n      2048 && (s.drawingMode = /*drawingMode*/\n      o[11]), i[0] & /*transform*/\n      1024 && (s.transform = /*transform*/\n      o[10]), i[0] & /*$scale*/\n      16384 && (s.viewportScale = /*$scale*/\n      o[14]), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction Dt(e) {\n  let t, n;\n  return t = new Xo({\n    props: {\n      target: (\n        /*drawingEl*/\n        e[4]\n      ),\n      editor: (\n        /*getEditor*/\n        e[19](\n          /*editable*/\n          e[30].target.selector\n        )\n      ),\n      annotation: (\n        /*editable*/\n        e[30]\n      ),\n      style: (\n        /*style*/\n        e[1]\n      ),\n      transform: (\n        /*transform*/\n        e[10]\n      ),\n      viewportScale: (\n        /*$scale*/\n        e[14]\n      )\n    }\n  }), t.$on(\"change\", function() {\n    q(\n      /*onChangeSelected*/\n      e[18](\n        /*editable*/\n        e[30]\n      )\n    ) && e[18](\n      /*editable*/\n      e[30]\n    ).apply(this, arguments);\n  }), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, i) {\n      e = o;\n      const s = {};\n      i[0] & /*drawingEl*/\n      16 && (s.target = /*drawingEl*/\n      e[4]), i[0] & /*editableAnnotations*/\n      64 && (s.editor = /*getEditor*/\n      e[19](\n        /*editable*/\n        e[30].target.selector\n      )), i[0] & /*editableAnnotations*/\n      64 && (s.annotation = /*editable*/\n      e[30]), i[0] & /*style*/\n      2 && (s.style = /*style*/\n      e[1]), i[0] & /*transform*/\n      1024 && (s.transform = /*transform*/\n      e[10]), i[0] & /*$scale*/\n      16384 && (s.viewportScale = /*$scale*/\n      e[14]), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction Xt(e) {\n  let t = (\n    /*editable*/\n    e[30].id\n  ), n, o, i = Dt(e);\n  return {\n    c() {\n      i.c(), n = ce();\n    },\n    m(s, r) {\n      i.m(s, r), B(s, n, r), o = !0;\n    },\n    p(s, r) {\n      r[0] & /*editableAnnotations*/\n      64 && W(t, t = /*editable*/\n      s[30].id) ? (re(), C(i, 1, 1, V), le(), i = Dt(s), i.c(), P(i, 1), i.m(n.parentNode, n)) : i.p(s, r);\n    },\n    i(s) {\n      o || (P(i), o = !0);\n    },\n    o(s) {\n      C(i), o = !1;\n    },\n    d(s) {\n      s && k(n), i.d(s);\n    }\n  };\n}\nfunction hi(e) {\n  let t, n, o, i, s, r, l = Se(\n    /*$store*/\n    e[13]\n  ), a = [];\n  for (let f = 0; f < l.length; f += 1)\n    a[f] = It(kt(e, l, f));\n  const c = (f) => C(a[f], 1, 1, () => {\n    a[f] = null;\n  });\n  let u = (\n    /*drawingEl*/\n    e[4] && Pt(e)\n  );\n  return {\n    c() {\n      t = U(\"svg\"), n = U(\"g\");\n      for (let f = 0; f < a.length; f += 1)\n        a[f].c();\n      o = U(\"g\"), u && u.c(), d(o, \"class\", \"drawing\"), d(t, \"class\", \"a9s-annotationlayer\"), ze(\n        t,\n        \"drawing\",\n        /*tool*/\n        e[12]\n      );\n    },\n    m(f, h) {\n      B(f, t, h), se(t, n);\n      for (let g = 0; g < a.length; g += 1)\n        a[g] && a[g].m(n, null);\n      se(t, o), u && u.m(o, null), e[26](o), e[27](t), i = !0, s || (r = [\n        F(t, \"pointerup\", function() {\n          q(\n            /*onPointerUp*/\n            e[8]\n          ) && e[8].apply(this, arguments);\n        }),\n        F(t, \"pointerdown\", function() {\n          q(\n            /*onPointerDown*/\n            e[9]\n          ) && e[9].apply(this, arguments);\n        })\n      ], s = !0);\n    },\n    p(f, h) {\n      if (e = f, h[0] & /*$store, style, isEditable*/\n      8322) {\n        l = Se(\n          /*$store*/\n          e[13]\n        );\n        let g;\n        for (g = 0; g < l.length; g += 1) {\n          const m = kt(e, l, g);\n          a[g] ? (a[g].p(m, h), P(a[g], 1)) : (a[g] = It(m), a[g].c(), P(a[g], 1), a[g].m(n, null));\n        }\n        for (re(), g = l.length; g < a.length; g += 1)\n          c(g);\n        le();\n      }\n      /*drawingEl*/\n      e[4] ? u ? (u.p(e, h), h[0] & /*drawingEl*/\n      16 && P(u, 1)) : (u = Pt(e), u.c(), P(u, 1), u.m(o, null)) : u && (re(), C(u, 1, 1, () => {\n        u = null;\n      }), le()), (!i || h[0] & /*tool*/\n      4096) && ze(\n        t,\n        \"drawing\",\n        /*tool*/\n        e[12]\n      );\n    },\n    i(f) {\n      if (!i) {\n        for (let h = 0; h < l.length; h += 1)\n          P(a[h]);\n        P(u), i = !0;\n      }\n    },\n    o(f) {\n      a = a.filter(en);\n      for (let h = 0; h < a.length; h += 1)\n        C(a[h]);\n      C(u), i = !1;\n    },\n    d(f) {\n      f && k(t), rt(a, f), u && u.d(), e[26](null), e[27](null), s = !1, ae(r);\n    }\n  };\n}\nfunction gi(e, t, n) {\n  let o, i, s, r, l, a, c, u, f, h, g = V, m = () => (g(), g = Vt(p, (I) => n(14, h = I)), p);\n  e.$$.on_destroy.push(() => g());\n  let { drawingEnabled: _ } = t, { image: w } = t, { preferredDrawingMode: y } = t, { state: E } = t, { style: b = void 0 } = t, { toolName: A = xt()[0] } = t, { user: L } = t, D, R, p;\n  Pe(() => m(n(5, p = wo(w, R))));\n  const { selection: T, store: S } = E;\n  ht(e, T, (I) => n(25, u = I)), ht(e, S, (I) => n(13, f = I));\n  let M, O;\n  const X = (I) => {\n    M && S.unobserve(M);\n    const z = I.filter(({ editable: H }) => H).map(({ id: H }) => H);\n    z.length > 0 ? (n(6, O = z.map((H) => S.getAnnotation(H)).filter(Boolean)), M = (H) => {\n      const { updated: J } = H.changes;\n      n(6, O = J == null ? void 0 : J.map((fe) => fe.newValue));\n    }, S.observe(M, { annotations: z })) : n(6, O = void 0);\n  }, Z = (I) => {\n    const z = qt(), H = {\n      id: z,\n      bodies: [],\n      target: {\n        annotation: z,\n        selector: I.detail,\n        creator: L,\n        created: /* @__PURE__ */ new Date()\n      }\n    };\n    S.addAnnotation(H), T.setSelected(H.id);\n  }, ge = (I) => (z) => {\n    var ne;\n    const { target: H } = I, J = 10 * 60 * 1e3, fe = ((ne = H.creator) == null ? void 0 : ne.id) !== L.id || !H.created || (/* @__PURE__ */ new Date()).getTime() - H.created.getTime() > J;\n    S.updateTarget({\n      ...H,\n      selector: z.detail,\n      created: fe ? H.created : /* @__PURE__ */ new Date(),\n      updated: fe ? /* @__PURE__ */ new Date() : void 0,\n      updatedBy: fe ? L : void 0\n    });\n  }, me = (I) => Oo(I);\n  function Me(I) {\n    He[I ? \"unshift\" : \"push\"](() => {\n      D = I, n(4, D);\n    });\n  }\n  function ie(I) {\n    He[I ? \"unshift\" : \"push\"](() => {\n      R = I, n(3, R);\n    });\n  }\n  return e.$$set = (I) => {\n    \"drawingEnabled\" in I && n(0, _ = I.drawingEnabled), \"image\" in I && n(20, w = I.image), \"preferredDrawingMode\" in I && n(21, y = I.preferredDrawingMode), \"state\" in I && n(22, E = I.state), \"style\" in I && n(1, b = I.style), \"toolName\" in I && n(2, A = I.toolName), \"user\" in I && n(23, L = I.user);\n  }, e.$$.update = () => {\n    e.$$.dirty[0] & /*toolName*/\n    4 && n(12, { tool: o, opts: i } = $t(A) || { tool: void 0, opts: void 0 }, o, (n(24, i), n(2, A))), e.$$.dirty[0] & /*opts, preferredDrawingMode*/\n    18874368 && n(11, s = (i == null ? void 0 : i.drawingMode) || y), e.$$.dirty[0] & /*svgEl*/\n    8 && n(10, r = ii(R)), e.$$.dirty[0] & /*svgEl*/\n    8 && n(9, { onPointerDown: l, onPointerUp: a } = ri(R, S), l, (n(8, a), n(3, R))), e.$$.dirty[0] & /*$selection*/\n    33554432 && n(7, c = (I) => u.selected.find((z) => z.id === I.id && z.editable)), e.$$.dirty[0] & /*$selection*/\n    33554432 && X(u.selected);\n  }, [\n    _,\n    b,\n    A,\n    R,\n    D,\n    p,\n    O,\n    c,\n    a,\n    l,\n    r,\n    s,\n    o,\n    f,\n    h,\n    T,\n    S,\n    Z,\n    ge,\n    me,\n    w,\n    y,\n    E,\n    L,\n    i,\n    u,\n    Me,\n    ie\n  ];\n}\nclass mi extends te {\n  constructor(t) {\n    super(), ee(\n      this,\n      t,\n      gi,\n      hi,\n      W,\n      {\n        drawingEnabled: 0,\n        image: 20,\n        preferredDrawingMode: 21,\n        state: 22,\n        style: 1,\n        toolName: 2,\n        user: 23\n      },\n      null,\n      [-1, -1]\n    );\n  }\n}\nfunction pi(e, t, n, o, i) {\n  tn(e, t, n || 0, o || e.length - 1, i || yi);\n}\nfunction tn(e, t, n, o, i) {\n  for (; o > n; ) {\n    if (o - n > 600) {\n      var s = o - n + 1, r = t - n + 1, l = Math.log(s), a = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * a * (s - a) / s) * (r - s / 2 < 0 ? -1 : 1), u = Math.max(n, Math.floor(t - r * a / s + c)), f = Math.min(o, Math.floor(t + (s - r) * a / s + c));\n      tn(e, t, u, f, i);\n    }\n    var h = e[t], g = n, m = o;\n    for (ve(e, n, t), i(e[o], h) > 0 && ve(e, n, o); g < m; ) {\n      for (ve(e, g, m), g++, m--; i(e[g], h) < 0; )\n        g++;\n      for (; i(e[m], h) > 0; )\n        m--;\n    }\n    i(e[n], h) === 0 ? ve(e, n, m) : (m++, ve(e, m, o)), m <= t && (n = m + 1), t <= m && (o = m - 1);\n  }\n}\nfunction ve(e, t, n) {\n  var o = e[t];\n  e[t] = e[n], e[n] = o;\n}\nfunction yi(e, t) {\n  return e < t ? -1 : e > t ? 1 : 0;\n}\nclass _i {\n  constructor(t = 9) {\n    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();\n  }\n  all() {\n    return this._all(this.data, []);\n  }\n  search(t) {\n    let n = this.data;\n    const o = [];\n    if (!Ne(t, n))\n      return o;\n    const i = this.toBBox, s = [];\n    for (; n; ) {\n      for (let r = 0; r < n.children.length; r++) {\n        const l = n.children[r], a = n.leaf ? i(l) : l;\n        Ne(t, a) && (n.leaf ? o.push(l) : tt(t, a) ? this._all(l, o) : s.push(l));\n      }\n      n = s.pop();\n    }\n    return o;\n  }\n  collides(t) {\n    let n = this.data;\n    if (!Ne(t, n))\n      return !1;\n    const o = [];\n    for (; n; ) {\n      for (let i = 0; i < n.children.length; i++) {\n        const s = n.children[i], r = n.leaf ? this.toBBox(s) : s;\n        if (Ne(t, r)) {\n          if (n.leaf || tt(t, r))\n            return !0;\n          o.push(s);\n        }\n      }\n      n = o.pop();\n    }\n    return !1;\n  }\n  load(t) {\n    if (!(t && t.length))\n      return this;\n    if (t.length < this._minEntries) {\n      for (let o = 0; o < t.length; o++)\n        this.insert(t[o]);\n      return this;\n    }\n    let n = this._build(t.slice(), 0, t.length - 1, 0);\n    if (!this.data.children.length)\n      this.data = n;\n    else if (this.data.height === n.height)\n      this._splitRoot(this.data, n);\n    else {\n      if (this.data.height < n.height) {\n        const o = this.data;\n        this.data = n, n = o;\n      }\n      this._insert(n, this.data.height - n.height - 1, !0);\n    }\n    return this;\n  }\n  insert(t) {\n    return t && this._insert(t, this.data.height - 1), this;\n  }\n  clear() {\n    return this.data = Ee([]), this;\n  }\n  remove(t, n) {\n    if (!t)\n      return this;\n    let o = this.data;\n    const i = this.toBBox(t), s = [], r = [];\n    let l, a, c;\n    for (; o || s.length; ) {\n      if (o || (o = s.pop(), a = s[s.length - 1], l = r.pop(), c = !0), o.leaf) {\n        const u = wi(t, o.children, n);\n        if (u !== -1)\n          return o.children.splice(u, 1), s.push(o), this._condense(s), this;\n      }\n      !c && !o.leaf && tt(o, i) ? (s.push(o), r.push(l), l = 0, a = o, o = o.children[0]) : a ? (l++, o = a.children[l], c = !1) : o = null;\n    }\n    return this;\n  }\n  toBBox(t) {\n    return t;\n  }\n  compareMinX(t, n) {\n    return t.minX - n.minX;\n  }\n  compareMinY(t, n) {\n    return t.minY - n.minY;\n  }\n  toJSON() {\n    return this.data;\n  }\n  fromJSON(t) {\n    return this.data = t, this;\n  }\n  _all(t, n) {\n    const o = [];\n    for (; t; )\n      t.leaf ? n.push(...t.children) : o.push(...t.children), t = o.pop();\n    return n;\n  }\n  _build(t, n, o, i) {\n    const s = o - n + 1;\n    let r = this._maxEntries, l;\n    if (s <= r)\n      return l = Ee(t.slice(n, o + 1)), we(l, this.toBBox), l;\n    i || (i = Math.ceil(Math.log(s) / Math.log(r)), r = Math.ceil(s / Math.pow(r, i - 1))), l = Ee([]), l.leaf = !1, l.height = i;\n    const a = Math.ceil(s / r), c = a * Math.ceil(Math.sqrt(r));\n    Ct(t, n, o, c, this.compareMinX);\n    for (let u = n; u <= o; u += c) {\n      const f = Math.min(u + c - 1, o);\n      Ct(t, u, f, a, this.compareMinY);\n      for (let h = u; h <= f; h += a) {\n        const g = Math.min(h + a - 1, f);\n        l.children.push(this._build(t, h, g, i - 1));\n      }\n    }\n    return we(l, this.toBBox), l;\n  }\n  _chooseSubtree(t, n, o, i) {\n    for (; i.push(n), !(n.leaf || i.length - 1 === o); ) {\n      let s = 1 / 0, r = 1 / 0, l;\n      for (let a = 0; a < n.children.length; a++) {\n        const c = n.children[a], u = et(c), f = Ai(t, c) - u;\n        f < r ? (r = f, s = u < s ? u : s, l = c) : f === r && u < s && (s = u, l = c);\n      }\n      n = l || n.children[0];\n    }\n    return n;\n  }\n  _insert(t, n, o) {\n    const i = o ? t : this.toBBox(t), s = [], r = this._chooseSubtree(i, this.data, n, s);\n    for (r.children.push(t), Oe(r, i); n >= 0 && s[n].children.length > this._maxEntries; )\n      this._split(s, n), n--;\n    this._adjustParentBBoxes(i, s, n);\n  }\n  // split overflowed node into two\n  _split(t, n) {\n    const o = t[n], i = o.children.length, s = this._minEntries;\n    this._chooseSplitAxis(o, s, i);\n    const r = this._chooseSplitIndex(o, s, i), l = Ee(o.children.splice(r, o.children.length - r));\n    l.height = o.height, l.leaf = o.leaf, we(o, this.toBBox), we(l, this.toBBox), n ? t[n - 1].children.push(l) : this._splitRoot(o, l);\n  }\n  _splitRoot(t, n) {\n    this.data = Ee([t, n]), this.data.height = t.height + 1, this.data.leaf = !1, we(this.data, this.toBBox);\n  }\n  _chooseSplitIndex(t, n, o) {\n    let i, s = 1 / 0, r = 1 / 0;\n    for (let l = n; l <= o - n; l++) {\n      const a = ke(t, 0, l, this.toBBox), c = ke(t, l, o, this.toBBox), u = Si(a, c), f = et(a) + et(c);\n      u < s ? (s = u, i = l, r = f < r ? f : r) : u === s && f < r && (r = f, i = l);\n    }\n    return i || o - n;\n  }\n  // sorts node children by the best axis for split\n  _chooseSplitAxis(t, n, o) {\n    const i = t.leaf ? this.compareMinX : bi, s = t.leaf ? this.compareMinY : Ei, r = this._allDistMargin(t, n, o, i), l = this._allDistMargin(t, n, o, s);\n    r < l && t.children.sort(i);\n  }\n  // total margin of all possible split distributions where each node is at least m full\n  _allDistMargin(t, n, o, i) {\n    t.children.sort(i);\n    const s = this.toBBox, r = ke(t, 0, n, s), l = ke(t, o - n, o, s);\n    let a = Ue(r) + Ue(l);\n    for (let c = n; c < o - n; c++) {\n      const u = t.children[c];\n      Oe(r, t.leaf ? s(u) : u), a += Ue(r);\n    }\n    for (let c = o - n - 1; c >= n; c--) {\n      const u = t.children[c];\n      Oe(l, t.leaf ? s(u) : u), a += Ue(l);\n    }\n    return a;\n  }\n  _adjustParentBBoxes(t, n, o) {\n    for (let i = o; i >= 0; i--)\n      Oe(n[i], t);\n  }\n  _condense(t) {\n    for (let n = t.length - 1, o; n >= 0; n--)\n      t[n].children.length === 0 ? n > 0 ? (o = t[n - 1].children, o.splice(o.indexOf(t[n]), 1)) : this.clear() : we(t[n], this.toBBox);\n  }\n}\nfunction wi(e, t, n) {\n  if (!n)\n    return t.indexOf(e);\n  for (let o = 0; o < t.length; o++)\n    if (n(e, t[o]))\n      return o;\n  return -1;\n}\nfunction we(e, t) {\n  ke(e, 0, e.children.length, t, e);\n}\nfunction ke(e, t, n, o, i) {\n  i || (i = Ee(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;\n  for (let s = t; s < n; s++) {\n    const r = e.children[s];\n    Oe(i, e.leaf ? o(r) : r);\n  }\n  return i;\n}\nfunction Oe(e, t) {\n  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;\n}\nfunction bi(e, t) {\n  return e.minX - t.minX;\n}\nfunction Ei(e, t) {\n  return e.minY - t.minY;\n}\nfunction et(e) {\n  return (e.maxX - e.minX) * (e.maxY - e.minY);\n}\nfunction Ue(e) {\n  return e.maxX - e.minX + (e.maxY - e.minY);\n}\nfunction Ai(e, t) {\n  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));\n}\nfunction Si(e, t) {\n  const n = Math.max(e.minX, t.minX), o = Math.max(e.minY, t.minY), i = Math.min(e.maxX, t.maxX), s = Math.min(e.maxY, t.maxY);\n  return Math.max(0, i - n) * Math.max(0, s - o);\n}\nfunction tt(e, t) {\n  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;\n}\nfunction Ne(e, t) {\n  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;\n}\nfunction Ee(e) {\n  return {\n    children: e,\n    height: 1,\n    leaf: !0,\n    minX: 1 / 0,\n    minY: 1 / 0,\n    maxX: -1 / 0,\n    maxY: -1 / 0\n  };\n}\nfunction Ct(e, t, n, o, i) {\n  const s = [t, n];\n  for (; s.length; ) {\n    if (n = s.pop(), t = s.pop(), n - t <= o)\n      continue;\n    const r = t + Math.ceil((n - t) / o / 2) * o;\n    pi(e, r, t, n, i), s.push(t, r, r, n);\n  }\n}\nconst Ti = () => {\n  const e = new _i(), t = /* @__PURE__ */ new Map(), n = () => [...t.values()], o = () => {\n    e.clear(), t.clear();\n  }, i = (f) => {\n    const { minX: h, minY: g, maxX: m, maxY: _ } = f.selector.geometry.bounds, w = { minX: h, minY: g, maxX: m, maxY: _, target: f };\n    e.insert(w), t.set(f.annotation, w);\n  }, s = (f) => {\n    const h = t.get(f.annotation);\n    h && e.remove(h), t.delete(f.annotation);\n  };\n  return {\n    all: n,\n    clear: o,\n    getAt: (f, h) => {\n      const m = e.search({\n        minX: f,\n        minY: h,\n        maxX: f,\n        maxY: h\n      }).map((_) => _.target).filter((_) => _.selector.type === j.RECTANGLE || wn(_.selector, f, h));\n      if (m.length > 0)\n        return m.sort((_, w) => st(_.selector) - st(w.selector)), m[0];\n    },\n    getIntersecting: (f, h, g, m) => e.search({\n      minX: f,\n      minY: h,\n      maxX: f + g,\n      maxY: h + m\n    }).map((_) => _.target),\n    insert: i,\n    remove: s,\n    set: (f, h = !0) => {\n      h && o();\n      const g = f.map((m) => {\n        const { minX: _, minY: w, maxX: y, maxY: E } = m.selector.geometry.bounds;\n        return { minX: _, minY: w, maxX: y, maxY: E, target: m };\n      });\n      g.forEach((m) => t.set(m.target.annotation, m)), e.load(g);\n    },\n    size: () => e.all().length,\n    update: (f, h) => {\n      s(f), i(h);\n    }\n  };\n}, Mi = (e) => {\n  const t = Kn(), n = Ti(), o = Rn(t, e.pointerSelectAction), i = Cn(t), s = xn();\n  return t.observe(({ changes: a }) => {\n    n.set((a.created || []).map((c) => c.target), !1), (a.deleted || []).forEach((c) => n.remove(c.target)), (a.updated || []).forEach(({ oldValue: c, newValue: u }) => n.update(c.target, u.target));\n  }), {\n    store: {\n      ...t,\n      getAt: (a, c) => {\n        const u = n.getAt(a, c);\n        return u ? t.getAnnotation(u.annotation) : void 0;\n      },\n      getIntersecting: (a, c, u, f) => n.getIntersecting(a, c, u, f).map((h) => t.getAnnotation(h.annotation))\n    },\n    selection: o,\n    hover: i,\n    viewport: s\n  };\n}, vi = (e) => {\n  const t = Mi(e);\n  return {\n    ...t,\n    store: Wn(t.store)\n  };\n}, Li = (e) => {\n  let t, n;\n  if (e.nodeName === \"CANVAS\")\n    t = e, n = t.getContext(\"2d\", { willReadFrequently: !0 });\n  else {\n    const i = e;\n    t = document.createElement(\"canvas\"), t.width = i.width, t.height = i.height, n = t.getContext(\"2d\", { willReadFrequently: !0 }), n.drawImage(i, 0, 0, i.width, i.height);\n  }\n  let o = 0;\n  for (let i = 1; i < 10; i++)\n    for (let s = 1; s < 10; s++) {\n      const r = Math.round(s * t.width / 10), l = Math.round(i * t.height / 10), a = n.getImageData(r, l, 1, 1).data, c = (0.299 * a[0] + 0.587 * a[1] + 0.114 * a[2]) / 255;\n      o += c;\n    }\n  return o / 81;\n}, ki = (e) => {\n  const t = Li(e), n = t > 0.6 ? \"dark\" : \"light\";\n  return console.log(`[Annotorious] Image brightness: ${t.toFixed(1)}. Setting ${n} theme.`), n;\n}, Rt = (e, t, n) => t.setAttribute(\"data-theme\", n === \"auto\" ? ki(e) : n), Oi = (e, t) => ({\n  ...e,\n  drawingEnabled: e.drawingEnabled === void 0 ? t.drawingEnabled : e.drawingEnabled,\n  drawingMode: e.drawingMode || t.drawingMode,\n  pointerSelectAction: e.pointerSelectAction || t.pointerSelectAction,\n  theme: e.theme || t.theme\n}), Ut = navigator.userAgent.indexOf(\"Mac OS X\") !== -1, Bi = (e, t) => {\n  const n = t || document, o = (r) => {\n    const l = r;\n    l.key === \"z\" && l.ctrlKey ? e.undo() : l.key === \"y\" && l.ctrlKey && e.redo();\n  }, i = (r) => {\n    const l = r;\n    l.key === \"z\" && l.metaKey && (l.shiftKey ? e.redo() : e.undo());\n  }, s = () => {\n    Ut ? n.removeEventListener(\"keydown\", i) : n.removeEventListener(\"keydown\", o);\n  };\n  return Ut ? n.addEventListener(\"keydown\", i) : n.addEventListener(\"keydown\", o), {\n    destroy: s\n  };\n}, Di = (e, t = {}) => {\n  if (!e)\n    throw \"Missing argument: image\";\n  const n = typeof e == \"string\" ? document.getElementById(e) : e, o = Oi(t, {\n    drawingEnabled: !0,\n    drawingMode: \"drag\",\n    pointerSelectAction: Kt.EDIT,\n    theme: \"light\"\n  }), i = vi(o), { selection: s, store: r } = i, l = Qn(r), a = $n(\n    i,\n    l,\n    o.adapter,\n    o.autoSave\n  ), c = document.createElement(\"DIV\");\n  c.style.position = \"relative\", c.style.display = \"inline-block\", n.style.display = \"block\", n.parentNode.insertBefore(c, n), c.appendChild(n);\n  const u = Bi(l);\n  let f = ro();\n  Rt(n, c, o.theme);\n  const h = new mi({\n    target: c,\n    props: {\n      drawingEnabled: !!o.drawingEnabled,\n      image: n,\n      preferredDrawingMode: o.drawingMode,\n      state: i,\n      style: o.style,\n      user: f\n    }\n  });\n  h.$on(\"click\", (p) => {\n    const { originalEvent: T, annotation: S } = p.detail;\n    S ? s.clickSelect(S.id, T) : s.isEmpty() || s.clear();\n  });\n  const g = to(i, l, o.adapter), m = () => {\n    h.$destroy(), c.parentNode.insertBefore(n, c), c.parentNode.removeChild(c), u.destroy(), l.destroy();\n  }, _ = () => f, w = (p, T, S) => qo(p, T, S), y = (p, T) => Bo(p, T), E = (p) => {\n    if (!$t(p))\n      throw `No drawing tool named ${p}`;\n    h.$set({ toolName: p });\n  }, b = (p) => h.$set({ drawingEnabled: p }), A = (p) => {\n    console.warn(\"Filter not implemented yet\");\n  }, L = (p) => h.$set({ style: p }), D = (p) => Rt(n, c, p), R = (p) => {\n    f = p, h.$set({ user: p });\n  };\n  return {\n    ...g,\n    destroy: m,\n    getUser: _,\n    listDrawingTools: xt,\n    on: a.on,\n    off: a.off,\n    registerDrawingTool: w,\n    registerShapeEditor: y,\n    setDrawingEnabled: b,\n    setDrawingTool: E,\n    setFilter: A,\n    setStyle: L,\n    setTheme: D,\n    setUser: R,\n    state: i\n  };\n};\nexport {\n  Qt as Editor,\n  Xo as EditorMount,\n  Le as Handle,\n  Yi as IdentityTransform,\n  po as PolygonEditor,\n  ko as RectangleEditor,\n  An as RectangleUtil,\n  Vo as RubberbandRectangle,\n  mi as SVGAnnotationLayer,\n  j as ShapeType,\n  Ro as ToolMount,\n  Pi as W3CImageFormat,\n  ri as addEventListeners,\n  Fe as boundsFromPoints,\n  st as computeArea,\n  Di as createImageAnnotator,\n  Mi as createImageAnnotatorState,\n  ii as createSVGTransform,\n  vi as createSvelteImageAnnotatorState,\n  ki as detectTheme,\n  Qe as distance,\n  wo as enableResponsive,\n  Oi as fillDefaults,\n  Oo as getEditor,\n  $t as getTool,\n  Bi as initKeyboardCommands,\n  wn as intersects,\n  bo as isTouch,\n  xt as listDrawingTools,\n  Sn as parseFragmentSelector,\n  On as parseSVGSelector,\n  fo as parseW3CImageAnnotation,\n  Bo as registerEditor,\n  at as registerShapeUtil,\n  qo as registerTool,\n  Li as sampleBrightness,\n  Tn as serializeFragmentSelector,\n  Bn as serializeSVGSelector,\n  uo as serializeW3CImageAnnotation,\n  Rt as setTheme\n};\n//# sourceMappingURL=annotorious.es.js.map\n","import { ShapeType } from '@annotorious/annotorious';\nimport type { ImageAnnotation, PolygonGeometry, RectangleGeometry, Shape } from '@annotorious/annotorious';\nimport type { PageMetadata } from '@annotorious/formats';\nimport type OpenSeadragon from 'openseadragon';\n\nexport interface ImageDimensions {\n\n  height: number;\n\n  width: number;\n\n}\n\nexport const getImageDimensions = (\n  viewer: OpenSeadragon.Viewer\n): Promise<ImageDimensions> => new Promise(resolve => {\n  if (viewer.world.getItemAt(0)?.source) {\n    // Image already loaded - resolve immediately\n    const { x, y } = viewer.world.getItemAt(0).source.dimensions;\n    resolve({ width: x, height: y });\n  } else {\n    // Attach onOpen handler and resolve then\n    const getDimensions = () => {\n      const { x, y } = viewer.world.getItemAt(0).source.dimensions;\n\n      viewer.removeHandler('open', getDimensions);\n\n      resolve({ width: x, height: y });\n    }\n\n    viewer.addHandler('open', getDimensions);\n  }\n});\n\nconst scaleShape = (shape: Shape, kx: number, ky: number): Shape => {\n  const { bounds } = shape.geometry;\n\n  const minX = bounds.minX * kx;\n  const minY = bounds.minY * ky;\n  const maxX = bounds.maxX * kx;\n  const maxY = bounds.maxY * ky;\n\n  if (shape.type === ShapeType.RECTANGLE) {\n    return {\n      type: ShapeType.RECTANGLE,\n      geometry: {\n        bounds: { minX, minY, maxX, maxY },\n        x: minX,\n        y: minY,\n        w: maxX - minX, \n        h: maxY - minY\n      } as RectangleGeometry\n    }\n  } else if (shape.type === ShapeType.POLYGON) {\n    return {\n      type: ShapeType.POLYGON,\n      geometry: {\n        bounds: { minX, minY, maxX, maxY },\n        points: (shape.geometry as PolygonGeometry)\n          .points.map(([x, y]) => ([x * kx, y * ky]))\n      } as PolygonGeometry\n    }\n  } else  {\n    console.error('Unsupported shape type', shape);\n    return shape;\n  }\n}\n\nexport const scaleAnnotations = (\n  a: ImageAnnotation[], \n  page: PageMetadata, \n  dim: ImageDimensions\n): {\n  scaled: ImageAnnotation[],\n  scaleX: number,\n  scaleY: number\n} => {\n  const pageWidth = page.width;\n  const pageHeight = page.height;\n\n  const imgWidth = dim.width;\n  const imgHeight = dim.height;\n\n  if (pageWidth && pageHeight) {\n    const scaleX = imgWidth / pageWidth;\n    const scaleY = imgHeight / pageHeight;\n\n    if (scaleX === 1 && scaleY === 1) {\n      // No need to scale\n      return { scaled: a, scaleX, scaleY };\n    } else {\n      console.log('[TextLayerExtension] Page and image are different size - scaling annotations');\n\n      const scaled = a.map(annotation => ({\n        ...annotation,\n        target: {\n          ...annotation.target,\n          selector: scaleShape(annotation.target.selector, scaleX, scaleY)\n        }\n      }));\n\n      return { scaled, scaleX, scaleY };\n    }\n  } else {\n    console.warn('[TextLayerExtension] Cannot scale annotations without page dimensions');\n    return { scaled: a, scaleX: 1, scaleY: 1 };\n  }\n}\n","<script lang=\"ts\">\n  import type { ImageAnnotation, ImageAnnotatorState, StoreChangeEvent } from '@annotorious/annotorious';\n  import { onMount } from 'svelte';\n  import { FillBoundsLabel, FixedPageSizeLabel, FixedScreenSizeLabel } from './Label';\n  import type { TextLayerOpts } from './Types';\n  import { getImageDimensions } from './ImageDimensions';\n    \n  /** props **/\n  export let state: ImageAnnotatorState;\n  export let viewer: OpenSeadragon.Viewer;\n  export let opts: TextLayerOpts;\n  export let visible: boolean = true;\n  export let captureEvents: boolean = false;\n\n  const { store } = state;\n\n  let transform: string;\n\n  let scale: number;\n\n  let annotations: ImageAnnotation[] = [];\n\n  let width: number;\n\n  let height: number;\n\n  $: fontSize = opts.fontSize || 16;\n\n  const redraw = () => {\n    const viewportBounds = viewer.viewport.viewportToImageRectangle(viewer.viewport.getBounds(true));\n\n    const containerWidth = viewer.viewport.getContainerSize().x;\n    const zoom = viewer.viewport.getZoom(true);\n    scale = zoom * containerWidth / viewer.world.getContentFactor();\n\n    // @ts-ignore note: getRotation(true <- realtime value) only since OSD 4!\n    let rotation = Math.PI * viewer.viewport.getRotation(true) / 180;\n    if (rotation < 0)\n      rotation += 2 * Math.PI;\n    \n    if (rotation > 2 * Math.PI)\n      rotation -= 2 * Math.PI;\n\n    const flipped = viewer.viewport.getFlip();\n\n    const dx = flipped ? \n      // @ts-ignore\n      viewer.viewport._containerInnerSize.x + viewportBounds.x * scale :\n      - viewportBounds.x * scale;\n\n    const dy = - viewportBounds.y * scale;\n\n    let offsetX: number, offsetY: number;\n\n    if (rotation > 0 && rotation <= Math.PI / 2) {\n      offsetX = viewportBounds.height * scale;\n      offsetY = 0;\n    } else if (rotation > Math.PI / 2 && rotation <= Math.PI) {\n      offsetX = viewportBounds.width * scale;\n      offsetY = viewportBounds.height * scale;\n    } else if (rotation > Math.PI && rotation <= Math.PI * 1.5) {\n      offsetX = 0;\n      offsetY = viewportBounds.width * scale;\n    } else {\n      offsetX = 0;\n      offsetY = 0;\n    }\n\n    const tx = Math.round(100 * (offsetX + dx * Math.cos(rotation) - dy * Math.sin(rotation))) / 100;\n    const ty = Math.round(100 * (offsetY + dx * Math.sin(rotation) + dy * Math.cos(rotation))) / 100;\n    \n    transform = `translate(${tx}px, ${ty}px) rotate(${rotation}rad) scaleX(${flipped ? - scale : scale}) scaleY(${scale})`;\n  }\n\n  onMount(() => {\n    getImageDimensions(viewer).then(dimensions => {\n      width = dimensions.width;\n      height = dimensions.height;\n    });\n\n    viewer.addHandler('update-viewport', redraw);\n\n    const onStoreChange = ((event: StoreChangeEvent<ImageAnnotation>) => {\n      annotations = event.state;\n      redraw();\n    });\n\n    store.observe(onStoreChange);\n\n    const onCopy = (evt: ClipboardEvent) => {\n      const unformatted = document.getSelection()!.toString();\n\n      // @ts-ignore\n      const clipboardData = evt.clipboardData || window.clipboardData;  \n      clipboardData.setData('text/plain', unformatted);\n      clipboardData.setData('text/html', unformatted);\n\n      evt.preventDefault();\n    }\n\n    document.addEventListener('copy', onCopy);\n\n    return () => {\n      viewer.removeHandler('update-viewport', redraw);\n\n      store.unobserve(onStoreChange);\n\n      document.removeEventListener('copy', onCopy);\n    }\n  });\n</script>\n\n{#if visible}\n  <div \n    style={`transform:${transform}; width: ${width}px; height: ${height}px; font-size: ${fontSize}px;`}\n    class=\"a9s-annotationlayer a9s-osd-textlayer\"\n    class:fixed-screen-size={opts.mode === 'fixedScreenSize' || (!opts.mode)}\n    class:fixed-page-size={opts.mode === 'fixedPageSize'}\n    class:fill-bounds={opts.mode === 'fillBounds'}\n    class:bottomleft={opts.position !== 'topleft'}\n    class:topleft={opts.position === 'topleft'}\n    class:pointer-events={captureEvents}>\n    {#if opts.mode === 'fixedScreenSize' || (!opts.mode)}\n      {#each annotations as annotation}\n        <FixedScreenSizeLabel \n          annotation={annotation} \n          opts={opts} \n          imageSize={[width, height]}\n          scale={scale} />\n      {/each}\n    {:else if opts.mode === 'fixedPageSize'}\n      {#each annotations as annotation}\n        <FixedPageSizeLabel \n          annotation={annotation} \n          opts={opts} />\n      {/each}\n    {:else if opts.mode === 'fillBounds'}\n      {#each annotations as annotation}\n        <FillBoundsLabel \n          annotation={annotation} \n          opts={opts} />\n      {/each}\n    {/if}\n  </div>\n{/if}","import type { ImageAnnotation, ImageAnnotatorState } from '@annotorious/annotorious';\nimport type { OpenSeadragonAnnotator } from '@annotorious/openseadragon';\nimport { parseALTO } from '@annotorious/formats';\nimport type { OCRFormat, TextLayerOpts } from './Types';\nimport OpenSeadragonTextLayer from './TextLayer.svelte';\nimport { getImageDimensions, scaleAnnotations } from './ImageDimensions';\n\nimport './textLayerExtension.css';\n\nexport const mountExtension = (\n  anno: OpenSeadragonAnnotator<ImageAnnotation>, \n  opts: TextLayerOpts\n) => {\n  // @ts-ignore\n  const { viewer, state } = anno;\n\n  let _visible = opts.defaultVisible === undefined ? true : opts.defaultVisible;\n\n  let _locked = false;\n\n  // @ts-ignore\n  const textLayer = new OpenSeadragonTextLayer({\n    target: viewer.element.querySelector('.openseadragon-canvas')!,\n    props: { state: state as ImageAnnotatorState, viewer, opts, visible: _visible }\n  });\n\n  const isVisible = () => _visible;\n\n  const isLocked = () => _locked;\n\n  const loadOCR = (url: string, format: OCRFormat = 'ALTO') => fetch(url)\n    .then(res => res.text())\n    .then(xml => {\n      const { annotations, metadata } = parseALTO(xml);\n\n      getImageDimensions(viewer).then(dimensions => {\n        const { scaled, scaleY } = scaleAnnotations(annotations, metadata, dimensions);\n\n        if (!opts.fontSize && metadata.averageLineHeight) {\n          // No user-defined font size - automatic!\n          const fontSize = metadata.averageLineHeight * scaleY * 0.5;\n\n          textLayer.$set({ opts: { ...opts, fontSize }});\n        }\n\n        anno.setAnnotations(scaled);\n      });\n    });\n\n  const setLocked = (locked: boolean) => {\n    _locked = locked;\n    viewer.setMouseNavEnabled(!locked);\n\n    // @ts-ignore\n    textLayer.$set({ captureEvents: locked });\n  }\n\n  const setVisible = (visible: boolean) => {\n    _visible = visible;\n\n    textLayer.$set({ visible });\n  }\n\n  const unmount = () => textLayer.$destroy();\n\n  return {\n    isLocked,\n    isVisible,\n    loadOCR,\n    setLocked,\n    setVisible,\n    unmount\n  }\n\n}"],"names":["transcriptionLabel","annotation","_a","b","ht","nn","en","on","n","rn","_t","gt","e","On","U","It","An","l","d","g","m","u","f","Ln","Pn","Gn","Un","te","ne","r","s","i","c","noop","run","fn","blank_object","run_all","fns","is_function","thing","safe_not_equal","a","is_empty","obj","append","target","node","insert","anchor","detach","destroy_each","iterations","detaching","element","name","text","data","empty","attr","attribute","value","children","set_data","toggle_class","toggle","current_component","set_current_component","component","get_current_component","onMount","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","update_scheduled","schedule_update","flush","add_render_callback","seen_callbacks","flushidx","saved_component","update","callback","$$","dirty","flush_render_callbacks","filtered","targets","outroing","outros","group_outros","check_outros","transition_in","block","local","transition_out","ensure_array_like","array_like_or_iterator","create_component","mount_component","fragment","after_update","new_on_destroy","destroy_component","make_dirty","init","options","instance","create_fragment","not_equal","props","append_styles","parent_component","ready","ret","rest","nodes","SvelteComponent","__publicField","type","callbacks","index","PUBLIC_VERSION","ctx","div","span","create_if_block","ref","$$props","opts","$$value","$$invalidate","left","top","width","height","scaleX","scaleY","label","div_style_value","getStyle","size","offsetX","offsetY","w","cx","h","cy","scale","imageSize","x","y","bottom","t","Ke","V","nt","Nt","dt","ae","q","W","sn","Gt","ln","an","cn","Ge","se","B","k","rt","zt","oe","ce","F","un","ze","dn","Ie","Be","Ht","Te","ue","be","He","Ae","mt","hn","ot","gn","Ft","it","We","pe","mn","pn","Ve","de","re","le","P","C","Se","$","Q","yn","ee","_n","j","at","Fe","bn","En","K","Nn","wt","bt","Le","ho","_","Et","At","E","go","Qt","mo","A","po","bo","Eo","Ao","So","To","Mo","L","D","R","p","T","S","M","O","X","Z","ge","me","Me","ie","I","z","H","J","fe","N","qe","ut","Y","v","Ye","De","Xe","Ce","vo","Lo","ko","Io","St","Po","Yo","getImageDimensions","viewer","resolve","getDimensions","scaleShape","shape","kx","ky","bounds","minX","minY","maxX","maxY","ShapeType","scaleAnnotations","page","dim","pageWidth","pageHeight","imgWidth","imgHeight","current","each_blocks","fixedscreensizelabel_changes","state","visible","captureEvents","store","transform","annotations","redraw","viewportBounds","containerWidth","zoom","rotation","flipped","dx","dy","tx","ty","dimensions","onStoreChange","event","onCopy","evt","unformatted","clipboardData","fontSize","mountExtension","anno","_visible","_locked","textLayer","OpenSeadragonTextLayer","url","format","res","xml","metadata","parseALTO","scaled","locked"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,14]}