{"version":3,"file":"annotorious-openseadragon-textlayer.js","sources":["../src/labelConfigurations/transcriptionLabel.ts","../node_modules/@annotorious/formats/dist/annotorious-formats.es.js","../node_modules/svelte/src/runtime/internal/utils.js","../node_modules/svelte/src/runtime/internal/dom.js","../node_modules/svelte/src/runtime/internal/lifecycle.js","../node_modules/svelte/src/runtime/internal/scheduler.js","../node_modules/svelte/src/runtime/internal/transitions.js","../node_modules/svelte/src/runtime/internal/each.js","../node_modules/svelte/src/runtime/internal/Component.js","../node_modules/svelte/src/shared/version.js","../node_modules/svelte/src/runtime/internal/disclose-version/index.js","../src/Label/FillBoundsLabel.svelte","../src/Label/FixedPageSizeLabel.svelte","../src/Label/FixedScreenSizeLabel.svelte","../node_modules/@annotorious/annotorious/dist/annotorious.es.js","../src/ImageDimensions.ts","../src/TextLayer.svelte","../src/textLayerExtension.ts"],"sourcesContent":["import type { ImageAnnotation } from '@annotorious/annotorious';\n\nexport const transcriptionLabel = (annotation: ImageAnnotation) =>\n  annotation.bodies.find(b => b.purpose === 'transcribing')?.value;","let ht;\nconst nn = new Uint8Array(16);\nfunction en() {\n  if (!ht && (ht = typeof crypto < \"u\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !ht))\n    throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n  return ht(nn);\n}\nconst L = [];\nfor (let t = 0; t < 256; ++t)\n  L.push((t + 256).toString(16).slice(1));\nfunction on(t, n = 0) {\n  return L[t[n + 0]] + L[t[n + 1]] + L[t[n + 2]] + L[t[n + 3]] + \"-\" + L[t[n + 4]] + L[t[n + 5]] + \"-\" + L[t[n + 6]] + L[t[n + 7]] + \"-\" + L[t[n + 8]] + L[t[n + 9]] + \"-\" + L[t[n + 10]] + L[t[n + 11]] + L[t[n + 12]] + L[t[n + 13]] + L[t[n + 14]] + L[t[n + 15]];\n}\nconst rn = typeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto), _t = {\n  randomUUID: rn\n};\nfunction gt(t, n, e) {\n  if (_t.randomUUID && !n && !t)\n    return _t.randomUUID();\n  t = t || {};\n  const o = t.random || (t.rng || en)();\n  if (o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, n) {\n    e = e || 0;\n    for (let r = 0; r < 16; ++r)\n      n[e + r] = o[r];\n    return n;\n  }\n  return on(o);\n}\nvar sn = Object.defineProperty, an = (t, n, e) => n in t ? sn(t, n, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[n] = e, Ft = (t, n, e) => (an(t, typeof n != \"symbol\" ? n + \"\" : n, e), e);\nfunction rt() {\n}\nfunction Lt(t, n) {\n  for (const e in n)\n    t[e] = n[e];\n  return (\n    /** @type {T & S} */\n    t\n  );\n}\nfunction qt(t) {\n  return t();\n}\nfunction Nt() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction D(t) {\n  t.forEach(qt);\n}\nfunction H(t) {\n  return typeof t == \"function\";\n}\nfunction yt(t, n) {\n  return t != t ? n == n : t !== n || t && typeof t == \"object\" || typeof t == \"function\";\n}\nfunction cn(t) {\n  return Object.keys(t).length === 0;\n}\nfunction ln(t, n, e, o) {\n  if (t) {\n    const r = zt(t, n, e, o);\n    return t[0](r);\n  }\n}\nfunction zt(t, n, e, o) {\n  return t[1] && o ? Lt(e.ctx.slice(), t[1](o(n))) : e.ctx;\n}\nfunction un(t, n, e, o) {\n  if (t[2] && o) {\n    const r = t[2](o(e));\n    if (n.dirty === void 0)\n      return r;\n    if (typeof r == \"object\") {\n      const s = [], a = Math.max(n.dirty.length, r.length);\n      for (let c = 0; c < a; c += 1)\n        s[c] = n.dirty[c] | r[c];\n      return s;\n    }\n    return n.dirty | r;\n  }\n  return n.dirty;\n}\nfunction pn(t, n, e, o, r, s) {\n  if (r) {\n    const a = zt(n, e, o, s);\n    t.p(a, r);\n  }\n}\nfunction dn(t) {\n  if (t.ctx.length > 32) {\n    const n = [], e = t.ctx.length / 32;\n    for (let o = 0; o < e; o++)\n      n[o] = -1;\n    return n;\n  }\n  return -1;\n}\nfunction Gt(t) {\n  const n = {};\n  for (const e in t)\n    e[0] !== \"$\" && (n[e] = t[e]);\n  return n;\n}\nfunction ft(t) {\n  return t ?? \"\";\n}\nfunction Ut(t, n) {\n  t.appendChild(n);\n}\nfunction S(t, n, e) {\n  t.insertBefore(n, e || null);\n}\nfunction T(t) {\n  t.parentNode && t.parentNode.removeChild(t);\n}\nfunction hn(t, n) {\n  for (let e = 0; e < t.length; e += 1)\n    t[e] && t[e].d(n);\n}\nfunction M(t) {\n  return document.createElementNS(\"http://www.w3.org/2000/svg\", t);\n}\nfunction Kt(t) {\n  return document.createTextNode(t);\n}\nfunction G() {\n  return Kt(\" \");\n}\nfunction Qt() {\n  return Kt(\"\");\n}\nfunction P(t, n, e, o) {\n  return t.addEventListener(n, e, o), () => t.removeEventListener(n, e, o);\n}\nfunction i(t, n, e) {\n  e == null ? t.removeAttribute(n) : t.getAttribute(n) !== e && t.setAttribute(n, e);\n}\nfunction gn(t) {\n  return Array.from(t.childNodes);\n}\nfunction kt(t, n, e) {\n  t.classList.toggle(n, !!e);\n}\nfunction mn(t, n, { bubbles: e = !1, cancelable: o = !1 } = {}) {\n  return new CustomEvent(t, { detail: n, bubbles: e, cancelable: o });\n}\nlet st;\nfunction ot(t) {\n  st = t;\n}\nfunction fn() {\n  if (!st)\n    throw new Error(\"Function called outside component initialization\");\n  return st;\n}\nfunction yn() {\n  const t = fn();\n  return (n, e, { cancelable: o = !1 } = {}) => {\n    const r = t.$$.callbacks[n];\n    if (r) {\n      const s = mn(\n        /** @type {string} */\n        n,\n        e,\n        { cancelable: o }\n      );\n      return r.slice().forEach((a) => {\n        a.call(t, s);\n      }), !s.defaultPrevented;\n    }\n    return !0;\n  };\n}\nfunction C(t, n) {\n  const e = t.$$.callbacks[n.type];\n  e && e.slice().forEach((o) => o.call(this, n));\n}\nconst tt = [], Rt = [];\nlet nt = [];\nconst Wt = [], $n = /* @__PURE__ */ Promise.resolve();\nlet Pt = !1;\nfunction xn() {\n  Pt || (Pt = !0, $n.then(Jt));\n}\nfunction Ht(t) {\n  nt.push(t);\n}\nconst At = /* @__PURE__ */ new Set();\nlet Y = 0;\nfunction Jt() {\n  if (Y !== 0)\n    return;\n  const t = st;\n  do {\n    try {\n      for (; Y < tt.length; ) {\n        const n = tt[Y];\n        Y++, ot(n), wn(n.$$);\n      }\n    } catch (n) {\n      throw tt.length = 0, Y = 0, n;\n    }\n    for (ot(null), tt.length = 0, Y = 0; Rt.length; )\n      Rt.pop()();\n    for (let n = 0; n < nt.length; n += 1) {\n      const e = nt[n];\n      At.has(e) || (At.add(e), e());\n    }\n    nt.length = 0;\n  } while (tt.length);\n  for (; Wt.length; )\n    Wt.pop()();\n  Pt = !1, At.clear(), ot(t);\n}\nfunction wn(t) {\n  if (t.fragment !== null) {\n    t.update(), D(t.before_update);\n    const n = t.dirty;\n    t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, n), t.after_update.forEach(Ht);\n  }\n}\nfunction bn(t) {\n  const n = [], e = [];\n  nt.forEach((o) => t.indexOf(o) === -1 ? n.push(o) : e.push(o)), e.forEach((o) => o()), nt = n;\n}\nconst mt = /* @__PURE__ */ new Set();\nlet K;\nfunction Tn() {\n  K = {\n    r: 0,\n    c: [],\n    p: K\n    // parent group\n  };\n}\nfunction En() {\n  K.r || D(K.c), K = K.p;\n}\nfunction F(t, n) {\n  t && t.i && (mt.delete(t), t.i(n));\n}\nfunction k(t, n, e, o) {\n  if (t && t.o) {\n    if (mt.has(t))\n      return;\n    mt.add(t), K.c.push(() => {\n      mt.delete(t), o && (e && t.d(1), o());\n    }), t.o(n);\n  } else\n    o && o();\n}\nfunction vt(t) {\n  return (t == null ? void 0 : t.length) !== void 0 ? t : Array.from(t);\n}\nfunction Q(t) {\n  t && t.c();\n}\nfunction q(t, n, e) {\n  const { fragment: o, after_update: r } = t.$$;\n  o && o.m(n, e), Ht(() => {\n    const s = t.$$.on_mount.map(qt).filter(H);\n    t.$$.on_destroy ? t.$$.on_destroy.push(...s) : D(s), t.$$.on_mount = [];\n  }), r.forEach(Ht);\n}\nfunction z(t, n) {\n  const e = t.$$;\n  e.fragment !== null && (bn(e.after_update), D(e.on_destroy), e.fragment && e.fragment.d(n), e.on_destroy = e.fragment = null, e.ctx = []);\n}\nfunction Sn(t, n) {\n  t.$$.dirty[0] === -1 && (tt.push(t), xn(), t.$$.dirty.fill(0)), t.$$.dirty[n / 31 | 0] |= 1 << n % 31;\n}\nfunction $t(t, n, e, o, r, s, a = null, c = [-1]) {\n  const l = st;\n  ot(t);\n  const d = t.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props: s,\n    update: rt,\n    not_equal: r,\n    bound: Nt(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(n.context || (l ? l.$$.context : [])),\n    // everything else\n    callbacks: Nt(),\n    dirty: c,\n    skip_bound: !1,\n    root: n.target || l.$$.root\n  };\n  a && a(d.root);\n  let g = !1;\n  if (d.ctx = e ? e(t, n.props || {}, (y, p, ...h) => {\n    const f = h.length ? h[0] : p;\n    return d.ctx && r(d.ctx[y], d.ctx[y] = f) && (!d.skip_bound && d.bound[y] && d.bound[y](f), g && Sn(t, y)), p;\n  }) : [], d.update(), g = !0, D(d.before_update), d.fragment = o ? o(d.ctx) : !1, n.target) {\n    if (n.hydrate) {\n      const y = gn(n.target);\n      d.fragment && d.fragment.l(y), y.forEach(T);\n    } else\n      d.fragment && d.fragment.c();\n    n.intro && F(t.$$.fragment), q(t, n.target, n.anchor), Jt();\n  }\n  ot(l);\n}\nclass xt {\n  constructor() {\n    Ft(this, \"$$\"), Ft(this, \"$$set\");\n  }\n  /** @returns {void} */\n  $destroy() {\n    z(this, 1), this.$destroy = rt;\n  }\n  /**\n   * @template {Extract<keyof Events, string>} K\n   * @param {K} type\n   * @param {((e: Events[K]) => void) | null | undefined} callback\n   * @returns {() => void}\n   */\n  $on(n, e) {\n    if (!H(e))\n      return rt;\n    const o = this.$$.callbacks[n] || (this.$$.callbacks[n] = []);\n    return o.push(e), () => {\n      const r = o.indexOf(e);\n      r !== -1 && o.splice(r, 1);\n    };\n  }\n  /**\n   * @param {Partial<Props>} props\n   * @returns {void}\n   */\n  $set(n) {\n    this.$$set && !cn(n) && (this.$$.skip_bound = !0, this.$$set(n), this.$$.skip_bound = !1);\n  }\n}\nconst On = \"4\";\ntypeof window < \"u\" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(On);\nvar R = /* @__PURE__ */ ((t) => (t.ELLIPSE = \"ELLIPSE\", t.POLYGON = \"POLYGON\", t.RECTANGLE = \"RECTANGLE\", t))(R || {});\nconst It = (t, n) => n, Zt = (t) => {\n  let n = 1 / 0, e = 1 / 0, o = -1 / 0, r = -1 / 0;\n  return t.forEach(([s, a]) => {\n    n = Math.min(n, s), e = Math.min(e, a), o = Math.max(o, s), r = Math.max(r, a);\n  }), { minX: n, minY: e, maxX: o, maxY: r };\n}, An = {\n  area: (t) => Math.PI * t.geometry.rx * t.geometry.ry,\n  intersects: (t, n, e) => {\n    const { cx: o, cy: r, rx: s, ry: a } = t.geometry, c = 0, l = Math.cos(c), d = Math.sin(c), g = n - o, y = e - r, p = l * g + d * y, h = d * g - l * y;\n    return p * p / (s * s) + h * h / (a * a) <= 1;\n  }\n};\nIt(R.ELLIPSE, An);\nconst Ln = {\n  area: (t) => {\n    const { points: n } = t.geometry;\n    let e = 0, o = n.length - 1;\n    for (let r = 0; r < n.length; r++)\n      e += (n[o][0] + n[r][0]) * (n[o][1] - n[r][1]), o = r;\n    return Math.abs(0.5 * e);\n  },\n  intersects: (t, n, e) => {\n    const { points: o } = t.geometry;\n    let r = !1;\n    for (let s = 0, a = o.length - 1; s < o.length; a = s++) {\n      const c = o[s][0], l = o[s][1], d = o[a][0], g = o[a][1];\n      l > e != g > e && n < (d - c) * (e - l) / (g - l) + c && (r = !r);\n    }\n    return r;\n  }\n};\nIt(R.POLYGON, Ln);\nconst Pn = {\n  area: (t) => t.geometry.w * t.geometry.h,\n  intersects: (t, n, e) => n >= t.geometry.x && n <= t.geometry.x + t.geometry.w && e >= t.geometry.y && e <= t.geometry.y + t.geometry.h\n};\nIt(R.RECTANGLE, Pn);\nconst Hn = (t, n = !1) => {\n  const e = typeof t == \"string\" ? t : t.value, o = /^(xywh)=(pixel|percent)?:?(.+?),(.+?),(.+?),(.+)*/g, r = [...e.matchAll(o)][0], [s, a, c, l, d, g, y] = r;\n  if (a !== \"xywh\")\n    throw new Error(\"Unsupported MediaFragment: \" + e);\n  if (c && c !== \"pixel\")\n    throw new Error(`Unsupported MediaFragment unit: ${c}`);\n  const [p, h, f, u] = [l, d, g, y].map(parseFloat);\n  return {\n    type: R.RECTANGLE,\n    geometry: {\n      x: p,\n      y: h,\n      w: f,\n      h: u,\n      bounds: {\n        minX: p,\n        minY: n ? h - u : h,\n        maxX: p + f,\n        maxY: n ? h : h + u\n      }\n    }\n  };\n}, Yt = \"http://www.w3.org/2000/svg\", Ct = (t) => {\n  const n = (o) => {\n    Array.from(o.attributes).forEach((r) => {\n      r.name.startsWith(\"on\") && o.removeAttribute(r.name);\n    });\n  }, e = t.getElementsByTagName(\"script\");\n  return Array.from(e).reverse().forEach((o) => o.parentNode.removeChild(o)), Array.from(t.querySelectorAll(\"*\")).forEach(n), t;\n}, In = (t) => {\n  const n = new XMLSerializer().serializeToString(t.documentElement).replace(\"<svg>\", `<svg xmlns=\"${Yt}\">`);\n  return new DOMParser().parseFromString(n, \"image/svg+xml\").documentElement;\n}, Mn = (t) => {\n  const n = new DOMParser().parseFromString(t, \"image/svg+xml\"), e = n.lookupPrefix(Yt), o = n.lookupNamespaceURI(null);\n  return e || o ? Ct(n).firstChild : Ct(In(n)).firstChild;\n}, _n = (t) => {\n  const [n, e, o] = t.match(/(<polygon points=[\"|'])([^(\"|')]*)/) || [], r = o.split(\" \").map((s) => s.split(\",\").map(parseFloat));\n  return {\n    type: R.POLYGON,\n    geometry: {\n      points: r,\n      bounds: Zt(r)\n    }\n  };\n}, Fn = (t) => {\n  const n = Mn(t), e = parseFloat(n.getAttribute(\"cx\")), o = parseFloat(n.getAttribute(\"cy\")), r = parseFloat(n.getAttribute(\"rx\")), s = parseFloat(n.getAttribute(\"ry\")), a = {\n    minX: e - r,\n    minY: o - s,\n    maxX: e + r,\n    maxY: o + s\n  };\n  return {\n    type: R.ELLIPSE,\n    geometry: {\n      cx: e,\n      cy: o,\n      rx: r,\n      ry: s,\n      bounds: a\n    }\n  };\n}, Nn = (t) => {\n  const n = typeof t == \"string\" ? t : t.value;\n  if (n.includes(\"<polygon points=\"))\n    return _n(n);\n  if (n.includes(\"<ellipse \"))\n    return Fn(n);\n  throw \"Unsupported SVG shape: \" + n;\n}, Gn = [];\nfor (let t = 0; t < 256; ++t)\n  Gn.push((t + 256).toString(16).slice(1));\ntypeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nconst Un = [];\nfor (let t = 0; t < 256; ++t)\n  Un.push((t + 256).toString(16).slice(1));\ntypeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nlet kn = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce((n, e) => (e &= 63, e < 36 ? n += e.toString(36) : e < 62 ? n += (e - 26).toString(36).toUpperCase() : e > 62 ? n += \"-\" : n += \"_\", n), \"\");\nkn();\nfunction Dt(t, n, e) {\n  const o = t.slice();\n  return o[10] = n[e], o[12] = e, o;\n}\nfunction Xt(t) {\n  let n, e;\n  return n = new et({\n    props: {\n      x: (\n        /*point*/\n        t[10][0]\n      ),\n      y: (\n        /*point*/\n        t[10][1]\n      ),\n      scale: (\n        /*viewportScale*/\n        t[3]\n      )\n    }\n  }), n.$on(\"pointerdown\", function() {\n    H(\n      /*grab*/\n      t[9](`HANDLE-${/*idx*/\n      t[12]}`)\n    ) && t[9](`HANDLE-${/*idx*/\n    t[12]}`).apply(this, arguments);\n  }), {\n    c() {\n      Q(n.$$.fragment);\n    },\n    m(o, r) {\n      q(n, o, r), e = !0;\n    },\n    p(o, r) {\n      t = o;\n      const s = {};\n      r & /*geom*/\n      16 && (s.x = /*point*/\n      t[10][0]), r & /*geom*/\n      16 && (s.y = /*point*/\n      t[10][1]), r & /*viewportScale*/\n      8 && (s.scale = /*viewportScale*/\n      t[3]), n.$set(s);\n    },\n    i(o) {\n      e || (F(n.$$.fragment, o), e = !0);\n    },\n    o(o) {\n      k(n.$$.fragment, o), e = !1;\n    },\n    d(o) {\n      z(n, o);\n    }\n  };\n}\nfunction Rn(t) {\n  let n, e, o, r, s, a, c, l, d, g, y, p = vt(\n    /*geom*/\n    t[4].points\n  ), h = [];\n  for (let u = 0; u < p.length; u += 1)\n    h[u] = Xt(Dt(t, p, u));\n  const f = (u) => k(h[u], 1, 1, () => {\n    h[u] = null;\n  });\n  return {\n    c() {\n      n = M(\"polygon\"), r = G(), s = M(\"polygon\"), c = G();\n      for (let u = 0; u < h.length; u += 1)\n        h[u].c();\n      l = Qt(), i(n, \"class\", \"a9s-outer\"), i(n, \"style\", e = /*computedStyle*/\n      t[1] ? \"display:none;\" : void 0), i(n, \"points\", o = /*geom*/\n      t[4].points.map(Bt).join(\" \")), i(s, \"class\", \"a9s-inner a9s-shape-handle\"), i(\n        s,\n        \"style\",\n        /*computedStyle*/\n        t[1]\n      ), i(s, \"points\", a = /*geom*/\n      t[4].points.map(jt).join(\" \"));\n    },\n    m(u, $) {\n      S(u, n, $), S(u, r, $), S(u, s, $), S(u, c, $);\n      for (let x = 0; x < h.length; x += 1)\n        h[x] && h[x].m(u, $);\n      S(u, l, $), d = !0, g || (y = [\n        P(n, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"SHAPE\")\n          ) && t[9](\"SHAPE\").apply(this, arguments);\n        }),\n        P(s, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"SHAPE\")\n          ) && t[9](\"SHAPE\").apply(this, arguments);\n        })\n      ], g = !0);\n    },\n    p(u, $) {\n      if (t = u, (!d || $ & /*computedStyle*/\n      2 && e !== (e = /*computedStyle*/\n      t[1] ? \"display:none;\" : void 0)) && i(n, \"style\", e), (!d || $ & /*geom*/\n      16 && o !== (o = /*geom*/\n      t[4].points.map(Bt).join(\" \"))) && i(n, \"points\", o), (!d || $ & /*computedStyle*/\n      2) && i(\n        s,\n        \"style\",\n        /*computedStyle*/\n        t[1]\n      ), (!d || $ & /*geom*/\n      16 && a !== (a = /*geom*/\n      t[4].points.map(jt).join(\" \"))) && i(s, \"points\", a), $ & /*geom, viewportScale, grab*/\n      536) {\n        p = vt(\n          /*geom*/\n          t[4].points\n        );\n        let x;\n        for (x = 0; x < p.length; x += 1) {\n          const O = Dt(t, p, x);\n          h[x] ? (h[x].p(O, $), F(h[x], 1)) : (h[x] = Xt(O), h[x].c(), F(h[x], 1), h[x].m(l.parentNode, l));\n        }\n        for (Tn(), x = p.length; x < h.length; x += 1)\n          f(x);\n        En();\n      }\n    },\n    i(u) {\n      if (!d) {\n        for (let $ = 0; $ < p.length; $ += 1)\n          F(h[$]);\n        d = !0;\n      }\n    },\n    o(u) {\n      h = h.filter(Boolean);\n      for (let $ = 0; $ < h.length; $ += 1)\n        k(h[$]);\n      d = !1;\n    },\n    d(u) {\n      u && (T(n), T(r), T(s), T(c), T(l)), hn(h, u), g = !1, D(y);\n    }\n  };\n}\nfunction Wn(t) {\n  let n, e;\n  return n = new tn({\n    props: {\n      shape: (\n        /*shape*/\n        t[0]\n      ),\n      transform: (\n        /*transform*/\n        t[2]\n      ),\n      editor: (\n        /*editor*/\n        t[5]\n      ),\n      $$slots: {\n        default: [\n          Rn,\n          ({ grab: o }) => ({ 9: o }),\n          ({ grab: o }) => o ? 512 : 0\n        ]\n      },\n      $$scope: { ctx: t }\n    }\n  }), n.$on(\n    \"change\",\n    /*change_handler*/\n    t[6]\n  ), n.$on(\n    \"grab\",\n    /*grab_handler*/\n    t[7]\n  ), n.$on(\n    \"release\",\n    /*release_handler*/\n    t[8]\n  ), {\n    c() {\n      Q(n.$$.fragment);\n    },\n    m(o, r) {\n      q(n, o, r), e = !0;\n    },\n    p(o, [r]) {\n      const s = {};\n      r & /*shape*/\n      1 && (s.shape = /*shape*/\n      o[0]), r & /*transform*/\n      4 && (s.transform = /*transform*/\n      o[2]), r & /*$$scope, geom, viewportScale, grab, computedStyle*/\n      8730 && (s.$$scope = { dirty: r, ctx: o }), n.$set(s);\n    },\n    i(o) {\n      e || (F(n.$$.fragment, o), e = !0);\n    },\n    o(o) {\n      k(n.$$.fragment, o), e = !1;\n    },\n    d(o) {\n      z(n, o);\n    }\n  };\n}\nconst Bt = (t) => t.join(\",\"), jt = (t) => t.join(\",\");\nfunction vn(t, n, e) {\n  let o, { shape: r } = n, { computedStyle: s } = n, { transform: a } = n, { viewportScale: c = 1 } = n;\n  const l = (p, h, f) => {\n    let u;\n    const $ = p.geometry;\n    h === \"SHAPE\" ? u = $.points.map(([O, E]) => [O + f[0], E + f[1]]) : u = $.points.map(([O, E], I) => h === `HANDLE-${I}` ? [O + f[0], E + f[1]] : [O, E]);\n    const x = Zt(u);\n    return { ...p, geometry: { points: u, bounds: x } };\n  };\n  function d(p) {\n    C.call(this, t, p);\n  }\n  function g(p) {\n    C.call(this, t, p);\n  }\n  function y(p) {\n    C.call(this, t, p);\n  }\n  return t.$$set = (p) => {\n    \"shape\" in p && e(0, r = p.shape), \"computedStyle\" in p && e(1, s = p.computedStyle), \"transform\" in p && e(2, a = p.transform), \"viewportScale\" in p && e(3, c = p.viewportScale);\n  }, t.$$.update = () => {\n    t.$$.dirty & /*shape*/\n    1 && e(4, o = r.geometry);\n  }, [\n    r,\n    s,\n    a,\n    c,\n    o,\n    l,\n    d,\n    g,\n    y\n  ];\n}\nclass Cn extends xt {\n  constructor(n) {\n    super(), $t(this, n, vn, Wn, yt, {\n      shape: 0,\n      computedStyle: 1,\n      transform: 2,\n      viewportScale: 3\n    });\n  }\n}\nconst Dn = \"ontouchstart\" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;\nfunction Xn(t) {\n  let n, e, o, r, s, a;\n  return {\n    c() {\n      n = M(\"rect\"), i(n, \"class\", e = ft(`a9s-handle ${/*$$props*/\n      t[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\"), i(n, \"x\", o = /*x*/\n      t[0] - /*handleSize*/\n      t[5] / 2), i(n, \"y\", r = /*y*/\n      t[1] - /*handleSize*/\n      t[5] / 2), i(\n        n,\n        \"width\",\n        /*handleSize*/\n        t[5]\n      ), i(\n        n,\n        \"height\",\n        /*handleSize*/\n        t[5]\n      );\n    },\n    m(c, l) {\n      S(c, n, l), s || (a = P(\n        n,\n        \"pointerdown\",\n        /*pointerdown_handler_2*/\n        t[11]\n      ), s = !0);\n    },\n    p(c, l) {\n      l & /*$$props*/\n      256 && e !== (e = ft(`a9s-handle ${/*$$props*/\n      c[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\") && i(n, \"class\", e), l & /*x, handleSize*/\n      33 && o !== (o = /*x*/\n      c[0] - /*handleSize*/\n      c[5] / 2) && i(n, \"x\", o), l & /*y, handleSize*/\n      34 && r !== (r = /*y*/\n      c[1] - /*handleSize*/\n      c[5] / 2) && i(n, \"y\", r), l & /*handleSize*/\n      32 && i(\n        n,\n        \"width\",\n        /*handleSize*/\n        c[5]\n      ), l & /*handleSize*/\n      32 && i(\n        n,\n        \"height\",\n        /*handleSize*/\n        c[5]\n      );\n    },\n    d(c) {\n      c && T(n), s = !1, a();\n    }\n  };\n}\nfunction Bn(t) {\n  let n, e, o, r, s, a, c, l, d;\n  return {\n    c() {\n      n = M(\"g\"), e = M(\"circle\"), r = M(\"rect\"), i(\n        e,\n        \"cx\",\n        /*x*/\n        t[0]\n      ), i(\n        e,\n        \"cy\",\n        /*y*/\n        t[1]\n      ), i(e, \"r\", o = /*radius*/\n      t[3] / /*scale*/\n      t[2]), i(e, \"class\", \"a9s-touch-halo svelte-1sgkh33\"), kt(\n        e,\n        \"touched\",\n        /*touched*/\n        t[4]\n      ), i(r, \"class\", s = ft(`a9s-handle ${/*$$props*/\n      t[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\"), i(r, \"x\", a = /*x*/\n      t[0] - /*handleSize*/\n      t[5] / 2), i(r, \"y\", c = /*y*/\n      t[1] - /*handleSize*/\n      t[5] / 2), i(\n        r,\n        \"width\",\n        /*handleSize*/\n        t[5]\n      ), i(\n        r,\n        \"height\",\n        /*handleSize*/\n        t[5]\n      ), i(n, \"class\", \"a9s-touch-handle\");\n    },\n    m(g, y) {\n      S(g, n, y), Ut(n, e), Ut(n, r), l || (d = [\n        P(\n          e,\n          \"pointerdown\",\n          /*pointerdown_handler*/\n          t[10]\n        ),\n        P(\n          e,\n          \"pointerdown\",\n          /*onPointerDown*/\n          t[6]\n        ),\n        P(\n          e,\n          \"pointerup\",\n          /*onPointerUp*/\n          t[7]\n        ),\n        P(\n          r,\n          \"pointerdown\",\n          /*pointerdown_handler_1*/\n          t[9]\n        ),\n        P(\n          r,\n          \"pointerdown\",\n          /*onPointerDown*/\n          t[6]\n        ),\n        P(\n          r,\n          \"pointerup\",\n          /*onPointerUp*/\n          t[7]\n        )\n      ], l = !0);\n    },\n    p(g, y) {\n      y & /*x*/\n      1 && i(\n        e,\n        \"cx\",\n        /*x*/\n        g[0]\n      ), y & /*y*/\n      2 && i(\n        e,\n        \"cy\",\n        /*y*/\n        g[1]\n      ), y & /*radius, scale*/\n      12 && o !== (o = /*radius*/\n      g[3] / /*scale*/\n      g[2]) && i(e, \"r\", o), y & /*touched*/\n      16 && kt(\n        e,\n        \"touched\",\n        /*touched*/\n        g[4]\n      ), y & /*$$props*/\n      256 && s !== (s = ft(`a9s-handle ${/*$$props*/\n      g[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\") && i(r, \"class\", s), y & /*x, handleSize*/\n      33 && a !== (a = /*x*/\n      g[0] - /*handleSize*/\n      g[5] / 2) && i(r, \"x\", a), y & /*y, handleSize*/\n      34 && c !== (c = /*y*/\n      g[1] - /*handleSize*/\n      g[5] / 2) && i(r, \"y\", c), y & /*handleSize*/\n      32 && i(\n        r,\n        \"width\",\n        /*handleSize*/\n        g[5]\n      ), y & /*handleSize*/\n      32 && i(\n        r,\n        \"height\",\n        /*handleSize*/\n        g[5]\n      );\n    },\n    d(g) {\n      g && T(n), l = !1, D(d);\n    }\n  };\n}\nfunction jn(t) {\n  let n;\n  function e(r, s) {\n    return Dn ? Bn : Xn;\n  }\n  let o = e()(t);\n  return {\n    c() {\n      o.c(), n = Qt();\n    },\n    m(r, s) {\n      o.m(r, s), S(r, n, s);\n    },\n    p(r, [s]) {\n      o.p(r, s);\n    },\n    i: rt,\n    o: rt,\n    d(r) {\n      r && T(n), o.d(r);\n    }\n  };\n}\nfunction Vn(t, n, e) {\n  let o, { x: r } = n, { y: s } = n, { scale: a } = n, { radius: c = 30 } = n, l = !1;\n  const d = (f) => {\n    f.pointerType === \"touch\" && e(4, l = !0);\n  }, g = () => e(4, l = !1);\n  function y(f) {\n    C.call(this, t, f);\n  }\n  function p(f) {\n    C.call(this, t, f);\n  }\n  function h(f) {\n    C.call(this, t, f);\n  }\n  return t.$$set = (f) => {\n    e(8, n = Lt(Lt({}, n), Gt(f))), \"x\" in f && e(0, r = f.x), \"y\" in f && e(1, s = f.y), \"scale\" in f && e(2, a = f.scale), \"radius\" in f && e(3, c = f.radius);\n  }, t.$$.update = () => {\n    t.$$.dirty & /*scale*/\n    4 && e(5, o = 10 / a);\n  }, n = Gt(n), [\n    r,\n    s,\n    a,\n    c,\n    l,\n    o,\n    d,\n    g,\n    n,\n    y,\n    p,\n    h\n  ];\n}\nclass et extends xt {\n  constructor(n) {\n    super(), $t(this, n, Vn, jn, yt, { x: 0, y: 1, scale: 2, radius: 3 });\n  }\n}\nfunction qn(t) {\n  let n, e, o, r, s, a, c, l, d, g, y, p, h, f, u, $, x, O, E, I, N, U, W, A, v, J, Z, wt, _, it, at, ct, bt, X, Tt, B, Et, j, St, V, b, Ot, Mt;\n  return X = new et({\n    props: {\n      class: \"a9s-corner-handle-topleft\",\n      x: (\n        /*geom*/\n        t[4].x\n      ),\n      y: (\n        /*geom*/\n        t[4].y\n      ),\n      scale: (\n        /*viewportScale*/\n        t[3]\n      )\n    }\n  }), X.$on(\"pointerdown\", function() {\n    H(\n      /*grab*/\n      t[9](\"TOP_LEFT\")\n    ) && t[9](\"TOP_LEFT\").apply(this, arguments);\n  }), B = new et({\n    props: {\n      class: \"a9s-corner-handle-topright\",\n      x: (\n        /*geom*/\n        t[4].x + /*geom*/\n        t[4].w\n      ),\n      y: (\n        /*geom*/\n        t[4].y\n      ),\n      scale: (\n        /*viewportScale*/\n        t[3]\n      )\n    }\n  }), B.$on(\"pointerdown\", function() {\n    H(\n      /*grab*/\n      t[9](\"TOP_RIGHT\")\n    ) && t[9](\"TOP_RIGHT\").apply(this, arguments);\n  }), j = new et({\n    props: {\n      class: \"a9s-corner-handle-bottomright\",\n      x: (\n        /*geom*/\n        t[4].x + /*geom*/\n        t[4].w\n      ),\n      y: (\n        /*geom*/\n        t[4].y + /*geom*/\n        t[4].h\n      ),\n      scale: (\n        /*viewportScale*/\n        t[3]\n      )\n    }\n  }), j.$on(\"pointerdown\", function() {\n    H(\n      /*grab*/\n      t[9](\"BOTTOM_RIGHT\")\n    ) && t[9](\"BOTTOM_RIGHT\").apply(this, arguments);\n  }), V = new et({\n    props: {\n      class: \"a9s-corner-handle-bottomleft\",\n      x: (\n        /*geom*/\n        t[4].x\n      ),\n      y: (\n        /*geom*/\n        t[4].y + /*geom*/\n        t[4].h\n      ),\n      scale: (\n        /*viewportScale*/\n        t[3]\n      )\n    }\n  }), V.$on(\"pointerdown\", function() {\n    H(\n      /*grab*/\n      t[9](\"BOTTOM_LEFT\")\n    ) && t[9](\"BOTTOM_LEFT\").apply(this, arguments);\n  }), {\n    c() {\n      n = M(\"rect\"), c = G(), l = M(\"rect\"), h = G(), f = M(\"rect\"), O = G(), E = M(\"rect\"), W = G(), A = M(\"rect\"), wt = G(), _ = M(\"rect\"), bt = G(), Q(X.$$.fragment), Tt = G(), Q(B.$$.fragment), Et = G(), Q(j.$$.fragment), St = G(), Q(V.$$.fragment), i(n, \"class\", \"a9s-outer\"), i(n, \"style\", e = /*computedStyle*/\n      t[1] ? \"display:none;\" : void 0), i(n, \"x\", o = /*geom*/\n      t[4].x), i(n, \"y\", r = /*geom*/\n      t[4].y), i(n, \"width\", s = /*geom*/\n      t[4].w), i(n, \"height\", a = /*geom*/\n      t[4].h), i(l, \"class\", \"a9s-inner a9s-shape-handle\"), i(\n        l,\n        \"style\",\n        /*computedStyle*/\n        t[1]\n      ), i(l, \"x\", d = /*geom*/\n      t[4].x), i(l, \"y\", g = /*geom*/\n      t[4].y), i(l, \"width\", y = /*geom*/\n      t[4].w), i(l, \"height\", p = /*geom*/\n      t[4].h), i(f, \"class\", \"a9s-edge-handle a9s-edge-handle-top\"), i(f, \"x\", u = /*geom*/\n      t[4].x), i(f, \"y\", $ = /*geom*/\n      t[4].y), i(f, \"height\", 1), i(f, \"width\", x = /*geom*/\n      t[4].w), i(E, \"class\", \"a9s-edge-handle a9s-edge-handle-right\"), i(E, \"x\", I = /*geom*/\n      t[4].x + /*geom*/\n      t[4].w), i(E, \"y\", N = /*geom*/\n      t[4].y), i(E, \"height\", U = /*geom*/\n      t[4].h), i(E, \"width\", 1), i(A, \"class\", \"a9s-edge-handle a9s-edge-handle-bottom\"), i(A, \"x\", v = /*geom*/\n      t[4].x), i(A, \"y\", J = /*geom*/\n      t[4].y + /*geom*/\n      t[4].h), i(A, \"height\", 1), i(A, \"width\", Z = /*geom*/\n      t[4].w), i(_, \"class\", \"a9s-edge-handle a9s-edge-handle-left\"), i(_, \"x\", it = /*geom*/\n      t[4].x), i(_, \"y\", at = /*geom*/\n      t[4].y), i(_, \"height\", ct = /*geom*/\n      t[4].h), i(_, \"width\", 1);\n    },\n    m(w, m) {\n      S(w, n, m), S(w, c, m), S(w, l, m), S(w, h, m), S(w, f, m), S(w, O, m), S(w, E, m), S(w, W, m), S(w, A, m), S(w, wt, m), S(w, _, m), S(w, bt, m), q(X, w, m), S(w, Tt, m), q(B, w, m), S(w, Et, m), q(j, w, m), S(w, St, m), q(V, w, m), b = !0, Ot || (Mt = [\n        P(n, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"SHAPE\")\n          ) && t[9](\"SHAPE\").apply(this, arguments);\n        }),\n        P(l, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"SHAPE\")\n          ) && t[9](\"SHAPE\").apply(this, arguments);\n        }),\n        P(f, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"TOP\")\n          ) && t[9](\"TOP\").apply(this, arguments);\n        }),\n        P(E, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"RIGHT\")\n          ) && t[9](\"RIGHT\").apply(this, arguments);\n        }),\n        P(A, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"BOTTOM\")\n          ) && t[9](\"BOTTOM\").apply(this, arguments);\n        }),\n        P(_, \"pointerdown\", function() {\n          H(\n            /*grab*/\n            t[9](\"LEFT\")\n          ) && t[9](\"LEFT\").apply(this, arguments);\n        })\n      ], Ot = !0);\n    },\n    p(w, m) {\n      t = w, (!b || m & /*computedStyle*/\n      2 && e !== (e = /*computedStyle*/\n      t[1] ? \"display:none;\" : void 0)) && i(n, \"style\", e), (!b || m & /*geom*/\n      16 && o !== (o = /*geom*/\n      t[4].x)) && i(n, \"x\", o), (!b || m & /*geom*/\n      16 && r !== (r = /*geom*/\n      t[4].y)) && i(n, \"y\", r), (!b || m & /*geom*/\n      16 && s !== (s = /*geom*/\n      t[4].w)) && i(n, \"width\", s), (!b || m & /*geom*/\n      16 && a !== (a = /*geom*/\n      t[4].h)) && i(n, \"height\", a), (!b || m & /*computedStyle*/\n      2) && i(\n        l,\n        \"style\",\n        /*computedStyle*/\n        t[1]\n      ), (!b || m & /*geom*/\n      16 && d !== (d = /*geom*/\n      t[4].x)) && i(l, \"x\", d), (!b || m & /*geom*/\n      16 && g !== (g = /*geom*/\n      t[4].y)) && i(l, \"y\", g), (!b || m & /*geom*/\n      16 && y !== (y = /*geom*/\n      t[4].w)) && i(l, \"width\", y), (!b || m & /*geom*/\n      16 && p !== (p = /*geom*/\n      t[4].h)) && i(l, \"height\", p), (!b || m & /*geom*/\n      16 && u !== (u = /*geom*/\n      t[4].x)) && i(f, \"x\", u), (!b || m & /*geom*/\n      16 && $ !== ($ = /*geom*/\n      t[4].y)) && i(f, \"y\", $), (!b || m & /*geom*/\n      16 && x !== (x = /*geom*/\n      t[4].w)) && i(f, \"width\", x), (!b || m & /*geom*/\n      16 && I !== (I = /*geom*/\n      t[4].x + /*geom*/\n      t[4].w)) && i(E, \"x\", I), (!b || m & /*geom*/\n      16 && N !== (N = /*geom*/\n      t[4].y)) && i(E, \"y\", N), (!b || m & /*geom*/\n      16 && U !== (U = /*geom*/\n      t[4].h)) && i(E, \"height\", U), (!b || m & /*geom*/\n      16 && v !== (v = /*geom*/\n      t[4].x)) && i(A, \"x\", v), (!b || m & /*geom*/\n      16 && J !== (J = /*geom*/\n      t[4].y + /*geom*/\n      t[4].h)) && i(A, \"y\", J), (!b || m & /*geom*/\n      16 && Z !== (Z = /*geom*/\n      t[4].w)) && i(A, \"width\", Z), (!b || m & /*geom*/\n      16 && it !== (it = /*geom*/\n      t[4].x)) && i(_, \"x\", it), (!b || m & /*geom*/\n      16 && at !== (at = /*geom*/\n      t[4].y)) && i(_, \"y\", at), (!b || m & /*geom*/\n      16 && ct !== (ct = /*geom*/\n      t[4].h)) && i(_, \"height\", ct);\n      const lt = {};\n      m & /*geom*/\n      16 && (lt.x = /*geom*/\n      t[4].x), m & /*geom*/\n      16 && (lt.y = /*geom*/\n      t[4].y), m & /*viewportScale*/\n      8 && (lt.scale = /*viewportScale*/\n      t[3]), X.$set(lt);\n      const ut = {};\n      m & /*geom*/\n      16 && (ut.x = /*geom*/\n      t[4].x + /*geom*/\n      t[4].w), m & /*geom*/\n      16 && (ut.y = /*geom*/\n      t[4].y), m & /*viewportScale*/\n      8 && (ut.scale = /*viewportScale*/\n      t[3]), B.$set(ut);\n      const pt = {};\n      m & /*geom*/\n      16 && (pt.x = /*geom*/\n      t[4].x + /*geom*/\n      t[4].w), m & /*geom*/\n      16 && (pt.y = /*geom*/\n      t[4].y + /*geom*/\n      t[4].h), m & /*viewportScale*/\n      8 && (pt.scale = /*viewportScale*/\n      t[3]), j.$set(pt);\n      const dt = {};\n      m & /*geom*/\n      16 && (dt.x = /*geom*/\n      t[4].x), m & /*geom*/\n      16 && (dt.y = /*geom*/\n      t[4].y + /*geom*/\n      t[4].h), m & /*viewportScale*/\n      8 && (dt.scale = /*viewportScale*/\n      t[3]), V.$set(dt);\n    },\n    i(w) {\n      b || (F(X.$$.fragment, w), F(B.$$.fragment, w), F(j.$$.fragment, w), F(V.$$.fragment, w), b = !0);\n    },\n    o(w) {\n      k(X.$$.fragment, w), k(B.$$.fragment, w), k(j.$$.fragment, w), k(V.$$.fragment, w), b = !1;\n    },\n    d(w) {\n      w && (T(n), T(c), T(l), T(h), T(f), T(O), T(E), T(W), T(A), T(wt), T(_), T(bt), T(Tt), T(Et), T(St)), z(X, w), z(B, w), z(j, w), z(V, w), Ot = !1, D(Mt);\n    }\n  };\n}\nfunction zn(t) {\n  let n, e;\n  return n = new tn({\n    props: {\n      shape: (\n        /*shape*/\n        t[0]\n      ),\n      transform: (\n        /*transform*/\n        t[2]\n      ),\n      editor: (\n        /*editor*/\n        t[5]\n      ),\n      $$slots: {\n        default: [\n          qn,\n          ({ grab: o }) => ({ 9: o }),\n          ({ grab: o }) => o ? 512 : 0\n        ]\n      },\n      $$scope: { ctx: t }\n    }\n  }), n.$on(\n    \"grab\",\n    /*grab_handler*/\n    t[6]\n  ), n.$on(\n    \"change\",\n    /*change_handler*/\n    t[7]\n  ), n.$on(\n    \"release\",\n    /*release_handler*/\n    t[8]\n  ), {\n    c() {\n      Q(n.$$.fragment);\n    },\n    m(o, r) {\n      q(n, o, r), e = !0;\n    },\n    p(o, [r]) {\n      const s = {};\n      r & /*shape*/\n      1 && (s.shape = /*shape*/\n      o[0]), r & /*transform*/\n      4 && (s.transform = /*transform*/\n      o[2]), r & /*$$scope, geom, viewportScale, grab, computedStyle*/\n      1562 && (s.$$scope = { dirty: r, ctx: o }), n.$set(s);\n    },\n    i(o) {\n      e || (F(n.$$.fragment, o), e = !0);\n    },\n    o(o) {\n      k(n.$$.fragment, o), e = !1;\n    },\n    d(o) {\n      z(n, o);\n    }\n  };\n}\nfunction Kn(t, n, e) {\n  let o, { shape: r } = n, { computedStyle: s } = n, { transform: a } = n, { viewportScale: c = 1 } = n;\n  const l = (p, h, f) => {\n    const u = p.geometry.bounds;\n    let [$, x] = [u.minX, u.minY], [O, E] = [u.maxX, u.maxY];\n    const [I, N] = f;\n    if (h === \"SHAPE\")\n      $ += I, O += I, x += N, E += N;\n    else {\n      switch (h) {\n        case \"TOP\":\n        case \"TOP_LEFT\":\n        case \"TOP_RIGHT\": {\n          x += N;\n          break;\n        }\n        case \"BOTTOM\":\n        case \"BOTTOM_LEFT\":\n        case \"BOTTOM_RIGHT\": {\n          E += N;\n          break;\n        }\n      }\n      switch (h) {\n        case \"LEFT\":\n        case \"TOP_LEFT\":\n        case \"BOTTOM_LEFT\": {\n          $ += I;\n          break;\n        }\n        case \"RIGHT\":\n        case \"TOP_RIGHT\":\n        case \"BOTTOM_RIGHT\": {\n          O += I;\n          break;\n        }\n      }\n    }\n    const U = Math.min($, O), W = Math.min(x, E), A = Math.abs(O - $), v = Math.abs(E - x);\n    return {\n      ...p,\n      geometry: {\n        x: U,\n        y: W,\n        w: A,\n        h: v,\n        bounds: {\n          minX: U,\n          minY: W,\n          maxX: U + A,\n          maxY: W + v\n        }\n      }\n    };\n  };\n  function d(p) {\n    C.call(this, t, p);\n  }\n  function g(p) {\n    C.call(this, t, p);\n  }\n  function y(p) {\n    C.call(this, t, p);\n  }\n  return t.$$set = (p) => {\n    \"shape\" in p && e(0, r = p.shape), \"computedStyle\" in p && e(1, s = p.computedStyle), \"transform\" in p && e(2, a = p.transform), \"viewportScale\" in p && e(3, c = p.viewportScale);\n  }, t.$$.update = () => {\n    t.$$.dirty & /*shape*/\n    1 && e(4, o = r.geometry);\n  }, [\n    r,\n    s,\n    a,\n    c,\n    o,\n    l,\n    d,\n    g,\n    y\n  ];\n}\nclass Qn extends xt {\n  constructor(n) {\n    super(), $t(this, n, Kn, zn, yt, {\n      shape: 0,\n      computedStyle: 1,\n      transform: 2,\n      viewportScale: 3\n    });\n  }\n}\nR.RECTANGLE, R.POLYGON;\nconst Jn = (t) => ({}), Vt = (t) => ({ grab: (\n  /*onGrab*/\n  t[0]\n) });\nfunction Zn(t) {\n  let n, e, o, r;\n  const s = (\n    /*#slots*/\n    t[7].default\n  ), a = ln(\n    s,\n    t,\n    /*$$scope*/\n    t[6],\n    Vt\n  );\n  return {\n    c() {\n      n = M(\"g\"), a && a.c(), i(n, \"class\", \"a9s-annotation selected\");\n    },\n    m(c, l) {\n      S(c, n, l), a && a.m(n, null), e = !0, o || (r = [\n        P(\n          n,\n          \"pointerup\",\n          /*onRelease*/\n          t[2]\n        ),\n        P(\n          n,\n          \"pointermove\",\n          /*onPointerMove*/\n          t[1]\n        )\n      ], o = !0);\n    },\n    p(c, [l]) {\n      a && a.p && (!e || l & /*$$scope*/\n      64) && pn(\n        a,\n        s,\n        c,\n        /*$$scope*/\n        c[6],\n        e ? un(\n          s,\n          /*$$scope*/\n          c[6],\n          l,\n          Jn\n        ) : dn(\n          /*$$scope*/\n          c[6]\n        ),\n        Vt\n      );\n    },\n    i(c) {\n      e || (F(a, c), e = !0);\n    },\n    o(c) {\n      k(a, c), e = !1;\n    },\n    d(c) {\n      c && T(n), a && a.d(c), o = !1, D(r);\n    }\n  };\n}\nfunction Yn(t, n, e) {\n  let { $$slots: o = {}, $$scope: r } = n;\n  const s = yn();\n  let { shape: a } = n, { editor: c } = n, { transform: l } = n, d, g, y;\n  const p = (u) => ($) => {\n    d = u, g = l.elementToImage($.offsetX, $.offsetY), y = a, $.target.setPointerCapture($.pointerId), s(\"grab\", $);\n  }, h = (u) => {\n    if (d) {\n      const [$, x] = l.elementToImage(u.offsetX, u.offsetY), O = [$ - g[0], x - g[1]];\n      e(3, a = c(y, d, O)), s(\"change\", a);\n    }\n  }, f = (u) => {\n    u.target.releasePointerCapture(u.pointerId), d = void 0, y = a, s(\"release\", u);\n  };\n  return t.$$set = (u) => {\n    \"shape\" in u && e(3, a = u.shape), \"editor\" in u && e(4, c = u.editor), \"transform\" in u && e(5, l = u.transform), \"$$scope\" in u && e(6, r = u.$$scope);\n  }, [p, h, f, a, c, l, r, o];\n}\nclass tn extends xt {\n  constructor(n) {\n    super(), $t(this, n, Yn, Zn, yt, { shape: 3, editor: 4, transform: 5 });\n  }\n}\nnavigator.userAgent.indexOf(\"Mac OS X\");\nconst te = (t) => {\n  const n = [];\n  let e = 1 / 0, o = 0, r = 0, s = 0, a = 0, c = 0;\n  const l = t.querySelectorAll(\"String\");\n  for (const d of l) {\n    const g = d.getAttribute(\"ID\") || gt(), y = d.getAttribute(\"CONTENT\"), p = parseFloat(d.getAttribute(\"HPOS\")), h = parseFloat(d.getAttribute(\"VPOS\")), f = parseFloat(d.getAttribute(\"WIDTH\")), u = parseFloat(d.getAttribute(\"HEIGHT\")), $ = p + f, x = h + u;\n    p < e && (e = p), $ > o && (o = $), r += y.length, s += 1, a += u, c += f, n.push({\n      id: g,\n      bodies: [{\n        id: g,\n        annotation: g,\n        purpose: \"transcribing\",\n        value: y\n      }],\n      target: {\n        annotation: g,\n        selector: {\n          type: R.RECTANGLE,\n          geometry: {\n            bounds: { minX: p, minY: h, maxX: $, maxY: x },\n            x: p,\n            y: h,\n            w: f,\n            h: u\n          }\n        }\n      }\n    });\n  }\n  return {\n    annotations: n,\n    avgWordHeight: a / l.length,\n    avgWordWidth: c / l.length,\n    lineWidth: o - e,\n    numWords: s,\n    numChars: r\n  };\n}, ne = (t) => {\n  const n = [], o = new DOMParser().parseFromString(t, \"application/xml\"), r = o.querySelector(\"Page\"), s = o.querySelectorAll(\"TextLine\");\n  let a = 0, c = 0, l = 0, d = 0, g = 0;\n  for (const N of s) {\n    const {\n      annotations: U,\n      avgWordHeight: W,\n      avgWordWidth: A,\n      lineWidth: v,\n      numWords: J,\n      numChars: Z\n    } = te(N);\n    a += W, c += A, l += v, d += J, g += Z, n.push(...U);\n  }\n  const y = r.getAttribute(\"ID\"), p = parseFloat(r.getAttribute(\"HEIGHT\")), h = parseFloat(r.getAttribute(\"WIDTH\")), f = s.length, { length: u } = s, $ = a / u, x = l / u, O = c / u, E = d / u, I = g / u;\n  return {\n    annotations: n,\n    metadata: {\n      id: y,\n      height: p,\n      width: h,\n      avgLineHeight: $,\n      avgLineWidth: x,\n      avgWordWidth: O,\n      avgWordsPerLine: E,\n      avgCharsPerLine: I,\n      numLines: f\n    }\n  };\n}, ee = (t) => t.reduce(\n  (n, e) => {\n    const { on: o, resource: r } = e;\n    let s;\n    if (o.selector[\"@type\"] === \"oa:FragmentSelector\") {\n      const a = e[\"@id\"];\n      s = {\n        id: a,\n        target: {\n          annotation: a,\n          selector: Hn(o.selector.value)\n        },\n        bodies: [{\n          id: gt(),\n          annotation: a,\n          purpose: \"transcribing\",\n          value: r.chars\n        }]\n      };\n    } else if (o.selector[\"@type\"] === \"oa:SvgSelector\") {\n      const a = Nn(o.selector.value);\n      if (a) {\n        const c = e[\"@id\"] || gt();\n        s = {\n          id: c,\n          target: {\n            annotation: c,\n            selector: {\n              type: a.type,\n              geometry: { ...a.geometry }\n            }\n          },\n          bodies: [{\n            id: gt(),\n            annotation: c,\n            purpose: \"transcribing\",\n            value: r.chars\n          }]\n        };\n      }\n    }\n    return s ? {\n      parsed: [...n.parsed, s],\n      failed: n.failed\n    } : {\n      parsed: n.parsed,\n      failed: [...n.failed, e]\n    };\n  },\n  { parsed: [], failed: [] }\n);\nexport {\n  ne as parseALTO,\n  ee as parseAnnotations\n};\n//# sourceMappingURL=annotorious-formats.es.js.map\n","/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import { contenteditable_truthy_values, has_prop } from './utils.js';\n\nimport { ResizeObserverSingleton } from './ResizeObserverSingleton.js';\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\n\n/**\n * @returns {void}\n */\nexport function start_hydrating() {\n\tis_hydrating = true;\n}\n\n/**\n * @returns {void}\n */\nexport function end_hydrating() {\n\tis_hydrating = false;\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {(index: number) => number} key\n * @param {number} value\n * @returns {number}\n */\nfunction upper_bound(low, high, key, value) {\n\t// Return first index of value larger than input value in the range [low, high)\n\twhile (low < high) {\n\t\tconst mid = low + ((high - low) >> 1);\n\t\tif (key(mid) <= value) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\treturn low;\n}\n\n/**\n * @param {NodeEx} target\n * @returns {void}\n */\nfunction init_hydrate(target) {\n\tif (target.hydrate_init) return;\n\ttarget.hydrate_init = true;\n\t// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n\n\tlet children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);\n\t// If target is <head>, there may be children without claim_order\n\tif (target.nodeName === 'HEAD') {\n\t\tconst my_children = [];\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst node = children[i];\n\t\t\tif (node.claim_order !== undefined) {\n\t\t\t\tmy_children.push(node);\n\t\t\t}\n\t\t}\n\t\tchildren = my_children;\n\t}\n\t/*\n\t * Reorder claimed children optimally.\n\t * We can reorder claimed children optimally by finding the longest subsequence of\n\t * nodes that are already claimed in order and only moving the rest. The longest\n\t * subsequence of nodes that are claimed in order can be found by\n\t * computing the longest increasing subsequence of .claim_order values.\n\t *\n\t * This algorithm is optimal in generating the least amount of reorder operations\n\t * possible.\n\t *\n\t * Proof:\n\t * We know that, given a set of reordering operations, the nodes that do not move\n\t * always form an increasing subsequence, since they do not move among each other\n\t * meaning that they must be already ordered among each other. Thus, the maximal\n\t * set of nodes that do not move form a longest increasing subsequence.\n\t */\n\t// Compute longest increasing subsequence\n\t// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n\tconst m = new Int32Array(children.length + 1);\n\t// Predecessor indices + 1\n\tconst p = new Int32Array(children.length);\n\tm[0] = -1;\n\tlet longest = 0;\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst current = children[i].claim_order;\n\t\t// Find the largest subsequence length such that it ends in a value less than our current value\n\t\t// upper_bound returns first greater value, so we subtract one\n\t\t// with fast path for when we are on the current longest subsequence\n\t\tconst seq_len =\n\t\t\t(longest > 0 && children[m[longest]].claim_order <= current\n\t\t\t\t? longest + 1\n\t\t\t\t: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;\n\t\tp[i] = m[seq_len] + 1;\n\t\tconst new_len = seq_len + 1;\n\t\t// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n\t\tm[new_len] = i;\n\t\tlongest = Math.max(new_len, longest);\n\t}\n\t// The longest increasing subsequence of nodes (initially reversed)\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst lis = [];\n\t// The rest of the nodes, nodes that will be moved\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst to_move = [];\n\tlet last = children.length - 1;\n\tfor (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n\t\tlis.push(children[cur - 1]);\n\t\tfor (; last >= cur; last--) {\n\t\t\tto_move.push(children[last]);\n\t\t}\n\t\tlast--;\n\t}\n\tfor (; last >= 0; last--) {\n\t\tto_move.push(children[last]);\n\t}\n\tlis.reverse();\n\t// We sort the nodes being moved to guarantee that their insertion order matches the claim order\n\tto_move.sort((a, b) => a.claim_order - b.claim_order);\n\t// Finally, we move the nodes\n\tfor (let i = 0, j = 0; i < to_move.length; i++) {\n\t\twhile (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\n\t\t\tj++;\n\t\t}\n\t\tconst anchor = j < lis.length ? lis[j] : null;\n\t\ttarget.insertBefore(to_move[i], anchor);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nexport function append(target, node) {\n\ttarget.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n * @returns {void}\n */\nexport function append_styles(target, style_sheet_id, styles) {\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tappend_stylesheet(append_styles_to, style);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {ShadowRoot | Document}\n */\nexport function get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn node.ownerDocument;\n}\n\n/**\n * @param {Node} node\n * @returns {CSSStyleSheet}\n */\nexport function append_empty_stylesheet(node) {\n\tconst style_element = element('style');\n\t// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\n\t// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\n\t// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\n\t// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\n\t// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\n\tstyle_element.textContent = '/* empty */';\n\tappend_stylesheet(get_root_for_style(node), style_element);\n\treturn style_element.sheet;\n}\n\n/**\n * @param {ShadowRoot | Document} node\n * @param {HTMLStyleElement} style\n * @returns {CSSStyleSheet}\n */\nfunction append_stylesheet(node, style) {\n\tappend(/** @type {Document} */ (node).head || node, style);\n\treturn style.sheet;\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @returns {void}\n */\nexport function append_hydration(target, node) {\n\tif (is_hydrating) {\n\t\tinit_hydrate(target);\n\t\tif (\n\t\t\ttarget.actual_end_child === undefined ||\n\t\t\t(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)\n\t\t) {\n\t\t\ttarget.actual_end_child = target.firstChild;\n\t\t}\n\t\t// Skip nodes of undefined ordering\n\t\twhile (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\n\t\t\ttarget.actual_end_child = target.actual_end_child.nextSibling;\n\t\t}\n\t\tif (node !== target.actual_end_child) {\n\t\t\t// We only insert if the ordering of this node should be modified or the parent node is not target\n\t\t\tif (node.claim_order !== undefined || node.parentNode !== target) {\n\t\t\t\ttarget.insertBefore(node, target.actual_end_child);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.actual_end_child = node.nextSibling;\n\t\t}\n\t} else if (node.parentNode !== target || node.nextSibling !== null) {\n\t\ttarget.appendChild(node);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nexport function insert(target, node, anchor) {\n\ttarget.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @param {NodeEx} [anchor]\n * @returns {void}\n */\nexport function insert_hydration(target, node, anchor) {\n\tif (is_hydrating && !anchor) {\n\t\tappend_hydration(target, node);\n\t} else if (node.parentNode !== target || node.nextSibling != anchor) {\n\t\ttarget.insertBefore(node, anchor || null);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nexport function detach(node) {\n\tif (node.parentNode) {\n\t\tnode.parentNode.removeChild(node);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function destroy_each(iterations, detaching) {\n\tfor (let i = 0; i < iterations.length; i += 1) {\n\t\tif (iterations[i]) iterations[i].d(detaching);\n\t}\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element(name) {\n\treturn document.createElement(name);\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @param {string} is\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element_is(name, is) {\n\treturn document.createElement(name, { is });\n}\n\n/**\n * @template T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K[]} exclude\n * @returns {Pick<T, Exclude<keyof T, K>>}\n */\nexport function object_without_properties(obj, exclude) {\n\tconst target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});\n\tfor (const k in obj) {\n\t\tif (\n\t\t\thas_prop(obj, k) &&\n\t\t\t// @ts-ignore\n\t\t\texclude.indexOf(k) === -1\n\t\t) {\n\t\t\t// @ts-ignore\n\t\t\ttarget[k] = obj[k];\n\t\t}\n\t}\n\treturn target;\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nexport function svg_element(name) {\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nexport function text(data) {\n\treturn document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nexport function space() {\n\treturn text(' ');\n}\n\n/**\n * @returns {Text} */\nexport function empty() {\n\treturn text('');\n}\n\n/**\n * @param {string} content\n * @returns {Comment}\n */\nexport function comment(content) {\n\treturn document.createComment(content);\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nexport function listen(node, event, handler, options) {\n\tnode.addEventListener(event, handler, options);\n\treturn () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function prevent_default(fn) {\n\treturn function (event) {\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_immediate_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function self(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.target === this) fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function trusted(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.isTrusted) fn.call(this, event);\n\t};\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nexport function attr(node, attribute, value) {\n\tif (value == null) node.removeAttribute(attribute);\n\telse if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_attributes(node, attributes) {\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\tfor (const key in attributes) {\n\t\tif (attributes[key] == null) {\n\t\t\tnode.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\tnode.style.cssText = attributes[key];\n\t\t} else if (key === '__value') {\n\t\t\t/** @type {any} */ (node).value = node[key] = attributes[key];\n\t\t} else if (\n\t\t\tdescriptors[key] &&\n\t\t\tdescriptors[key].set &&\n\t\t\talways_set_through_set_attribute.indexOf(key) === -1\n\t\t) {\n\t\t\tnode[key] = attributes[key];\n\t\t} else {\n\t\t\tattr(node, key, attributes[key]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_svg_attributes(node, attributes) {\n\tfor (const key in attributes) {\n\t\tattr(node, key, attributes[key]);\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} data_map\n * @returns {void}\n */\nexport function set_custom_element_data_map(node, data_map) {\n\tObject.keys(data_map).forEach((key) => {\n\t\tset_custom_element_data(node, key, data_map[key]);\n\t});\n}\n\n/**\n * @returns {void} */\nexport function set_custom_element_data(node, prop, value) {\n\tconst lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first\n\tif (lower in node) {\n\t\tnode[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;\n\t} else if (prop in node) {\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n\t} else {\n\t\tattr(node, prop, value);\n\t}\n}\n\n/**\n * @param {string} tag\n */\nexport function set_dynamic_element_data(tag) {\n\treturn /-/.test(tag) ? set_custom_element_data_map : set_attributes;\n}\n\n/**\n * @returns {void}\n */\nexport function xlink_attr(node, attribute, value) {\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @returns {string}\n */\nexport function get_svelte_dataset(node) {\n\treturn node.dataset.svelteH;\n}\n\n/**\n * @returns {unknown[]} */\nexport function get_binding_group_value(group, __value, checked) {\n\tconst value = new Set();\n\tfor (let i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) value.add(group[i].__value);\n\t}\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement[]} group\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\n */\nexport function init_binding_group(group) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\treturn {\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\t_inputs.forEach((input) => group.push(input));\n\t\t},\n\t\t/* remove */ r() {\n\t\t\t_inputs.forEach((input) => group.splice(group.indexOf(input), 1));\n\t\t}\n\t};\n}\n\n/**\n * @param {number[]} indexes\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\n */\nexport function init_binding_group_dynamic(group, indexes) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _group = get_binding_group(group);\n\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\n\tfunction get_binding_group(group) {\n\t\tfor (let i = 0; i < indexes.length; i++) {\n\t\t\tgroup = group[indexes[i]] = group[indexes[i]] || [];\n\t\t}\n\t\treturn group;\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction push() {\n\t\t_inputs.forEach((input) => _group.push(input));\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction remove() {\n\t\t_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));\n\t}\n\treturn {\n\t\t/* update */ u(new_indexes) {\n\t\t\tindexes = new_indexes;\n\t\t\tconst new_group = get_binding_group(group);\n\t\t\tif (new_group !== _group) {\n\t\t\t\tremove();\n\t\t\t\t_group = new_group;\n\t\t\t\tpush();\n\t\t\t}\n\t\t},\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\tpush();\n\t\t},\n\t\t/* remove */ r: remove\n\t};\n}\n\n/** @returns {number} */\nexport function to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/** @returns {any[]} */\nexport function time_ranges_to_array(ranges) {\n\tconst array = [];\n\tfor (let i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nexport function children(element) {\n\treturn Array.from(element.childNodes);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {void}\n */\nfunction init_claim_info(nodes) {\n\tif (nodes.claim_info === undefined) {\n\t\tnodes.claim_info = { last_index: 0, total_claimed: 0 };\n\t}\n}\n\n/**\n * @template {ChildNodeEx} R\n * @param {ChildNodeArray} nodes\n * @param {(node: ChildNodeEx) => node is R} predicate\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\n * @param {() => R} create_node\n * @param {boolean} dont_update_last_index\n * @returns {R}\n */\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\n\t// Try to find nodes in an order such that we lengthen the longest increasing subsequence\n\tinit_claim_info(nodes);\n\tconst result_node = (() => {\n\t\t// We first try to find an element after the previous one\n\t\tfor (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// Otherwise, we try to find one before\n\t\t// We iterate in reverse so that we don't go too far back\n\t\tfor (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t} else if (replacement === undefined) {\n\t\t\t\t\t// Since we spliced before the last_index, we decrease it\n\t\t\t\t\tnodes.claim_info.last_index--;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// If we can't find any matching node, we create a new one\n\t\treturn create_node();\n\t})();\n\tresult_node.claim_order = nodes.claim_info.total_claimed;\n\tnodes.claim_info.total_claimed += 1;\n\treturn result_node;\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @param {(name: string) => Element | SVGElement} create_element\n * @returns {Element | SVGElement}\n */\nfunction claim_element_base(nodes, name, attributes, create_element) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Element | SVGElement} */\n\t\t(node) => node.nodeName === name,\n\t\t/** @param {Element} node */\n\t\t(node) => {\n\t\t\tconst remove = [];\n\t\t\tfor (let j = 0; j < node.attributes.length; j++) {\n\t\t\t\tconst attribute = node.attributes[j];\n\t\t\t\tif (!attributes[attribute.name]) {\n\t\t\t\t\tremove.push(attribute.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove.forEach((v) => node.removeAttribute(v));\n\t\t\treturn undefined;\n\t\t},\n\t\t() => create_element(name)\n\t);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_svg_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, svg_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Text}\n */\nexport function claim_text(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Text} */\n\t\t(node) => node.nodeType === 3,\n\t\t/** @param {Text} node */\n\t\t(node) => {\n\t\t\tconst data_str = '' + data;\n\t\t\tif (node.data.startsWith(data_str)) {\n\t\t\t\tif (node.data.length !== data_str.length) {\n\t\t\t\t\treturn node.splitText(data_str.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.data = data_str;\n\t\t\t}\n\t\t},\n\t\t() => text(data),\n\t\ttrue // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n\t);\n}\n\n/**\n * @returns {Text} */\nexport function claim_space(nodes) {\n\treturn claim_text(nodes, ' ');\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Comment}\n */\nexport function claim_comment(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Comment} */\n\t\t(node) => node.nodeType === 8,\n\t\t/** @param {Comment} node */\n\t\t(node) => {\n\t\t\tnode.data = '' + data;\n\t\t\treturn undefined;\n\t\t},\n\t\t() => comment(data),\n\t\ttrue\n\t);\n}\n\nfunction get_comment_idx(nodes, text, start) {\n\tfor (let i = start; i < nodes.length; i += 1) {\n\t\tconst node = nodes[i];\n\t\tif (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * @param {boolean} is_svg\n * @returns {HtmlTagHydration}\n */\nexport function claim_html_tag(nodes, is_svg) {\n\t// find html opening tag\n\tconst start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\n\tconst end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\n\tif (start_index === -1 || end_index === -1) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\n\tinit_claim_info(nodes);\n\tconst html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n\tdetach(html_tag_nodes[0]);\n\tdetach(html_tag_nodes[html_tag_nodes.length - 1]);\n\tconst claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n\tif (claimed_nodes.length === 0) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\tfor (const n of claimed_nodes) {\n\t\tn.claim_order = nodes.claim_info.total_claimed;\n\t\tnodes.claim_info.total_claimed += 1;\n\t}\n\treturn new HtmlTagHydration(is_svg, claimed_nodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data(text, data) {\n\tdata = '' + data;\n\tif (text.data === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data_contenteditable(text, data) {\n\tdata = '' + data;\n\tif (text.wholeText === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nexport function set_data_maybe_contenteditable(text, data, attr_value) {\n\tif (~contenteditable_truthy_values.indexOf(attr_value)) {\n\t\tset_data_contenteditable(text, data);\n\t} else {\n\t\tset_data(text, data);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_input_value(input, value) {\n\tinput.value = value == null ? '' : value;\n}\n\n/**\n * @returns {void} */\nexport function set_input_type(input, type) {\n\ttry {\n\t\tinput.type = type;\n\t} catch (e) {\n\t\t// do nothing\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_style(node, key, value, important) {\n\tif (value == null) {\n\t\tnode.style.removeProperty(key);\n\t} else {\n\t\tnode.style.setProperty(key, value, important ? 'important' : '');\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_option(select, value, mounting) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\tif (option.__value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_options(select, value) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\toption.selected = ~value.indexOf(option.__value);\n\t}\n}\n\nexport function select_value(select) {\n\tconst selected_option = select.querySelector(':checked');\n\treturn selected_option && selected_option.__value;\n}\n\nexport function select_multiple_value(select) {\n\treturn [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nexport function is_crossorigin() {\n\tif (crossorigin === undefined) {\n\t\tcrossorigin = false;\n\t\ttry {\n\t\t\tif (typeof window !== 'undefined' && window.parent) {\n\t\t\t\tvoid window.parent.document;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tcrossorigin = true;\n\t\t}\n\t}\n\treturn crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nexport function add_iframe_resize_listener(node, fn) {\n\tconst computed_style = getComputedStyle(node);\n\tif (computed_style.position === 'static') {\n\t\tnode.style.position = 'relative';\n\t}\n\tconst iframe = element('iframe');\n\tiframe.setAttribute(\n\t\t'style',\n\t\t'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n\t\t\t'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'\n\t);\n\tiframe.setAttribute('aria-hidden', 'true');\n\tiframe.tabIndex = -1;\n\tconst crossorigin = is_crossorigin();\n\n\t/**\n\t * @type {() => void}\n\t */\n\tlet unsubscribe;\n\tif (crossorigin) {\n\t\tiframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n\t\tunsubscribe = listen(\n\t\t\twindow,\n\t\t\t'message',\n\t\t\t/** @param {MessageEvent} event */ (event) => {\n\t\t\t\tif (event.source === iframe.contentWindow) fn();\n\t\t\t}\n\t\t);\n\t} else {\n\t\tiframe.src = 'about:blank';\n\t\tiframe.onload = () => {\n\t\t\tunsubscribe = listen(iframe.contentWindow, 'resize', fn);\n\t\t\t// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n\t\t\t// see https://github.com/sveltejs/svelte/issues/4233\n\t\t\tfn();\n\t\t};\n\t}\n\tappend(node, iframe);\n\treturn () => {\n\t\tif (crossorigin) {\n\t\t\tunsubscribe();\n\t\t} else if (unsubscribe && iframe.contentWindow) {\n\t\t\tunsubscribe();\n\t\t}\n\t\tdetach(iframe);\n\t};\n}\nexport const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box'\n});\nexport const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box'\n});\nexport const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(\n\t{ box: 'device-pixel-content-box' }\n);\nexport { ResizeObserverSingleton };\n\n/**\n * @returns {void} */\nexport function toggle_class(element, name, toggle) {\n\t// The `!!` is required because an `undefined` flag means flipping the current state.\n\telement.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nexport function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * @param {string} selector\n * @param {HTMLElement} parent\n * @returns {ChildNodeArray}\n */\nexport function query_selector_all(selector, parent = document.body) {\n\treturn Array.from(parent.querySelectorAll(selector));\n}\n\n/**\n * @param {string} nodeId\n * @param {HTMLElement} head\n * @returns {any[]}\n */\nexport function head_selector(nodeId, head) {\n\tconst result = [];\n\tlet started = 0;\n\tfor (const node of head.childNodes) {\n\t\tif (node.nodeType === 8 /* comment node */) {\n\t\t\tconst comment = node.textContent.trim();\n\t\t\tif (comment === `HEAD_${nodeId}_END`) {\n\t\t\t\tstarted -= 1;\n\t\t\t\tresult.push(node);\n\t\t\t} else if (comment === `HEAD_${nodeId}_START`) {\n\t\t\t\tstarted += 1;\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t} else if (started > 0) {\n\t\t\tresult.push(node);\n\t\t}\n\t}\n\treturn result;\n}\n/** */\nexport class HtmlTag {\n\t/**\n\t * @private\n\t * @default false\n\t */\n\tis_svg = false;\n\t/** parent for creating node */\n\te = undefined;\n\t/** html tag nodes */\n\tn = undefined;\n\t/** target */\n\tt = undefined;\n\t/** anchor */\n\ta = undefined;\n\tconstructor(is_svg = false) {\n\t\tthis.is_svg = is_svg;\n\t\tthis.e = this.n = null;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tthis.h(html);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @param {HTMLElement | SVGElement} target\n\t * @param {HTMLElement | SVGElement} anchor\n\t * @returns {void}\n\t */\n\tm(html, target, anchor = null) {\n\t\tif (!this.e) {\n\t\t\tif (this.is_svg)\n\t\t\t\tthis.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));\n\t\t\t/** #7364  target for <template> may be provided as #document-fragment(11) */ else\n\t\t\t\tthis.e = element(\n\t\t\t\t\t/** @type {keyof HTMLElementTagNameMap} */ (\n\t\t\t\t\t\ttarget.nodeType === 11 ? 'TEMPLATE' : target.nodeName\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tthis.t =\n\t\t\t\ttarget.tagName !== 'TEMPLATE'\n\t\t\t\t\t? target\n\t\t\t\t\t: /** @type {HTMLTemplateElement} */ (target).content;\n\t\t\tthis.c(html);\n\t\t}\n\t\tthis.i(anchor);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\th(html) {\n\t\tthis.e.innerHTML = html;\n\t\tthis.n = Array.from(\n\t\t\tthis.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert(this.t, this.n[i], anchor);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tp(html) {\n\t\tthis.d();\n\t\tthis.h(html);\n\t\tthis.i(this.a);\n\t}\n\n\t/**\n\t * @returns {void} */\n\td() {\n\t\tthis.n.forEach(detach);\n\t}\n}\n\nexport class HtmlTagHydration extends HtmlTag {\n\t/** @type {Element[]} hydration claimed nodes */\n\tl = undefined;\n\n\tconstructor(is_svg = false, claimed_nodes) {\n\t\tsuper(is_svg);\n\t\tthis.e = this.n = null;\n\t\tthis.l = claimed_nodes;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tif (this.l) {\n\t\t\tthis.n = this.l;\n\t\t} else {\n\t\t\tsuper.c(html);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert_hydration(this.t, this.n[i], anchor);\n\t\t}\n\t}\n}\n\n/**\n * @param {NamedNodeMap} attributes\n * @returns {{}}\n */\nexport function attribute_to_object(attributes) {\n\tconst result = {};\n\tfor (const attribute of attributes) {\n\t\tresult[attribute.name] = attribute.value;\n\t}\n\treturn result;\n}\n\nconst escaped = {\n\t'\"': '&quot;',\n\t'&': '&amp;',\n\t'<': '&lt;'\n};\n\nconst regex_attribute_characters_to_escape = /[\"&<]/g;\n\n/**\n * Note that the attribute itself should be surrounded in double quotes\n * @param {any} attribute\n */\nfunction escape_attribute(attribute) {\n\treturn String(attribute).replace(regex_attribute_characters_to_escape, (match) => escaped[match]);\n}\n\n/**\n * @param {Record<string, string>} attributes\n */\nexport function stringify_spread(attributes) {\n\tlet str = ' ';\n\tfor (const key in attributes) {\n\t\tif (attributes[key] != null) {\n\t\t\tstr += `${key}=\"${escape_attribute(attributes[key])}\" `;\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {{}}\n */\nexport function get_custom_elements_slots(element) {\n\tconst result = {};\n\telement.childNodes.forEach(\n\t\t/** @param {Element} node */ (node) => {\n\t\t\tresult[node.slot || 'default'] = true;\n\t\t}\n\t);\n\treturn result;\n}\n\nexport function construct_svelte_component(component, props) {\n\treturn new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n","import { custom_event } from './dom.js';\n\nexport let current_component;\n\n/** @returns {void} */\nexport function set_current_component(component) {\n\tcurrent_component = component;\n}\n\nexport function get_current_component() {\n\tif (!current_component) throw new Error('Function called outside component initialization');\n\treturn current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tget_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tget_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tget_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tget_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component = get_current_component();\n\treturn (type, detail, { cancelable = false } = {}) => {\n\t\tconst callbacks = component.$$.callbacks[type];\n\t\tif (callbacks) {\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = custom_event(/** @type {string} */ (type), detail, { cancelable });\n\t\t\tcallbacks.slice().forEach((fn) => {\n\t\t\t\tfn.call(component, event);\n\t\t\t});\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_current_component().$$.context.set(key, context);\n\treturn context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\treturn get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\treturn get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nexport function bubble(component, event) {\n\tconst callbacks = component.$$.callbacks[event.type];\n\tif (callbacks) {\n\t\t// @ts-ignore\n\t\tcallbacks.slice().forEach((fn) => fn.call(this, event));\n\t}\n}\n","import { run_all } from './utils.js';\nimport { current_component, set_current_component } from './lifecycle.js';\n\nexport const dirty_components = [];\nexport const intros = { enabled: false };\nexport const binding_callbacks = [];\n\nlet render_callbacks = [];\n\nconst flush_callbacks = [];\n\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\n\nlet update_scheduled = false;\n\n/** @returns {void} */\nexport function schedule_update() {\n\tif (!update_scheduled) {\n\t\tupdate_scheduled = true;\n\t\tresolved_promise.then(flush);\n\t}\n}\n\n/** @returns {Promise<void>} */\nexport function tick() {\n\tschedule_update();\n\treturn resolved_promise;\n}\n\n/** @returns {void} */\nexport function add_render_callback(fn) {\n\trender_callbacks.push(fn);\n}\n\n/** @returns {void} */\nexport function add_flush_callback(fn) {\n\tflush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\n\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nexport function flush() {\n\t// Do not reenter flush while dirty components are updated, as this can\n\t// result in an infinite loop. Instead, let the inner flush handle it.\n\t// Reentrancy is ok afterwards for bindings etc.\n\tif (flushidx !== 0) {\n\t\treturn;\n\t}\n\tconst saved_component = current_component;\n\tdo {\n\t\t// first, call beforeUpdate functions\n\t\t// and update components\n\t\ttry {\n\t\t\twhile (flushidx < dirty_components.length) {\n\t\t\t\tconst component = dirty_components[flushidx];\n\t\t\t\tflushidx++;\n\t\t\t\tset_current_component(component);\n\t\t\t\tupdate(component.$$);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// reset dirty state to not end up in a deadlocked state and then rethrow\n\t\t\tdirty_components.length = 0;\n\t\t\tflushidx = 0;\n\t\t\tthrow e;\n\t\t}\n\t\tset_current_component(null);\n\t\tdirty_components.length = 0;\n\t\tflushidx = 0;\n\t\twhile (binding_callbacks.length) binding_callbacks.pop()();\n\t\t// then, once components are updated, call\n\t\t// afterUpdate functions. This may cause\n\t\t// subsequent updates...\n\t\tfor (let i = 0; i < render_callbacks.length; i += 1) {\n\t\t\tconst callback = render_callbacks[i];\n\t\t\tif (!seen_callbacks.has(callback)) {\n\t\t\t\t// ...so guard against infinite loops\n\t\t\t\tseen_callbacks.add(callback);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t\trender_callbacks.length = 0;\n\t} while (dirty_components.length);\n\twhile (flush_callbacks.length) {\n\t\tflush_callbacks.pop()();\n\t}\n\tupdate_scheduled = false;\n\tseen_callbacks.clear();\n\tset_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n\tif ($$.fragment !== null) {\n\t\t$$.update();\n\t\trun_all($$.before_update);\n\t\tconst dirty = $$.dirty;\n\t\t$$.dirty = [-1];\n\t\t$$.fragment && $$.fragment.p($$.ctx, dirty);\n\t\t$$.after_update.forEach(add_render_callback);\n\t}\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function flush_render_callbacks(fns) {\n\tconst filtered = [];\n\tconst targets = [];\n\trender_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));\n\ttargets.forEach((c) => c());\n\trender_callbacks = filtered;\n}\n","import { identity as linear, is_function, noop, run_all } from './utils.js';\nimport { now } from './environment.js';\nimport { loop } from './loop.js';\nimport { create_rule, delete_rule } from './style_manager.js';\nimport { custom_event } from './dom.js';\nimport { add_render_callback } from './scheduler.js';\n\n/**\n * @type {Promise<void> | null}\n */\nlet promise;\n\n/**\n * @returns {Promise<void>}\n */\nfunction wait() {\n\tif (!promise) {\n\t\tpromise = Promise.resolve();\n\t\tpromise.then(() => {\n\t\t\tpromise = null;\n\t\t});\n\t}\n\treturn promise;\n}\n\n/**\n * @param {Element} node\n * @param {INTRO | OUTRO | boolean} direction\n * @param {'start' | 'end'} kind\n * @returns {void}\n */\nfunction dispatch(node, direction, kind) {\n\tnode.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\n\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nexport function group_outros() {\n\toutros = {\n\t\tr: 0,\n\t\tc: [],\n\t\tp: outros // parent group\n\t};\n}\n\n/**\n * @returns {void} */\nexport function check_outros() {\n\tif (!outros.r) {\n\t\trun_all(outros.c);\n\t}\n\toutros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nexport function transition_in(block, local) {\n\tif (block && block.i) {\n\t\toutroing.delete(block);\n\t\tblock.i(local);\n\t}\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nexport function transition_out(block, local, detach, callback) {\n\tif (block && block.o) {\n\t\tif (outroing.has(block)) return;\n\t\toutroing.add(block);\n\t\toutros.c.push(() => {\n\t\t\toutroing.delete(block);\n\t\t\tif (callback) {\n\t\t\t\tif (detach) block.d(1);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\tblock.o(local);\n\t} else if (callback) {\n\t\tcallback();\n\t}\n}\n\n/**\n * @type {import('../transition/public.js').TransitionConfig}\n */\nconst null_transition = { duration: 0 };\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\n */\nexport function create_in_transition(node, fn, params) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'in' };\n\tlet config = fn(node, params, options);\n\tlet running = false;\n\tlet animation_name;\n\tlet task;\n\tlet uid = 0;\n\n\t/**\n\t * @returns {void} */\n\tfunction cleanup() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\t\tif (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n\t\ttick(0, 1);\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tif (task) task.abort();\n\t\trunning = true;\n\t\tadd_render_callback(() => dispatch(node, true, 'start'));\n\t\ttask = loop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(1, 0);\n\t\t\t\t\tdispatch(node, true, 'end');\n\t\t\t\t\tcleanup();\n\t\t\t\t\treturn (running = false);\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\tlet started = false;\n\treturn {\n\t\tstart() {\n\t\t\tif (started) return;\n\t\t\tstarted = true;\n\t\t\tdelete_rule(node);\n\t\t\tif (is_function(config)) {\n\t\t\t\tconfig = config(options);\n\t\t\t\twait().then(go);\n\t\t\t} else {\n\t\t\t\tgo();\n\t\t\t}\n\t\t},\n\t\tinvalidate() {\n\t\t\tstarted = false;\n\t\t},\n\t\tend() {\n\t\t\tif (running) {\n\t\t\t\tcleanup();\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ end(reset: any): void; }}\n */\nexport function create_out_transition(node, fn, params) {\n\t/** @type {TransitionOptions} */\n\tconst options = { direction: 'out' };\n\tlet config = fn(node, params, options);\n\tlet running = true;\n\tlet animation_name;\n\tconst group = outros;\n\tgroup.r += 1;\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\tif (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tadd_render_callback(() => dispatch(node, false, 'start'));\n\n\t\tif ('inert' in node) {\n\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\tnode.inert = true;\n\t\t}\n\n\t\tloop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(0, 1);\n\t\t\t\t\tdispatch(node, false, 'end');\n\t\t\t\t\tif (!--group.r) {\n\t\t\t\t\t\t// this will result in `end()` being called,\n\t\t\t\t\t\t// so we don't need to clean up here\n\t\t\t\t\t\trun_all(group.c);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(1 - t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\n\tif (is_function(config)) {\n\t\twait().then(() => {\n\t\t\t// @ts-ignore\n\t\t\tconfig = config(options);\n\t\t\tgo();\n\t\t});\n\t} else {\n\t\tgo();\n\t}\n\n\treturn {\n\t\tend(reset) {\n\t\t\tif (reset && 'inert' in node) {\n\t\t\t\tnode.inert = original_inert_value;\n\t\t\t}\n\t\t\tif (reset && config.tick) {\n\t\t\t\tconfig.tick(1, 0);\n\t\t\t}\n\t\t\tif (running) {\n\t\t\t\tif (animation_name) delete_rule(node, animation_name);\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @param {boolean} intro\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\n */\nexport function create_bidirectional_transition(node, fn, params, intro) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'both' };\n\tlet config = fn(node, params, options);\n\tlet t = intro ? 0 : 1;\n\n\t/**\n\t * @type {Program | null} */\n\tlet running_program = null;\n\n\t/**\n\t * @type {PendingProgram | null} */\n\tlet pending_program = null;\n\tlet animation_name = null;\n\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction clear_animation() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @param {PendingProgram} program\n\t * @param {number} duration\n\t * @returns {Program}\n\t */\n\tfunction init(program, duration) {\n\t\tconst d = /** @type {Program['d']} */ (program.b - t);\n\t\tduration *= Math.abs(d);\n\t\treturn {\n\t\t\ta: t,\n\t\t\tb: program.b,\n\t\t\td,\n\t\t\tduration,\n\t\t\tstart: program.start,\n\t\t\tend: program.start + duration,\n\t\t\tgroup: program.group\n\t\t};\n\t}\n\n\t/**\n\t * @param {INTRO | OUTRO} b\n\t * @returns {void}\n\t */\n\tfunction go(b) {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\t/**\n\t\t * @type {PendingProgram} */\n\t\tconst program = {\n\t\t\tstart: now() + delay,\n\t\t\tb\n\t\t};\n\n\t\tif (!b) {\n\t\t\t// @ts-ignore todo: improve typings\n\t\t\tprogram.group = outros;\n\t\t\toutros.r += 1;\n\t\t}\n\n\t\tif ('inert' in node) {\n\t\t\tif (b) {\n\t\t\t\tif (original_inert_value !== undefined) {\n\t\t\t\t\t// aborted/reversed outro  restore previous inert value\n\t\t\t\t\tnode.inert = original_inert_value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\t\tnode.inert = true;\n\t\t\t}\n\t\t}\n\n\t\tif (running_program || pending_program) {\n\t\t\tpending_program = program;\n\t\t} else {\n\t\t\t// if this is an intro, and there's a delay, we need to do\n\t\t\t// an initial tick and/or apply CSS animation immediately\n\t\t\tif (css) {\n\t\t\t\tclear_animation();\n\t\t\t\tanimation_name = create_rule(node, t, b, duration, delay, easing, css);\n\t\t\t}\n\t\t\tif (b) tick(0, 1);\n\t\t\trunning_program = init(program, duration);\n\t\t\tadd_render_callback(() => dispatch(node, b, 'start'));\n\t\t\tloop((now) => {\n\t\t\t\tif (pending_program && now > pending_program.start) {\n\t\t\t\t\trunning_program = init(pending_program, duration);\n\t\t\t\t\tpending_program = null;\n\t\t\t\t\tdispatch(node, running_program.b, 'start');\n\t\t\t\t\tif (css) {\n\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\tanimation_name = create_rule(\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tt,\n\t\t\t\t\t\t\trunning_program.b,\n\t\t\t\t\t\t\trunning_program.duration,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\teasing,\n\t\t\t\t\t\t\tconfig.css\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (running_program) {\n\t\t\t\t\tif (now >= running_program.end) {\n\t\t\t\t\t\ttick((t = running_program.b), 1 - t);\n\t\t\t\t\t\tdispatch(node, running_program.b, 'end');\n\t\t\t\t\t\tif (!pending_program) {\n\t\t\t\t\t\t\t// we're done\n\t\t\t\t\t\t\tif (running_program.b) {\n\t\t\t\t\t\t\t\t// intro  we can tidy up immediately\n\t\t\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// outro  needs to be coordinated\n\t\t\t\t\t\t\t\tif (!--running_program.group.r) run_all(running_program.group.c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trunning_program = null;\n\t\t\t\t\t} else if (now >= running_program.start) {\n\t\t\t\t\t\tconst p = now - running_program.start;\n\t\t\t\t\t\tt = running_program.a + running_program.d * easing(p / running_program.duration);\n\t\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!(running_program || pending_program);\n\t\t\t});\n\t\t}\n\t}\n\treturn {\n\t\trun(b) {\n\t\t\tif (is_function(config)) {\n\t\t\t\twait().then(() => {\n\t\t\t\t\tconst opts = { direction: b ? 'in' : 'out' };\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconfig = config(opts);\n\t\t\t\t\tgo(b);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tgo(b);\n\t\t\t}\n\t\t},\n\t\tend() {\n\t\t\tclear_animation();\n\t\t\trunning_program = pending_program = null;\n\t\t}\n\t};\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n","import { transition_in, transition_out } from './transitions.js';\nimport { run_all } from './utils.js';\n\n// general each functions:\n\nexport function ensure_array_like(array_like_or_iterator) {\n\treturn array_like_or_iterator?.length !== undefined\n\t\t? array_like_or_iterator\n\t\t: Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nexport function destroy_block(block, lookup) {\n\tblock.d(1);\n\tlookup.delete(block.key);\n}\n\n/** @returns {void} */\nexport function outro_and_destroy_block(block, lookup) {\n\ttransition_out(block, 1, 1, () => {\n\t\tlookup.delete(block.key);\n\t});\n}\n\n/** @returns {void} */\nexport function fix_and_destroy_block(block, lookup) {\n\tblock.f();\n\tdestroy_block(block, lookup);\n}\n\n/** @returns {void} */\nexport function fix_and_outro_and_destroy_block(block, lookup) {\n\tblock.f();\n\toutro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nexport function update_keyed_each(\n\told_blocks,\n\tdirty,\n\tget_key,\n\tdynamic,\n\tctx,\n\tlist,\n\tlookup,\n\tnode,\n\tdestroy,\n\tcreate_each_block,\n\tnext,\n\tget_context\n) {\n\tlet o = old_blocks.length;\n\tlet n = list.length;\n\tlet i = o;\n\tconst old_indexes = {};\n\twhile (i--) old_indexes[old_blocks[i].key] = i;\n\tconst new_blocks = [];\n\tconst new_lookup = new Map();\n\tconst deltas = new Map();\n\tconst updates = [];\n\ti = n;\n\twhile (i--) {\n\t\tconst child_ctx = get_context(ctx, list, i);\n\t\tconst key = get_key(child_ctx);\n\t\tlet block = lookup.get(key);\n\t\tif (!block) {\n\t\t\tblock = create_each_block(key, child_ctx);\n\t\t\tblock.c();\n\t\t} else if (dynamic) {\n\t\t\t// defer updates until all the DOM shuffling is done\n\t\t\tupdates.push(() => block.p(child_ctx, dirty));\n\t\t}\n\t\tnew_lookup.set(key, (new_blocks[i] = block));\n\t\tif (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n\t}\n\tconst will_move = new Set();\n\tconst did_move = new Set();\n\t/** @returns {void} */\n\tfunction insert(block) {\n\t\ttransition_in(block, 1);\n\t\tblock.m(node, next);\n\t\tlookup.set(block.key, block);\n\t\tnext = block.first;\n\t\tn--;\n\t}\n\twhile (o && n) {\n\t\tconst new_block = new_blocks[n - 1];\n\t\tconst old_block = old_blocks[o - 1];\n\t\tconst new_key = new_block.key;\n\t\tconst old_key = old_block.key;\n\t\tif (new_block === old_block) {\n\t\t\t// do nothing\n\t\t\tnext = new_block.first;\n\t\t\to--;\n\t\t\tn--;\n\t\t} else if (!new_lookup.has(old_key)) {\n\t\t\t// remove old block\n\t\t\tdestroy(old_block, lookup);\n\t\t\to--;\n\t\t} else if (!lookup.has(new_key) || will_move.has(new_key)) {\n\t\t\tinsert(new_block);\n\t\t} else if (did_move.has(old_key)) {\n\t\t\to--;\n\t\t} else if (deltas.get(new_key) > deltas.get(old_key)) {\n\t\t\tdid_move.add(new_key);\n\t\t\tinsert(new_block);\n\t\t} else {\n\t\t\twill_move.add(old_key);\n\t\t\to--;\n\t\t}\n\t}\n\twhile (o--) {\n\t\tconst old_block = old_blocks[o];\n\t\tif (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n\t}\n\twhile (n) insert(new_blocks[n - 1]);\n\trun_all(updates);\n\treturn new_blocks;\n}\n\n/** @returns {void} */\nexport function validate_each_keys(ctx, list, get_context, get_key) {\n\tconst keys = new Map();\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst key = get_key(get_context(ctx, list, i));\n\t\tif (keys.has(key)) {\n\t\t\tlet value = '';\n\t\t\ttry {\n\t\t\t\tvalue = `with value '${String(key)}' `;\n\t\t\t} catch (e) {\n\t\t\t\t// can't stringify\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} ${value}are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n","import {\n\tadd_render_callback,\n\tflush,\n\tflush_render_callbacks,\n\tschedule_update,\n\tdirty_components\n} from './scheduler.js';\nimport { current_component, set_current_component } from './lifecycle.js';\nimport { blank_object, is_empty, is_function, run, run_all, noop } from './utils.js';\nimport {\n\tchildren,\n\tdetach,\n\tstart_hydrating,\n\tend_hydrating,\n\tget_custom_elements_slots,\n\tinsert,\n\telement,\n\tattr\n} from './dom.js';\nimport { transition_in } from './transitions.js';\n\n/** @returns {void} */\nexport function bind(component, name, callback) {\n\tconst index = component.$$.props[name];\n\tif (index !== undefined) {\n\t\tcomponent.$$.bound[index] = callback;\n\t\tcallback(component.$$.ctx[index]);\n\t}\n}\n\n/** @returns {void} */\nexport function create_component(block) {\n\tblock && block.c();\n}\n\n/** @returns {void} */\nexport function claim_component(block, parent_nodes) {\n\tblock && block.l(parent_nodes);\n}\n\n/** @returns {void} */\nexport function mount_component(component, target, anchor) {\n\tconst { fragment, after_update } = component.$$;\n\tfragment && fragment.m(target, anchor);\n\t// onMount happens before the initial afterUpdate\n\tadd_render_callback(() => {\n\t\tconst new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n\t\t// if the component was destroyed immediately\n\t\t// it will update the `$$.on_destroy` reference to `null`.\n\t\t// the destructured on_destroy may still reference to the old array\n\t\tif (component.$$.on_destroy) {\n\t\t\tcomponent.$$.on_destroy.push(...new_on_destroy);\n\t\t} else {\n\t\t\t// Edge case - component was destroyed immediately,\n\t\t\t// most likely as a result of a binding initialising\n\t\t\trun_all(new_on_destroy);\n\t\t}\n\t\tcomponent.$$.on_mount = [];\n\t});\n\tafter_update.forEach(add_render_callback);\n}\n\n/** @returns {void} */\nexport function destroy_component(component, detaching) {\n\tconst $$ = component.$$;\n\tif ($$.fragment !== null) {\n\t\tflush_render_callbacks($$.after_update);\n\t\trun_all($$.on_destroy);\n\t\t$$.fragment && $$.fragment.d(detaching);\n\t\t// TODO null out other refs, including component.$$ (but need to\n\t\t// preserve final state?)\n\t\t$$.on_destroy = $$.fragment = null;\n\t\t$$.ctx = [];\n\t}\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n\tif (component.$$.dirty[0] === -1) {\n\t\tdirty_components.push(component);\n\t\tschedule_update();\n\t\tcomponent.$$.dirty.fill(0);\n\t}\n\tcomponent.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nexport function init(\n\tcomponent,\n\toptions,\n\tinstance,\n\tcreate_fragment,\n\tnot_equal,\n\tprops,\n\tappend_styles = null,\n\tdirty = [-1]\n) {\n\tconst parent_component = current_component;\n\tset_current_component(component);\n\t/** @type {import('./private.js').T$$} */\n\tconst $$ = (component.$$ = {\n\t\tfragment: null,\n\t\tctx: [],\n\t\t// state\n\t\tprops,\n\t\tupdate: noop,\n\t\tnot_equal,\n\t\tbound: blank_object(),\n\t\t// lifecycle\n\t\ton_mount: [],\n\t\ton_destroy: [],\n\t\ton_disconnect: [],\n\t\tbefore_update: [],\n\t\tafter_update: [],\n\t\tcontext: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n\t\t// everything else\n\t\tcallbacks: blank_object(),\n\t\tdirty,\n\t\tskip_bound: false,\n\t\troot: options.target || parent_component.$$.root\n\t});\n\tappend_styles && append_styles($$.root);\n\tlet ready = false;\n\t$$.ctx = instance\n\t\t? instance(component, options.props || {}, (i, ret, ...rest) => {\n\t\t\t\tconst value = rest.length ? rest[0] : ret;\n\t\t\t\tif ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n\t\t\t\t\tif (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n\t\t\t\t\tif (ready) make_dirty(component, i);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t  })\n\t\t: [];\n\t$$.update();\n\tready = true;\n\trun_all($$.before_update);\n\t// `false` as a special case of no DOM component\n\t$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\tif (options.target) {\n\t\tif (options.hydrate) {\n\t\t\tstart_hydrating();\n\t\t\t// TODO: what is the correct type here?\n\t\t\t// @ts-expect-error\n\t\t\tconst nodes = children(options.target);\n\t\t\t$$.fragment && $$.fragment.l(nodes);\n\t\t\tnodes.forEach(detach);\n\t\t} else {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t$$.fragment && $$.fragment.c();\n\t\t}\n\t\tif (options.intro) transition_in(component.$$.fragment);\n\t\tmount_component(component, options.target, options.anchor);\n\t\tend_hydrating();\n\t\tflush();\n\t}\n\tset_current_component(parent_component);\n}\n\nexport let SvelteElement;\n\nif (typeof HTMLElement === 'function') {\n\tSvelteElement = class extends HTMLElement {\n\t\t/** The Svelte component constructor */\n\t\t$$ctor;\n\t\t/** Slots */\n\t\t$$s;\n\t\t/** The Svelte component instance */\n\t\t$$c;\n\t\t/** Whether or not the custom element is connected */\n\t\t$$cn = false;\n\t\t/** Component props data */\n\t\t$$d = {};\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\n\t\t$$r = false;\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n\t\t$$p_d = {};\n\t\t/** @type {Record<string, Function[]>} Event listeners */\n\t\t$$l = {};\n\t\t/** @type {Map<Function, Function>} Event listener unsubscribe functions */\n\t\t$$l_u = new Map();\n\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\n\t\t\tsuper();\n\t\t\tthis.$$ctor = $$componentCtor;\n\t\t\tthis.$$s = $$slots;\n\t\t\tif (use_shadow_dom) {\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t}\n\t\t}\n\n\t\taddEventListener(type, listener, options) {\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\n\t\t\t// browser event, this fires twice - we can't avoid that.\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\n\t\t\tthis.$$l[type].push(listener);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t}\n\t\t\tsuper.addEventListener(type, listener, options);\n\t\t}\n\n\t\tremoveEventListener(type, listener, options) {\n\t\t\tsuper.removeEventListener(type, listener, options);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\n\t\t\t\tif (unsub) {\n\t\t\t\t\tunsub();\n\t\t\t\t\tthis.$$l_u.delete(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync connectedCallback() {\n\t\t\tthis.$$cn = true;\n\t\t\tif (!this.$$c) {\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tif (!this.$$cn || this.$$c) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfunction create_slot(name) {\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tlet node;\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\tc: function create() {\n\t\t\t\t\t\t\t\tnode = element('slot');\n\t\t\t\t\t\t\t\tif (name !== 'default') {\n\t\t\t\t\t\t\t\t\tattr(node, 'name', name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {HTMLElement} target\n\t\t\t\t\t\t\t * @param {HTMLElement} [anchor]\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tm: function mount(target, anchor) {\n\t\t\t\t\t\t\t\tinsert(target, node, anchor);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\td: function destroy(detaching) {\n\t\t\t\t\t\t\t\tif (detaching) {\n\t\t\t\t\t\t\t\t\tdetach(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tconst $$slots = {};\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\n\t\t\t\tfor (const name of this.$$s) {\n\t\t\t\t\tif (name in existing_slots) {\n\t\t\t\t\t\t$$slots[name] = [create_slot(name)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const attribute of this.attributes) {\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\n\t\t\t\t\tif (!(name in this.$$d)) {\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Port over props that were set programmatically before ce was initialized\n\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\tif (!(key in this.$$d) && this[key] !== undefined) {\n\t\t\t\t\t\tthis.$$d[key] = this[key]; // don't transform, these were set through JavaScript\n\t\t\t\t\t\tdelete this[key]; // remove the property that shadows the getter/setter\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$c = new this.$$ctor({\n\t\t\t\t\ttarget: this.shadowRoot || this,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...this.$$d,\n\t\t\t\t\t\t$$slots,\n\t\t\t\t\t\t$$scope: {\n\t\t\t\t\t\t\tctx: []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reflect component props as attributes\n\t\t\t\tconst reflect_attributes = () => {\n\t\t\t\t\tthis.$$r = true;\n\t\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\t\tthis.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n\t\t\t\t\t\tif (this.$$p_d[key].reflect) {\n\t\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tthis.$$d[key],\n\t\t\t\t\t\t\t\tthis.$$p_d,\n\t\t\t\t\t\t\t\t'toAttribute'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (attribute_value == null) {\n\t\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.$$r = false;\n\t\t\t\t};\n\t\t\t\tthis.$$c.$$.after_update.push(reflect_attributes);\n\t\t\t\treflect_attributes(); // once initially because after_update is added too late for first render\n\n\t\t\t\tfor (const type in this.$$l) {\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$l = {};\n\t\t\t}\n\t\t}\n\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n\t\t// and setting attributes through setAttribute etc, this is helpful\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\n\t\t\tif (this.$$r) return;\n\t\t\tattr = this.$$g_p(attr);\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.$$cn = false;\n\t\t\t// In a microtask, because this could be a move within the DOM\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tif (!this.$$cn) {\n\t\t\t\t\tthis.$$c.$destroy();\n\t\t\t\t\tthis.$$c = undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t$$g_p(attribute_name) {\n\t\t\treturn (\n\t\t\t\tObject.keys(this.$$p_d).find(\n\t\t\t\t\t(key) =>\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\n\t\t\t\t) || attribute_name\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n\tconst type = props_definition[prop]?.type;\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n\tif (!transform || !props_definition[prop]) {\n\t\treturn value;\n\t} else if (transform === 'toAttribute') {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value ? '' : null;\n\t\t\tcase 'Number':\n\t\t\t\treturn value == null ? null : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value && JSON.parse(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value; // conversion already handled above\n\t\t\tcase 'Number':\n\t\t\t\treturn value != null ? +value : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nexport function create_custom_element(\n\tComponent,\n\tprops_definition,\n\tslots,\n\taccessors,\n\tuse_shadow_dom,\n\textend\n) {\n\tlet Class = class extends SvelteElement {\n\t\tconstructor() {\n\t\t\tsuper(Component, slots, use_shadow_dom);\n\t\t\tthis.$$p_d = props_definition;\n\t\t}\n\t\tstatic get observedAttributes() {\n\t\t\treturn Object.keys(props_definition).map((key) =>\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\n\t\t\t);\n\t\t}\n\t};\n\tObject.keys(props_definition).forEach((prop) => {\n\t\tObject.defineProperty(Class.prototype, prop, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\n\t\t\t\tthis.$$d[prop] = value;\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\n\t\t\t}\n\t\t});\n\t});\n\taccessors.forEach((accessor) => {\n\t\tObject.defineProperty(Class.prototype, accessor, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c?.[accessor];\n\t\t\t}\n\t\t});\n\t});\n\tif (extend) {\n\t\t// @ts-expect-error - assigning here is fine\n\t\tClass = extend(Class);\n\t}\n\tComponent.element = /** @type {any} */ (Class);\n\treturn Class;\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nexport class SvelteComponent {\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$ = undefined;\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$set = undefined;\n\n\t/** @returns {void} */\n\t$destroy() {\n\t\tdestroy_component(this, 1);\n\t\tthis.$destroy = noop;\n\t}\n\n\t/**\n\t * @template {Extract<keyof Events, string>} K\n\t * @param {K} type\n\t * @param {((e: Events[K]) => void) | null | undefined} callback\n\t * @returns {() => void}\n\t */\n\t$on(type, callback) {\n\t\tif (!is_function(callback)) {\n\t\t\treturn noop;\n\t\t}\n\t\tconst callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n\t\tcallbacks.push(callback);\n\t\treturn () => {\n\t\t\tconst index = callbacks.indexOf(callback);\n\t\t\tif (index !== -1) callbacks.splice(index, 1);\n\t\t};\n\t}\n\n\t/**\n\t * @param {Partial<Props>} props\n\t * @returns {void}\n\t */\n\t$set(props) {\n\t\tif (this.$$set && !is_empty(props)) {\n\t\t\tthis.$$.skip_bound = true;\n\t\t\tthis.$$set(props);\n\t\t\tthis.$$.skip_bound = false;\n\t\t}\n\t}\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '4.2.12';\nexport const PUBLIC_VERSION = '4';\n","import { PUBLIC_VERSION } from '../../../shared/version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);\n","<script lang=\"ts\">\n  import type { ImageAnnotation } from '@annotorious/annotorious';\n  import type { TextLayerOpts } from '../Types';\n\n  let ref: HTMLSpanElement;\n\n  /** props **/\n  export let annotation: ImageAnnotation;\n  export let opts: TextLayerOpts;\n\n  $: b = annotation.target.selector.geometry.bounds;\n\n  $: left = b.minX;\n  $: top = b.minY;\n  $: width = b.maxX - b.minX;\n  $: height = b.maxY - b.minY;\n\n  $: scaleX = ref ? width / ref.offsetWidth : 1;\n  $: scaleY = ref ? height / ref.offsetHeight : 1;\n\n  $: label = opts.label(annotation);\n</script>\n\n{#if label}\n  <div \n    class=\"annotation\"\n    style={`left:${left}px; top:${top}px; width: ${width}px; height: ${height}px; transform: scale(${scaleX}, ${scaleY})`}>\n    <span bind:this={ref}>\n      {label}\n    </span>&nbsp;<!-- ensures spaces between words on copy and paste! -->\n  </div>\n{/if}","<script lang=\"ts\">\n  import type { ImageAnnotation } from '@annotorious/annotorious';\n  import type { TextLayerOpts } from '../Types';\n\n  let ref: HTMLSpanElement;\n\n  /** props **/\n  export let annotation: ImageAnnotation;\n  export let opts: TextLayerOpts;\n\n  $: b = annotation.target.selector.geometry.bounds;\n\n  $: size =  ref ? [ref.offsetWidth, ref.offsetHeight] : [0, 0];\n\n  const getStyle = (size: number[]) => {\n    const offsetX = (opts.offsetX || 0);\n    const offsetY = (opts.offsetY || 0);\n\n    if (opts.position === 'center') {\n      const w = b.maxX - b.minX;\n      const cx = b.minX + w / 2 - size[0] / 2;\n\n      const h = b.maxY - b.minY;\n      const cy = b.minY + h / 2 - size[1] / 2;\n\n      return `left:${cx + offsetX}px; top:${cy + offsetY}px;`;\n    } else if (opts.position === 'topleft') {\n      return `left:${b.minX + offsetX}px; top:${b.minY + offsetY}px;`;\n    } else {\n      return `left:${b.minX + offsetX}px; top:${b.maxY + offsetY}px;`;\n    }\n  }\n\n  $: label = opts.label(annotation);\n</script>\n\n{#if label}\n  <div \n    class=\"annotation\"\n    style={getStyle(size)}>\n    <span bind:this={ref}>\n      {label}\n    </span>&nbsp;<!-- ensures spaces between words on copy and paste! -->\n  </div>\n{/if}","<script lang=\"ts\">\n  import type { ImageAnnotation } from '@annotorious/annotorious';\n  import type { TextLayerOpts } from '../Types';\n\n  /** props **/\n  export let annotation: ImageAnnotation;\n  export let opts: TextLayerOpts;\n  export let scale: number;\n  export let imageSize: [number, number];\n\n  $: b = annotation.target.selector.geometry.bounds;\n\n  $: x = b.minX;\n  $: y = opts.position === 'topleft' ? b.minY : b.maxY;\n\n  const getStyle = (x: number, y: number, scale: number) => {\n    const offsetX = (opts.offsetX || 0) / scale;\n    const offsetY = (opts.offsetY || 0) / scale;\n\n    if (opts.position === 'topleft') {\n      const bottom = imageSize[1] - y;\n      return `left:${x + offsetX}px; bottom:${bottom}px; transform: scale(${1 / scale})`;\n    } else {\n      return `left:${x + offsetX}px; top:${y + offsetY}px; transform: scale(${1 / scale})`;\n    }\n  }\n\n  $: label = opts.label(annotation);\n</script>\n\n{#if label}\n  <div \n    class=\"annotation\"\n    style={getStyle(x, y, scale)}>\n    <span>\n      {label}\n    </span>&nbsp;<!-- ensures spaces between words on copy and paste! -->\n  </div>\n{/if}","var nn = Object.defineProperty;\nvar on = (e, t, n) => t in e ? nn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;\nvar Ke = (e, t, n) => (on(e, typeof t != \"symbol\" ? t + \"\" : t, n), n);\nfunction V() {\n}\nfunction nt(e, t) {\n  for (const n in t)\n    e[n] = t[n];\n  return (\n    /** @type {T & S} */\n    e\n  );\n}\nfunction Nt(e) {\n  return e();\n}\nfunction dt() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction ae(e) {\n  e.forEach(Nt);\n}\nfunction q(e) {\n  return typeof e == \"function\";\n}\nfunction W(e, t) {\n  return e != e ? t == t : e !== t || e && typeof e == \"object\" || typeof e == \"function\";\n}\nfunction sn(e) {\n  return Object.keys(e).length === 0;\n}\nfunction Vt(e, ...t) {\n  if (e == null) {\n    for (const o of t)\n      o(void 0);\n    return V;\n  }\n  const n = e.subscribe(...t);\n  return n.unsubscribe ? () => n.unsubscribe() : n;\n}\nfunction ht(e, t, n) {\n  e.$$.on_destroy.push(Vt(t, n));\n}\nfunction rn(e, t, n, o) {\n  if (e) {\n    const i = Gt(e, t, n, o);\n    return e[0](i);\n  }\n}\nfunction Gt(e, t, n, o) {\n  return e[1] && o ? nt(n.ctx.slice(), e[1](o(t))) : n.ctx;\n}\nfunction ln(e, t, n, o) {\n  if (e[2] && o) {\n    const i = e[2](o(n));\n    if (t.dirty === void 0)\n      return i;\n    if (typeof i == \"object\") {\n      const s = [], r = Math.max(t.dirty.length, i.length);\n      for (let l = 0; l < r; l += 1)\n        s[l] = t.dirty[l] | i[l];\n      return s;\n    }\n    return t.dirty | i;\n  }\n  return t.dirty;\n}\nfunction an(e, t, n, o, i, s) {\n  if (i) {\n    const r = Gt(t, n, o, s);\n    e.p(r, i);\n  }\n}\nfunction cn(e) {\n  if (e.ctx.length > 32) {\n    const t = [], n = e.ctx.length / 32;\n    for (let o = 0; o < n; o++)\n      t[o] = -1;\n    return t;\n  }\n  return -1;\n}\nfunction gt(e) {\n  const t = {};\n  for (const n in e)\n    n[0] !== \"$\" && (t[n] = e[n]);\n  return t;\n}\nfunction Ge(e) {\n  return e ?? \"\";\n}\nconst fn = typeof window < \"u\" ? window : typeof globalThis < \"u\" ? globalThis : (\n  // @ts-ignore Node typings have this\n  global\n);\nfunction se(e, t) {\n  e.appendChild(t);\n}\nfunction B(e, t, n) {\n  e.insertBefore(t, n || null);\n}\nfunction k(e) {\n  e.parentNode && e.parentNode.removeChild(e);\n}\nfunction rt(e, t) {\n  for (let n = 0; n < e.length; n += 1)\n    e[n] && e[n].d(t);\n}\nfunction U(e) {\n  return document.createElementNS(\"http://www.w3.org/2000/svg\", e);\n}\nfunction zt(e) {\n  return document.createTextNode(e);\n}\nfunction oe() {\n  return zt(\" \");\n}\nfunction ce() {\n  return zt(\"\");\n}\nfunction F(e, t, n, o) {\n  return e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o);\n}\nfunction d(e, t, n) {\n  n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n);\n}\nfunction un(e) {\n  return Array.from(e.childNodes);\n}\nfunction ze(e, t, n) {\n  e.classList.toggle(t, !!n);\n}\nfunction dn(e, t, { bubbles: n = !1, cancelable: o = !1 } = {}) {\n  return new CustomEvent(e, { detail: t, bubbles: n, cancelable: o });\n}\nlet Ie;\nfunction Be(e) {\n  Ie = e;\n}\nfunction Ht() {\n  if (!Ie)\n    throw new Error(\"Function called outside component initialization\");\n  return Ie;\n}\nfunction Pe(e) {\n  Ht().$$.on_mount.push(e);\n}\nfunction Te() {\n  const e = Ht();\n  return (t, n, { cancelable: o = !1 } = {}) => {\n    const i = e.$$.callbacks[t];\n    if (i) {\n      const s = dn(\n        /** @type {string} */\n        t,\n        n,\n        { cancelable: o }\n      );\n      return i.slice().forEach((r) => {\n        r.call(e, s);\n      }), !s.defaultPrevented;\n    }\n    return !0;\n  };\n}\nfunction ue(e, t) {\n  const n = e.$$.callbacks[t.type];\n  n && n.slice().forEach((o) => o.call(this, t));\n}\nconst be = [], He = [];\nlet Ae = [];\nconst mt = [], hn = /* @__PURE__ */ Promise.resolve();\nlet ot = !1;\nfunction gn() {\n  ot || (ot = !0, hn.then(Ft));\n}\nfunction it(e) {\n  Ae.push(e);\n}\nconst We = /* @__PURE__ */ new Set();\nlet pe = 0;\nfunction Ft() {\n  if (pe !== 0)\n    return;\n  const e = Ie;\n  do {\n    try {\n      for (; pe < be.length; ) {\n        const t = be[pe];\n        pe++, Be(t), mn(t.$$);\n      }\n    } catch (t) {\n      throw be.length = 0, pe = 0, t;\n    }\n    for (Be(null), be.length = 0, pe = 0; He.length; )\n      He.pop()();\n    for (let t = 0; t < Ae.length; t += 1) {\n      const n = Ae[t];\n      We.has(n) || (We.add(n), n());\n    }\n    Ae.length = 0;\n  } while (be.length);\n  for (; mt.length; )\n    mt.pop()();\n  ot = !1, We.clear(), Be(e);\n}\nfunction mn(e) {\n  if (e.fragment !== null) {\n    e.update(), ae(e.before_update);\n    const t = e.dirty;\n    e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(it);\n  }\n}\nfunction pn(e) {\n  const t = [], n = [];\n  Ae.forEach((o) => e.indexOf(o) === -1 ? t.push(o) : n.push(o)), n.forEach((o) => o()), Ae = t;\n}\nconst Ve = /* @__PURE__ */ new Set();\nlet de;\nfunction re() {\n  de = {\n    r: 0,\n    c: [],\n    p: de\n    // parent group\n  };\n}\nfunction le() {\n  de.r || ae(de.c), de = de.p;\n}\nfunction P(e, t) {\n  e && e.i && (Ve.delete(e), e.i(t));\n}\nfunction C(e, t, n, o) {\n  if (e && e.o) {\n    if (Ve.has(e))\n      return;\n    Ve.add(e), de.c.push(() => {\n      Ve.delete(e), o && (n && e.d(1), o());\n    }), e.o(t);\n  } else\n    o && o();\n}\nfunction Se(e) {\n  return (e == null ? void 0 : e.length) !== void 0 ? e : Array.from(e);\n}\nfunction $(e) {\n  e && e.c();\n}\nfunction Q(e, t, n) {\n  const { fragment: o, after_update: i } = e.$$;\n  o && o.m(t, n), it(() => {\n    const s = e.$$.on_mount.map(Nt).filter(q);\n    e.$$.on_destroy ? e.$$.on_destroy.push(...s) : ae(s), e.$$.on_mount = [];\n  }), i.forEach(it);\n}\nfunction x(e, t) {\n  const n = e.$$;\n  n.fragment !== null && (pn(n.after_update), ae(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);\n}\nfunction yn(e, t) {\n  e.$$.dirty[0] === -1 && (be.push(e), gn(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;\n}\nfunction ee(e, t, n, o, i, s, r = null, l = [-1]) {\n  const a = Ie;\n  Be(e);\n  const c = e.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props: s,\n    update: V,\n    not_equal: i,\n    bound: dt(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(t.context || (a ? a.$$.context : [])),\n    // everything else\n    callbacks: dt(),\n    dirty: l,\n    skip_bound: !1,\n    root: t.target || a.$$.root\n  };\n  r && r(c.root);\n  let u = !1;\n  if (c.ctx = n ? n(e, t.props || {}, (f, h, ...g) => {\n    const m = g.length ? g[0] : h;\n    return c.ctx && i(c.ctx[f], c.ctx[f] = m) && (!c.skip_bound && c.bound[f] && c.bound[f](m), u && yn(e, f)), h;\n  }) : [], c.update(), u = !0, ae(c.before_update), c.fragment = o ? o(c.ctx) : !1, t.target) {\n    if (t.hydrate) {\n      const f = un(t.target);\n      c.fragment && c.fragment.l(f), f.forEach(k);\n    } else\n      c.fragment && c.fragment.c();\n    t.intro && P(e.$$.fragment), Q(e, t.target, t.anchor), Ft();\n  }\n  Be(a);\n}\nclass te {\n  constructor() {\n    /**\n     * ### PRIVATE API\n     *\n     * Do not use, may change at any time\n     *\n     * @type {any}\n     */\n    Ke(this, \"$$\");\n    /**\n     * ### PRIVATE API\n     *\n     * Do not use, may change at any time\n     *\n     * @type {any}\n     */\n    Ke(this, \"$$set\");\n  }\n  /** @returns {void} */\n  $destroy() {\n    x(this, 1), this.$destroy = V;\n  }\n  /**\n   * @template {Extract<keyof Events, string>} K\n   * @param {K} type\n   * @param {((e: Events[K]) => void) | null | undefined} callback\n   * @returns {() => void}\n   */\n  $on(t, n) {\n    if (!q(n))\n      return V;\n    const o = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);\n    return o.push(n), () => {\n      const i = o.indexOf(n);\n      i !== -1 && o.splice(i, 1);\n    };\n  }\n  /**\n   * @param {Partial<Props>} props\n   * @returns {void}\n   */\n  $set(t) {\n    this.$$set && !sn(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);\n  }\n}\nconst _n = \"4\";\ntypeof window < \"u\" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(_n);\nvar j = /* @__PURE__ */ ((e) => (e.ELLIPSE = \"ELLIPSE\", e.POLYGON = \"POLYGON\", e.RECTANGLE = \"RECTANGLE\", e))(j || {});\nconst lt = {}, at = (e, t) => lt[e] = t, st = (e) => lt[e.type].area(e), wn = (e, t, n) => lt[e.type].intersects(e, t, n), Fe = (e) => {\n  let t = 1 / 0, n = 1 / 0, o = -1 / 0, i = -1 / 0;\n  return e.forEach(([s, r]) => {\n    t = Math.min(t, s), n = Math.min(n, r), o = Math.max(o, s), i = Math.max(i, r);\n  }), { minX: t, minY: n, maxX: o, maxY: i };\n}, bn = {\n  area: (e) => Math.PI * e.geometry.rx * e.geometry.ry,\n  intersects: (e, t, n) => {\n    const { cx: o, cy: i, rx: s, ry: r } = e.geometry, l = 0, a = Math.cos(l), c = Math.sin(l), u = t - o, f = n - i, h = a * u + c * f, g = c * u - a * f;\n    return h * h / (s * s) + g * g / (r * r) <= 1;\n  }\n};\nat(j.ELLIPSE, bn);\nconst En = {\n  area: (e) => {\n    const { points: t } = e.geometry;\n    let n = 0, o = t.length - 1;\n    for (let i = 0; i < t.length; i++)\n      n += (t[o][0] + t[i][0]) * (t[o][1] - t[i][1]), o = i;\n    return Math.abs(0.5 * n);\n  },\n  intersects: (e, t, n) => {\n    const { points: o } = e.geometry;\n    let i = !1;\n    for (let s = 0, r = o.length - 1; s < o.length; r = s++) {\n      const l = o[s][0], a = o[s][1], c = o[r][0], u = o[r][1];\n      a > n != u > n && t < (c - l) * (n - a) / (u - a) + l && (i = !i);\n    }\n    return i;\n  }\n};\nat(j.POLYGON, En);\nconst An = {\n  area: (e) => e.geometry.w * e.geometry.h,\n  intersects: (e, t, n) => t >= e.geometry.x && t <= e.geometry.x + e.geometry.w && n >= e.geometry.y && n <= e.geometry.y + e.geometry.h\n};\nat(j.RECTANGLE, An);\nconst Sn = (e, t = !1) => {\n  const n = typeof e == \"string\" ? e : e.value, o = /^(xywh)=(pixel|percent)?:?(.+?),(.+?),(.+?),(.+)*/g, i = [...n.matchAll(o)][0], [s, r, l, a, c, u, f] = i;\n  if (r !== \"xywh\")\n    throw new Error(\"Unsupported MediaFragment: \" + n);\n  if (l && l !== \"pixel\")\n    throw new Error(`Unsupported MediaFragment unit: ${l}`);\n  const [h, g, m, _] = [a, c, u, f].map(parseFloat);\n  return {\n    type: j.RECTANGLE,\n    geometry: {\n      x: h,\n      y: g,\n      w: m,\n      h: _,\n      bounds: {\n        minX: h,\n        minY: t ? g - _ : g,\n        maxX: h + m,\n        maxY: t ? g : g + _\n      }\n    }\n  };\n}, Tn = (e) => {\n  const { x: t, y: n, w: o, h: i } = e;\n  return {\n    type: \"FragmentSelector\",\n    conformsTo: \"http://www.w3.org/TR/media-frags/\",\n    value: `xywh=pixel:${t},${n},${o},${i}`\n  };\n}, jt = \"http://www.w3.org/2000/svg\", pt = (e) => {\n  const t = (o) => {\n    Array.from(o.attributes).forEach((i) => {\n      i.name.startsWith(\"on\") && o.removeAttribute(i.name);\n    });\n  }, n = e.getElementsByTagName(\"script\");\n  return Array.from(n).reverse().forEach((o) => o.parentNode.removeChild(o)), Array.from(e.querySelectorAll(\"*\")).forEach(t), e;\n}, Mn = (e) => {\n  const o = new XMLSerializer().serializeToString(e.documentElement).replace(\"<svg>\", `<svg xmlns=\"${jt}\">`);\n  return new DOMParser().parseFromString(o, \"image/svg+xml\").documentElement;\n}, vn = (e) => {\n  const n = new DOMParser().parseFromString(e, \"image/svg+xml\"), o = n.lookupPrefix(jt), i = n.lookupNamespaceURI(null);\n  return o || i ? pt(n).firstChild : pt(Mn(n)).firstChild;\n}, Ln = (e) => {\n  const [t, n, o] = e.match(/(<polygon points=[\"|'])([^(\"|')]*)/) || [], i = o.split(\" \").map((s) => s.split(\",\").map(parseFloat));\n  return {\n    type: j.POLYGON,\n    geometry: {\n      points: i,\n      bounds: Fe(i)\n    }\n  };\n}, kn = (e) => {\n  const t = vn(e), n = parseFloat(t.getAttribute(\"cx\")), o = parseFloat(t.getAttribute(\"cy\")), i = parseFloat(t.getAttribute(\"rx\")), s = parseFloat(t.getAttribute(\"ry\")), r = {\n    minX: n - i,\n    minY: o - s,\n    maxX: n + i,\n    maxY: o + s\n  };\n  return {\n    type: j.ELLIPSE,\n    geometry: {\n      cx: n,\n      cy: o,\n      rx: i,\n      ry: s,\n      bounds: r\n    }\n  };\n}, On = (e) => {\n  const t = typeof e == \"string\" ? e : e.value;\n  if (t.includes(\"<polygon points=\"))\n    return Ln(t);\n  if (t.includes(\"<ellipse \"))\n    return kn(t);\n  throw \"Unsupported SVG shape: \" + t;\n}, Bn = (e) => {\n  let t;\n  if (e.type === j.POLYGON) {\n    const n = e.geometry, { points: o } = n;\n    t = `<svg><polygon points=\"${o.map((i) => i.join(\",\")).join(\" \")}\" /></svg>`;\n  } else if (e.type === j.ELLIPSE) {\n    const n = e.geometry;\n    t = `<svg><ellipse cx=\"${n.cx}\" cy=\"${n.cy}\" rx=\"${n.rx}\" ry=\"${n.ry}\" /></svg>`;\n  }\n  if (t)\n    return { type: \"SvgSelector\", value: t };\n  throw `Unsupported shape type: ${e.type}`;\n};\nlet Re;\nconst In = new Uint8Array(16);\nfunction Pn() {\n  if (!Re && (Re = typeof crypto < \"u\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Re))\n    throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n  return Re(In);\n}\nconst K = [];\nfor (let e = 0; e < 256; ++e)\n  K.push((e + 256).toString(16).slice(1));\nfunction Yn(e, t = 0) {\n  return K[e[t + 0]] + K[e[t + 1]] + K[e[t + 2]] + K[e[t + 3]] + \"-\" + K[e[t + 4]] + K[e[t + 5]] + \"-\" + K[e[t + 6]] + K[e[t + 7]] + \"-\" + K[e[t + 8]] + K[e[t + 9]] + \"-\" + K[e[t + 10]] + K[e[t + 11]] + K[e[t + 12]] + K[e[t + 13]] + K[e[t + 14]] + K[e[t + 15]];\n}\nconst Dn = typeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto), yt = {\n  randomUUID: Dn\n};\nfunction qt(e, t, n) {\n  if (yt.randomUUID && !t && !e)\n    return yt.randomUUID();\n  e = e || {};\n  const o = e.random || (e.rng || Pn)();\n  if (o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, t) {\n    n = n || 0;\n    for (let i = 0; i < 16; ++i)\n      t[n + i] = o[i];\n    return t;\n  }\n  return Yn(o);\n}\nvar _t = Object.prototype.hasOwnProperty;\nfunction he(e, t) {\n  var n, o;\n  if (e === t)\n    return !0;\n  if (e && t && (n = e.constructor) === t.constructor) {\n    if (n === Date)\n      return e.getTime() === t.getTime();\n    if (n === RegExp)\n      return e.toString() === t.toString();\n    if (n === Array) {\n      if ((o = e.length) === t.length)\n        for (; o-- && he(e[o], t[o]); )\n          ;\n      return o === -1;\n    }\n    if (!n || typeof e == \"object\") {\n      o = 0;\n      for (n in e)\n        if (_t.call(e, n) && ++o && !_t.call(t, n) || !(n in t) || !he(e[n], t[n]))\n          return !1;\n      return Object.keys(t).length === o;\n    }\n  }\n  return e !== e && t !== t;\n}\nfunction Je() {\n}\nfunction Xn(e, t) {\n  return e != e ? t == t : e !== t || e && typeof e == \"object\" || typeof e == \"function\";\n}\nconst ye = [];\nfunction ct(e, t = Je) {\n  let n;\n  const o = /* @__PURE__ */ new Set();\n  function i(l) {\n    if (Xn(e, l) && (e = l, n)) {\n      const a = !ye.length;\n      for (const c of o)\n        c[1](), ye.push(c, e);\n      if (a) {\n        for (let c = 0; c < ye.length; c += 2)\n          ye[c][0](ye[c + 1]);\n        ye.length = 0;\n      }\n    }\n  }\n  function s(l) {\n    i(l(e));\n  }\n  function r(l, a = Je) {\n    const c = [l, a];\n    return o.add(c), o.size === 1 && (n = t(i, s) || Je), l(e), () => {\n      o.delete(c), o.size === 0 && n && (n(), n = null);\n    };\n  }\n  return { set: i, update: s, subscribe: r };\n}\nconst Cn = (e) => {\n  const { subscribe: t, set: n } = ct();\n  let o;\n  return t((i) => o = i), e.observe(({ changes: i }) => {\n    if (o) {\n      (i.deleted || []).some((r) => r.id === o) && n(void 0);\n      const s = (i.updated || []).find(({ oldValue: r }) => r.id === o);\n      s && n(s.newValue.id);\n    }\n  }), {\n    get current() {\n      return o;\n    },\n    subscribe: t,\n    set: n\n  };\n};\nvar Kt = /* @__PURE__ */ ((e) => (e.EDIT = \"EDIT\", e.SELECT = \"SELECT\", e.NONE = \"NONE\", e))(Kt || {});\nconst Ze = { selected: [] }, Rn = (e, t = \"EDIT\") => {\n  const { subscribe: n, set: o } = ct(Ze);\n  let i = Ze;\n  n((f) => i = f);\n  const s = () => o(Ze), r = () => {\n    var f;\n    return ((f = i.selected) == null ? void 0 : f.length) === 0;\n  }, l = (f) => {\n    if (i.selected.length === 0)\n      return !1;\n    const h = typeof f == \"string\" ? f : f.id;\n    return i.selected.some((g) => g.id === h);\n  }, a = (f, h) => {\n    const g = e.getAnnotation(f);\n    if (g) {\n      const m = Un(g, t);\n      o(m === \"EDIT\" ? { selected: [{ id: f, editable: !0 }], pointerEvent: h } : m === \"SELECT\" ? { selected: [{ id: f }], pointerEvent: h } : { selected: [], pointerEvent: h });\n    } else\n      console.warn(\"Invalid selection: \" + f);\n  }, c = (f, h = !0) => {\n    const g = Array.isArray(f) ? f : [f], m = g.map((_) => e.getAnnotation(_)).filter(Boolean);\n    o({ selected: m.map(({ id: _ }) => ({ id: _, editable: h })) }), m.length !== g.length && console.warn(\"Invalid selection\", f);\n  }, u = (f) => {\n    if (i.selected.length === 0)\n      return !1;\n    const { selected: h } = i;\n    h.filter(({ id: g }) => f.includes(g)).length > 0 && o({ selected: h.filter(({ id: g }) => !f.includes(g)) });\n  };\n  return e.observe(({ changes: f }) => u((f.deleted || []).map((h) => h.id))), {\n    clear: s,\n    clickSelect: a,\n    get selected() {\n      return i ? [...i.selected] : null;\n    },\n    get pointerEvent() {\n      return i ? i.pointerEvent : null;\n    },\n    isEmpty: r,\n    isSelected: l,\n    setSelected: c,\n    subscribe: n\n  };\n}, Un = (e, t) => typeof t == \"function\" ? t(e) || \"EDIT\" : t || \"EDIT\", Nn = [];\nfor (let e = 0; e < 256; ++e)\n  Nn.push((e + 256).toString(16).slice(1));\ntypeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nconst Vn = (e, t) => {\n  const n = new Set(e.bodies.map((o) => o.id));\n  return t.bodies.filter((o) => !n.has(o.id));\n}, Gn = (e, t) => {\n  const n = new Set(t.bodies.map((o) => o.id));\n  return e.bodies.filter((o) => !n.has(o.id));\n}, zn = (e, t) => t.bodies.map((n) => {\n  const o = e.bodies.find((i) => i.id === n.id);\n  return { newBody: n, oldBody: o && !he(o, n) ? o : void 0 };\n}).filter(({ oldBody: n }) => n).map(({ oldBody: n, newBody: o }) => ({ oldBody: n, newBody: o })), Hn = (e, t) => !he(e.target, t.target), Wt = (e, t) => {\n  const n = Vn(e, t), o = Gn(e, t), i = zn(e, t);\n  return {\n    oldValue: e,\n    newValue: t,\n    bodiesCreated: n.length > 0 ? n : void 0,\n    bodiesDeleted: o.length > 0 ? o : void 0,\n    bodiesUpdated: i.length > 0 ? i : void 0,\n    targetUpdated: Hn(e, t) ? { oldTarget: e.target, newTarget: t.target } : void 0\n  };\n};\nvar G = /* @__PURE__ */ ((e) => (e.LOCAL = \"LOCAL\", e.REMOTE = \"REMOTE\", e))(G || {});\nconst Fn = (e, t) => {\n  var n, o;\n  const { changes: i, origin: s } = t;\n  if (!(!e.options.origin || e.options.origin === s))\n    return !1;\n  if (e.options.ignore) {\n    const { ignore: r } = e.options, l = (a) => a && a.length > 0;\n    if (!(l(i.created) || l(i.deleted))) {\n      const a = (n = i.updated) == null ? void 0 : n.some((u) => l(u.bodiesCreated) || l(u.bodiesDeleted) || l(u.bodiesUpdated)), c = (o = i.updated) == null ? void 0 : o.some((u) => u.targetUpdated);\n      if (r === \"BODY_ONLY\" && a && !c || r === \"TARGET_ONLY\" && c && !a)\n        return !1;\n    }\n  }\n  if (e.options.annotations) {\n    const r = /* @__PURE__ */ new Set([\n      ...(i.created || []).map((l) => l.id),\n      ...(i.deleted || []).map((l) => l.id),\n      ...(i.updated || []).map(({ oldValue: l }) => l.id)\n    ]);\n    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((l) => r.has(l));\n  } else\n    return !0;\n}, jn = (e, t) => {\n  const n = new Set((e.created || []).map((f) => f.id)), o = new Set((e.updated || []).map(({ newValue: f }) => f.id)), i = new Set((t.created || []).map((f) => f.id)), s = new Set((t.deleted || []).map((f) => f.id)), r = new Set((t.updated || []).map(({ oldValue: f }) => f.id)), l = new Set((t.updated || []).filter(({ oldValue: f }) => n.has(f.id) || o.has(f.id)).map(({ oldValue: f }) => f.id)), a = [\n    ...(e.created || []).filter((f) => !s.has(f.id)).map((f) => r.has(f.id) ? t.updated.find(({ oldValue: h }) => h.id === f.id).newValue : f),\n    ...t.created || []\n  ], c = [\n    ...(e.deleted || []).filter((f) => !i.has(f.id)),\n    ...(t.deleted || []).filter((f) => !n.has(f.id))\n  ], u = [\n    ...(e.updated || []).filter(({ newValue: f }) => !s.has(f.id)).map((f) => {\n      const { oldValue: h, newValue: g } = f;\n      if (r.has(g.id)) {\n        const m = t.updated.find((_) => _.oldValue.id === g.id).newValue;\n        return Wt(h, m);\n      } else\n        return f;\n    }),\n    ...(t.updated || []).filter(({ oldValue: f }) => !l.has(f.id))\n  ];\n  return { created: a, deleted: c, updated: u };\n}, qn = (e) => e.id !== void 0, Kn = () => {\n  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = [], o = (p, T = {}) => n.push({ onChange: p, options: T }), i = (p) => {\n    const T = n.findIndex((S) => S.onChange == p);\n    T > -1 && n.splice(T, 1);\n  }, s = (p, T) => {\n    const S = {\n      origin: p,\n      changes: {\n        created: T.created || [],\n        updated: T.updated || [],\n        deleted: T.deleted || []\n      },\n      state: [...e.values()]\n    };\n    n.forEach((M) => {\n      Fn(M, S) && M.onChange(S);\n    });\n  }, r = (p, T = G.LOCAL) => {\n    if (e.get(p.id))\n      throw Error(`Cannot add annotation ${p.id} - exists already`);\n    e.set(p.id, p), p.bodies.forEach((S) => t.set(S.id, p.id)), s(T, { created: [p] });\n  }, l = (p, T) => {\n    const S = typeof p == \"string\" ? T : p, M = typeof p == \"string\" ? p : p.id, O = e.get(M);\n    if (O) {\n      const X = Wt(O, S);\n      return M === S.id ? e.set(M, S) : (e.delete(M), e.set(S.id, S)), O.bodies.forEach((Z) => t.delete(Z.id)), S.bodies.forEach((Z) => t.set(Z.id, S.id)), X;\n    } else\n      console.warn(`Cannot update annotation ${M} - does not exist`);\n  }, a = (p, T = G.LOCAL, S = G.LOCAL) => {\n    const M = qn(T) ? S : T, O = l(p, T);\n    O && s(M, { updated: [O] });\n  }, c = (p, T = G.LOCAL) => {\n    const S = p.reduce((M, O) => {\n      const X = l(O);\n      return X ? [...M, X] : M;\n    }, []);\n    S.length > 0 && s(T, { updated: S });\n  }, u = (p, T = G.LOCAL) => {\n    const S = e.get(p.annotation);\n    if (S) {\n      const M = {\n        ...S,\n        bodies: [...S.bodies, p]\n      };\n      e.set(S.id, M), t.set(p.id, M.id), s(T, { updated: [{\n        oldValue: S,\n        newValue: M,\n        bodiesCreated: [p]\n      }] });\n    } else\n      console.warn(`Attempt to add body to missing annotation: ${p.annotation}`);\n  }, f = () => [...e.values()], h = (p = G.LOCAL) => {\n    const T = [...e.values()];\n    e.clear(), t.clear(), s(p, { deleted: T });\n  }, g = (p, T = !0, S = G.LOCAL) => {\n    if (T) {\n      const M = [...e.values()];\n      e.clear(), t.clear(), p.forEach((O) => {\n        e.set(O.id, O), O.bodies.forEach((X) => t.set(X.id, O.id));\n      }), s(S, { created: p, deleted: M });\n    } else {\n      const M = p.reduce((O, X) => {\n        const Z = e.get(X.id);\n        return Z ? [...O, Z] : O;\n      }, []);\n      if (M.length > 0)\n        throw Error(`Bulk insert would overwrite the following annotations: ${M.map((O) => O.id).join(\", \")}`);\n      p.forEach((O) => {\n        e.set(O.id, O), O.bodies.forEach((X) => t.set(X.id, O.id));\n      }), s(S, { created: p });\n    }\n  }, m = (p) => {\n    const T = typeof p == \"string\" ? p : p.id, S = e.get(T);\n    if (S)\n      return e.delete(T), S.bodies.forEach((M) => t.delete(M.id)), S;\n    console.warn(`Attempt to delete missing annotation: ${T}`);\n  }, _ = (p, T = G.LOCAL) => {\n    const S = m(p);\n    S && s(T, { deleted: [S] });\n  }, w = (p, T = G.LOCAL) => {\n    const S = p.reduce((M, O) => {\n      const X = m(O);\n      return X ? [...M, X] : M;\n    }, []);\n    S.length > 0 && s(T, { deleted: S });\n  }, y = (p, T = G.LOCAL) => {\n    const S = e.get(p.annotation);\n    if (S) {\n      const M = S.bodies.find((O) => O.id === p.id);\n      if (M) {\n        t.delete(M.id);\n        const O = {\n          ...S,\n          bodies: S.bodies.filter((X) => X.id !== p.id)\n        };\n        e.set(S.id, O), s(T, { updated: [{\n          oldValue: S,\n          newValue: O,\n          bodiesDeleted: [M]\n        }] });\n      } else\n        console.warn(`Attempt to delete missing body ${p.id} from annotation ${p.annotation}`);\n    } else\n      console.warn(`Attempt to delete body from missing annotation ${p.annotation}`);\n  }, E = (p) => {\n    const T = e.get(p);\n    return T ? { ...T } : void 0;\n  }, b = (p) => {\n    const T = t.get(p);\n    if (T) {\n      const S = E(T).bodies.find((M) => M.id === p);\n      if (S)\n        return S;\n      console.error(`Store integrity error: body ${p} in index, but not in annotation`);\n    } else\n      console.warn(`Attempt to retrieve missing body: ${p}`);\n  }, A = (p, T) => {\n    if (p.annotation !== T.annotation)\n      throw \"Annotation integrity violation: annotation ID must be the same when updating bodies\";\n    const S = e.get(p.annotation);\n    if (S) {\n      const M = S.bodies.find((X) => X.id === p.id), O = {\n        ...S,\n        bodies: S.bodies.map((X) => X.id === M.id ? T : X)\n      };\n      return e.set(S.id, O), M.id !== T.id && (t.delete(M.id), t.set(T.id, O.id)), {\n        oldValue: S,\n        newValue: O,\n        bodiesUpdated: [{ oldBody: M, newBody: T }]\n      };\n    } else\n      console.warn(`Attempt to add body to missing annotation ${p.annotation}`);\n  }, L = (p, T, S = G.LOCAL) => {\n    const M = A(p, T);\n    M && s(S, { updated: [M] });\n  }, D = (p, T = G.LOCAL) => {\n    const S = p.map((M) => A({ id: M.id, annotation: M.annotation }, M)).filter(Boolean);\n    s(T, { updated: S });\n  }, R = (p) => {\n    const T = e.get(p.annotation);\n    if (T) {\n      const S = {\n        ...T,\n        target: {\n          ...T.target,\n          ...p\n        }\n      };\n      return e.set(T.id, S), {\n        oldValue: T,\n        newValue: S,\n        targetUpdated: {\n          oldTarget: T.target,\n          newTarget: p\n        }\n      };\n    } else\n      console.warn(`Attempt to update target on missing annotation: ${p.annotation}`);\n  };\n  return {\n    addAnnotation: r,\n    addBody: u,\n    all: f,\n    bulkAddAnnotation: g,\n    bulkDeleteAnnotation: w,\n    bulkUpdateAnnotation: c,\n    bulkUpdateBodies: D,\n    bulkUpdateTargets: (p, T = G.LOCAL) => {\n      const S = p.map((M) => R(M)).filter(Boolean);\n      S.length > 0 && s(T, { updated: S });\n    },\n    clear: h,\n    deleteAnnotation: _,\n    deleteBody: y,\n    getAnnotation: E,\n    getBody: b,\n    observe: o,\n    unobserve: i,\n    updateAnnotation: a,\n    updateBody: L,\n    updateTarget: (p, T = G.LOCAL) => {\n      const S = R(p);\n      S && s(T, { updated: [S] });\n    }\n  };\n}, Wn = (e) => ({\n  ...e,\n  subscribe: (t) => {\n    const n = (o) => t(o.state);\n    return e.observe(n), t(e.all()), () => e.unobserve(n);\n  }\n});\nlet Jn = () => ({\n  emit(e, ...t) {\n    for (let n = 0, o = this.events[e] || [], i = o.length; n < i; n++)\n      o[n](...t);\n  },\n  events: {},\n  on(e, t) {\n    var n;\n    return ((n = this.events)[e] || (n[e] = [])).push(t), () => {\n      var o;\n      this.events[e] = (o = this.events[e]) == null ? void 0 : o.filter((i) => t !== i);\n    };\n  }\n});\nconst Zn = 250, Qn = (e) => {\n  const t = Jn(), n = [];\n  let o = -1, i = !1, s = 0;\n  const r = (g) => {\n    if (!i) {\n      const { changes: m } = g, _ = performance.now();\n      if (_ - s > Zn)\n        n.splice(o + 1), n.push(m), o = n.length - 1;\n      else {\n        const w = n.length - 1;\n        n[w] = jn(n[w], m);\n      }\n      s = _;\n    }\n    i = !1;\n  };\n  e.observe(r, { origin: G.LOCAL });\n  const l = (g) => g && g.length > 0 && e.bulkDeleteAnnotation(g), a = (g) => g && g.length > 0 && e.bulkAddAnnotation(g, !1), c = (g) => g && g.length > 0 && e.bulkUpdateAnnotation(g.map(({ oldValue: m }) => m)), u = (g) => g && g.length > 0 && e.bulkUpdateAnnotation(g.map(({ newValue: m }) => m)), f = (g) => g && g.length > 0 && e.bulkAddAnnotation(g, !1), h = (g) => g && g.length > 0 && e.bulkDeleteAnnotation(g);\n  return {\n    canRedo: () => n.length - 1 > o,\n    canUndo: () => o > -1,\n    destroy: () => e.unobserve(r),\n    on: (g, m) => t.on(g, m),\n    redo: () => {\n      if (n.length - 1 > o) {\n        i = !0;\n        const { created: g, updated: m, deleted: _ } = n[o + 1];\n        a(g), u(m), h(_), t.emit(\"redo\", n[o + 1]), o += 1;\n      }\n    },\n    undo: () => {\n      if (o > -1) {\n        i = !0;\n        const { created: g, updated: m, deleted: _ } = n[o];\n        l(g), c(m), f(_), t.emit(\"undo\", n[o]), o -= 1;\n      }\n    }\n  };\n}, xn = () => {\n  const { subscribe: e, set: t } = ct([]);\n  return {\n    subscribe: e,\n    set: t\n  };\n}, $n = (e, t, n, o) => {\n  const { store: i, selection: s, hover: r, viewport: l } = e, a = /* @__PURE__ */ new Map();\n  let c = [], u, f;\n  const h = (y, E) => {\n    a.has(y) ? a.get(y).push(E) : a.set(y, [E]);\n  }, g = (y, E) => {\n    const b = a.get(y);\n    b && b.indexOf(E) > 0 && b.splice(b.indexOf(E), 1);\n  }, m = (y, E, b) => {\n    a.has(y) && setTimeout(() => {\n      a.get(y).forEach((A) => {\n        if (n) {\n          const L = Array.isArray(E) ? E.map((R) => n.serialize(R)) : n.serialize(E), D = b ? b instanceof PointerEvent ? b : n.serialize(b) : void 0;\n          A(L, D);\n        } else\n          A(E, b);\n      });\n    }, 1);\n  }, _ = () => {\n    const { selected: y } = s, E = (y || []).map(({ id: b }) => i.getAnnotation(b));\n    E.forEach((b) => {\n      const A = c.find((L) => L.id === b.id);\n      (!A || !he(A, b)) && m(\"updateAnnotation\", b, A);\n    }), c = c.map((b) => E.find(({ id: L }) => L === b.id) || b);\n  };\n  s.subscribe(({ selected: y }) => {\n    if (!(c.length === 0 && y.length === 0)) {\n      if (c.length === 0 && y.length > 0)\n        c = y.map(({ id: E }) => i.getAnnotation(E));\n      else if (c.length > 0 && y.length === 0)\n        c.forEach((E) => {\n          const b = i.getAnnotation(E.id);\n          b && !he(b, E) && m(\"updateAnnotation\", b, E);\n        }), c = [];\n      else {\n        const E = new Set(c.map((A) => A.id)), b = new Set(y.map(({ id: A }) => A));\n        c.filter((A) => !b.has(A.id)).forEach((A) => {\n          const L = i.getAnnotation(A.id);\n          L && !he(L, A) && m(\"updateAnnotation\", L, A);\n        }), c = [\n          // Remove annotations that were deselected\n          ...c.filter((A) => b.has(A.id)),\n          // Add editable annotations that were selected\n          ...y.filter(({ id: A }) => !E.has(A)).map(({ id: A }) => i.getAnnotation(A))\n        ];\n      }\n      m(\"selectionChanged\", c);\n    }\n  }), r.subscribe((y) => {\n    !u && y ? m(\"mouseEnterAnnotation\", i.getAnnotation(y)) : u && !y ? m(\"mouseLeaveAnnotation\", i.getAnnotation(u)) : u && y && (m(\"mouseLeaveAnnotation\", i.getAnnotation(u)), m(\"mouseEnterAnnotation\", i.getAnnotation(y))), u = y;\n  }), l == null || l.subscribe((y) => m(\"viewportIntersect\", y.map((E) => i.getAnnotation(E)))), i.observe((y) => {\n    o && (f && clearTimeout(f), f = setTimeout(_, 1e3));\n    const { created: E, deleted: b } = y.changes;\n    (E || []).forEach((A) => m(\"createAnnotation\", A)), (b || []).forEach((A) => m(\"deleteAnnotation\", A)), (y.changes.updated || []).filter((A) => [\n      ...A.bodiesCreated || [],\n      ...A.bodiesDeleted || [],\n      ...A.bodiesUpdated || []\n    ].length > 0).forEach(({ oldValue: A, newValue: L }) => {\n      const D = c.find((R) => R.id === A.id) || A;\n      c = c.map((R) => R.id === A.id ? L : R), m(\"updateAnnotation\", L, D);\n    });\n  }, { origin: G.LOCAL }), i.observe((y) => {\n    if (c) {\n      const E = new Set(c.map((A) => A.id)), b = (y.changes.updated || []).filter(({ newValue: A }) => E.has(A.id)).map(({ newValue: A }) => A);\n      b.length > 0 && (c = c.map((A) => b.find((D) => D.id === A.id) || A));\n    }\n  }, { origin: G.REMOTE });\n  const w = (y) => (E) => {\n    const { created: b, deleted: A, updated: L } = E;\n    (b || []).forEach((D) => m(\"createAnnotation\", D)), (A || []).forEach((D) => m(\"deleteAnnotation\", D)), y ? (L || []).forEach((D) => m(\"updateAnnotation\", D.oldValue, D.newValue)) : (L || []).forEach((D) => m(\"updateAnnotation\", D.newValue, D.oldValue));\n  };\n  return t.on(\"undo\", w(!0)), t.on(\"redo\", w(!1)), { on: h, off: g, emit: m };\n}, eo = (e) => (t) => t.reduce((n, o) => {\n  const { parsed: i, error: s } = e.parse(o);\n  return s ? {\n    parsed: n.parsed,\n    failed: [...n.failed, o]\n  } : i ? {\n    parsed: [...n.parsed, i],\n    failed: n.failed\n  } : {\n    ...n\n  };\n}, { parsed: [], failed: [] }), to = (e, t, n) => {\n  const { store: o, selection: i } = e, s = (w) => {\n    if (n) {\n      const { parsed: y, error: E } = n.parse(w);\n      y ? o.addAnnotation(y, G.REMOTE) : console.error(E);\n    } else\n      o.addAnnotation(w, G.REMOTE);\n  }, r = () => i.clear(), l = () => o.clear(), a = (w) => {\n    const y = o.getAnnotation(w);\n    return n && y ? n.serialize(y) : y;\n  }, c = () => n ? o.all().map(n.serialize) : o.all(), u = () => {\n    var w;\n    const y = (((w = i.selected) == null ? void 0 : w.map((E) => E.id)) || []).map((E) => o.getAnnotation(E)).filter(Boolean);\n    return n ? y.map(n.serialize) : y;\n  }, f = (w) => fetch(w).then((y) => y.json()).then((y) => (g(y), y)), h = (w) => {\n    if (typeof w == \"string\") {\n      const y = o.getAnnotation(w);\n      if (o.deleteAnnotation(w), y)\n        return n ? n.serialize(y) : y;\n    } else {\n      const y = n ? n.parse(w).parsed : w;\n      if (y)\n        return o.deleteAnnotation(y), w;\n    }\n  }, g = (w) => {\n    if (n) {\n      const { parsed: y, failed: E } = eo(n)(w);\n      E.length > 0 && console.warn(`Discarded ${E.length} invalid annotations`, E), o.bulkAddAnnotation(y, !0, G.REMOTE);\n    } else\n      o.bulkAddAnnotation(w, !0, G.REMOTE);\n  }, m = (w) => {\n    w ? i.setSelected(w) : i.clear();\n  }, _ = (w) => {\n    if (n) {\n      const y = n.parse(w).parsed, E = n.serialize(o.getAnnotation(y.id));\n      return o.updateAnnotation(y), E;\n    } else {\n      const y = o.getAnnotation(w.id);\n      return o.updateAnnotation(w), y;\n    }\n  };\n  return {\n    addAnnotation: s,\n    cancelSelected: r,\n    canRedo: t.canRedo,\n    canUndo: t.canUndo,\n    clearAnnotations: l,\n    getAnnotationById: a,\n    getAnnotations: c,\n    getSelected: u,\n    loadAnnotations: f,\n    redo: t.redo,\n    removeAnnotation: h,\n    setAnnotations: g,\n    setSelected: m,\n    undo: t.undo,\n    updateAnnotation: _\n  };\n};\nlet no = (e) => crypto.getRandomValues(new Uint8Array(e)), oo = (e, t, n) => {\n  let o = (2 << Math.log(e.length - 1) / Math.LN2) - 1, i = -~(1.6 * o * t / e.length);\n  return (s = t) => {\n    let r = \"\";\n    for (; ; ) {\n      let l = n(i), a = i;\n      for (; a--; )\n        if (r += e[l[a] & o] || \"\", r.length === s)\n          return r;\n    }\n  };\n}, io = (e, t = 21) => oo(e, t, no), so = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, n) => (n &= 63, n < 36 ? t += n.toString(36) : n < 62 ? t += (n - 26).toString(36).toUpperCase() : n > 62 ? t += \"-\" : t += \"_\", t), \"\");\nconst ro = () => ({ isGuest: !0, id: io(\"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\", 20)() }), lo = (e) => {\n  const t = JSON.stringify(e);\n  let n = 0;\n  for (let o = 0, i = t.length; o < i; o++) {\n    let s = t.charCodeAt(o);\n    n = (n << 5) - n + s, n |= 0;\n  }\n  return `${n}`;\n}, Jt = (e) => e ? typeof e == \"object\" ? { ...e } : e : void 0, ao = (e, t) => (Array.isArray(e) ? e : [e]).map((n) => {\n  const { id: o, type: i, purpose: s, value: r, created: l, creator: a, ...c } = n;\n  return {\n    id: o || `temp-${lo(n)}`,\n    annotation: t,\n    type: i,\n    purpose: s,\n    value: r,\n    created: l ? new Date(l) : void 0,\n    creator: Jt(a),\n    ...c\n  };\n}), co = (e) => e.map((t) => {\n  var n, o;\n  const i = { ...t };\n  return delete i.annotation, (n = i.id) != null && n.startsWith(\"temp-\") && delete i.id, { ...i, created: (o = i.created) == null ? void 0 : o.toISOString() };\n});\nso();\nconst Pi = (e, t = !1) => ({ parse: (i) => fo(i, t), serialize: (i) => uo(i, e) }), fo = (e, t = !1) => {\n  const n = e.id || qt(), {\n    creator: o,\n    created: i,\n    modified: s,\n    body: r,\n    ...l\n  } = e, a = ao(r, n), c = Array.isArray(e.target) ? e.target[0] : e.target, u = Array.isArray(c.selector) ? c.selector[0] : c.selector, f = (u == null ? void 0 : u.type) === \"FragmentSelector\" ? Sn(u, t) : (u == null ? void 0 : u.type) === \"SvgSelector\" ? On(u) : void 0;\n  return f ? {\n    parsed: {\n      ...l,\n      id: n,\n      bodies: a,\n      target: {\n        created: i ? new Date(i) : void 0,\n        creator: Jt(o),\n        updated: s ? new Date(s) : void 0,\n        ...Array.isArray(l.target) ? l.target[0] : l.target,\n        annotation: n,\n        selector: f\n      }\n    }\n  } : {\n    error: Error(`Invalid selector: ${JSON.stringify(u)}`)\n  };\n}, uo = (e, t) => {\n  const {\n    selector: n,\n    creator: o,\n    created: i,\n    updated: s,\n    updatedBy: r,\n    // Excluded from serialization\n    ...l\n  } = e.target, a = n.type == j.RECTANGLE ? Tn(n.geometry) : Bn(n), c = {\n    ...e,\n    \"@context\": \"http://www.w3.org/ns/anno.jsonld\",\n    id: e.id,\n    type: \"Annotation\",\n    body: co(e.bodies),\n    created: i == null ? void 0 : i.toISOString(),\n    creator: o,\n    modified: s == null ? void 0 : s.toISOString(),\n    target: {\n      ...l,\n      source: t,\n      selector: a\n    }\n  };\n  return delete c.bodies, \"annotation\" in c.target && delete c.target.annotation, c;\n};\nfunction wt(e, t, n) {\n  const o = e.slice();\n  return o[10] = t[n], o[12] = n, o;\n}\nfunction bt(e) {\n  let t, n;\n  return t = new Le({\n    props: {\n      x: (\n        /*point*/\n        e[10][0]\n      ),\n      y: (\n        /*point*/\n        e[10][1]\n      ),\n      scale: (\n        /*viewportScale*/\n        e[3]\n      )\n    }\n  }), t.$on(\"pointerdown\", function() {\n    q(\n      /*grab*/\n      e[9](`HANDLE-${/*idx*/\n      e[12]}`)\n    ) && e[9](`HANDLE-${/*idx*/\n    e[12]}`).apply(this, arguments);\n  }), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, i) {\n      e = o;\n      const s = {};\n      i & /*geom*/\n      16 && (s.x = /*point*/\n      e[10][0]), i & /*geom*/\n      16 && (s.y = /*point*/\n      e[10][1]), i & /*viewportScale*/\n      8 && (s.scale = /*viewportScale*/\n      e[3]), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction ho(e) {\n  let t, n, o, i, s, r, l, a, c, u, f, h = Se(\n    /*geom*/\n    e[4].points\n  ), g = [];\n  for (let _ = 0; _ < h.length; _ += 1)\n    g[_] = bt(wt(e, h, _));\n  const m = (_) => C(g[_], 1, 1, () => {\n    g[_] = null;\n  });\n  return {\n    c() {\n      t = U(\"polygon\"), i = oe(), s = U(\"polygon\"), l = oe();\n      for (let _ = 0; _ < g.length; _ += 1)\n        g[_].c();\n      a = ce(), d(t, \"class\", \"a9s-outer\"), d(t, \"style\", n = /*computedStyle*/\n      e[1] ? \"display:none;\" : void 0), d(t, \"points\", o = /*geom*/\n      e[4].points.map(Et).join(\" \")), d(s, \"class\", \"a9s-inner a9s-shape-handle\"), d(\n        s,\n        \"style\",\n        /*computedStyle*/\n        e[1]\n      ), d(s, \"points\", r = /*geom*/\n      e[4].points.map(At).join(\" \"));\n    },\n    m(_, w) {\n      B(_, t, w), B(_, i, w), B(_, s, w), B(_, l, w);\n      for (let y = 0; y < g.length; y += 1)\n        g[y] && g[y].m(_, w);\n      B(_, a, w), c = !0, u || (f = [\n        F(t, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"SHAPE\")\n          ) && e[9](\"SHAPE\").apply(this, arguments);\n        }),\n        F(s, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"SHAPE\")\n          ) && e[9](\"SHAPE\").apply(this, arguments);\n        })\n      ], u = !0);\n    },\n    p(_, w) {\n      if (e = _, (!c || w & /*computedStyle*/\n      2 && n !== (n = /*computedStyle*/\n      e[1] ? \"display:none;\" : void 0)) && d(t, \"style\", n), (!c || w & /*geom*/\n      16 && o !== (o = /*geom*/\n      e[4].points.map(Et).join(\" \"))) && d(t, \"points\", o), (!c || w & /*computedStyle*/\n      2) && d(\n        s,\n        \"style\",\n        /*computedStyle*/\n        e[1]\n      ), (!c || w & /*geom*/\n      16 && r !== (r = /*geom*/\n      e[4].points.map(At).join(\" \"))) && d(s, \"points\", r), w & /*geom, viewportScale, grab*/\n      536) {\n        h = Se(\n          /*geom*/\n          e[4].points\n        );\n        let y;\n        for (y = 0; y < h.length; y += 1) {\n          const E = wt(e, h, y);\n          g[y] ? (g[y].p(E, w), P(g[y], 1)) : (g[y] = bt(E), g[y].c(), P(g[y], 1), g[y].m(a.parentNode, a));\n        }\n        for (re(), y = h.length; y < g.length; y += 1)\n          m(y);\n        le();\n      }\n    },\n    i(_) {\n      if (!c) {\n        for (let w = 0; w < h.length; w += 1)\n          P(g[w]);\n        c = !0;\n      }\n    },\n    o(_) {\n      g = g.filter(Boolean);\n      for (let w = 0; w < g.length; w += 1)\n        C(g[w]);\n      c = !1;\n    },\n    d(_) {\n      _ && (k(t), k(i), k(s), k(l), k(a)), rt(g, _), u = !1, ae(f);\n    }\n  };\n}\nfunction go(e) {\n  let t, n;\n  return t = new Qt({\n    props: {\n      shape: (\n        /*shape*/\n        e[0]\n      ),\n      transform: (\n        /*transform*/\n        e[2]\n      ),\n      editor: (\n        /*editor*/\n        e[5]\n      ),\n      $$slots: {\n        default: [\n          ho,\n          ({ grab: o }) => ({ 9: o }),\n          ({ grab: o }) => o ? 512 : 0\n        ]\n      },\n      $$scope: { ctx: e }\n    }\n  }), t.$on(\n    \"change\",\n    /*change_handler*/\n    e[6]\n  ), t.$on(\n    \"grab\",\n    /*grab_handler*/\n    e[7]\n  ), t.$on(\n    \"release\",\n    /*release_handler*/\n    e[8]\n  ), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, [i]) {\n      const s = {};\n      i & /*shape*/\n      1 && (s.shape = /*shape*/\n      o[0]), i & /*transform*/\n      4 && (s.transform = /*transform*/\n      o[2]), i & /*$$scope, geom, viewportScale, grab, computedStyle*/\n      8730 && (s.$$scope = { dirty: i, ctx: o }), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nconst Et = (e) => e.join(\",\"), At = (e) => e.join(\",\");\nfunction mo(e, t, n) {\n  let o, { shape: i } = t, { computedStyle: s } = t, { transform: r } = t, { viewportScale: l = 1 } = t;\n  const a = (h, g, m) => {\n    let _;\n    const w = h.geometry;\n    g === \"SHAPE\" ? _ = w.points.map(([E, b]) => [E + m[0], b + m[1]]) : _ = w.points.map(([E, b], A) => g === `HANDLE-${A}` ? [E + m[0], b + m[1]] : [E, b]);\n    const y = Fe(_);\n    return { ...h, geometry: { points: _, bounds: y } };\n  };\n  function c(h) {\n    ue.call(this, e, h);\n  }\n  function u(h) {\n    ue.call(this, e, h);\n  }\n  function f(h) {\n    ue.call(this, e, h);\n  }\n  return e.$$set = (h) => {\n    \"shape\" in h && n(0, i = h.shape), \"computedStyle\" in h && n(1, s = h.computedStyle), \"transform\" in h && n(2, r = h.transform), \"viewportScale\" in h && n(3, l = h.viewportScale);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*shape*/\n    1 && n(4, o = i.geometry);\n  }, [\n    i,\n    s,\n    r,\n    l,\n    o,\n    a,\n    c,\n    u,\n    f\n  ];\n}\nclass po extends te {\n  constructor(t) {\n    super(), ee(this, t, mo, go, W, {\n      shape: 0,\n      computedStyle: 1,\n      transform: 2,\n      viewportScale: 3\n    });\n  }\n}\nconst Qe = (e, t) => {\n  const n = Math.abs(t[0] - e[0]), o = Math.abs(t[1] - e[1]);\n  return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2));\n}, _e = [];\nfunction yo(e, t = V) {\n  let n;\n  const o = /* @__PURE__ */ new Set();\n  function i(l) {\n    if (W(e, l) && (e = l, n)) {\n      const a = !_e.length;\n      for (const c of o)\n        c[1](), _e.push(c, e);\n      if (a) {\n        for (let c = 0; c < _e.length; c += 2)\n          _e[c][0](_e[c + 1]);\n        _e.length = 0;\n      }\n    }\n  }\n  function s(l) {\n    i(l(e));\n  }\n  function r(l, a = V) {\n    const c = [l, a];\n    return o.add(c), o.size === 1 && (n = t(i, s) || V), l(e), () => {\n      o.delete(c), o.size === 0 && n && (n(), n = null);\n    };\n  }\n  return { set: i, update: s, subscribe: r };\n}\nconst _o = (e, t) => {\n  const { naturalWidth: n, naturalHeight: o } = e;\n  if (!n && !o) {\n    const { width: i, height: s } = e;\n    t.setAttribute(\"viewBox\", `0 0 ${i} ${s}`), e.addEventListener(\"load\", (r) => {\n      const l = r.target;\n      t.setAttribute(\"viewBox\", `0 0 ${l.naturalWidth} ${l.naturalHeight}`);\n    });\n  } else\n    t.setAttribute(\"viewBox\", `0 0 ${n} ${o}`);\n}, wo = (e, t) => {\n  _o(e, t);\n  const { subscribe: n, set: o } = yo(1);\n  let i;\n  return window.ResizeObserver && (i = new ResizeObserver(() => {\n    const r = t.getBoundingClientRect(), { width: l, height: a } = t.viewBox.baseVal, c = Math.max(\n      r.width / l,\n      r.height / a\n    );\n    o(c);\n  }), i.observe(t.parentElement)), { destroy: () => {\n    i && i.disconnect();\n  }, subscribe: n };\n}, bo = \"ontouchstart\" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;\nfunction Eo(e) {\n  let t, n, o, i, s, r;\n  return {\n    c() {\n      t = U(\"rect\"), d(t, \"class\", n = Ge(`a9s-handle ${/*$$props*/\n      e[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\"), d(t, \"x\", o = /*x*/\n      e[0] - /*handleSize*/\n      e[5] / 2), d(t, \"y\", i = /*y*/\n      e[1] - /*handleSize*/\n      e[5] / 2), d(\n        t,\n        \"width\",\n        /*handleSize*/\n        e[5]\n      ), d(\n        t,\n        \"height\",\n        /*handleSize*/\n        e[5]\n      );\n    },\n    m(l, a) {\n      B(l, t, a), s || (r = F(\n        t,\n        \"pointerdown\",\n        /*pointerdown_handler_2*/\n        e[11]\n      ), s = !0);\n    },\n    p(l, a) {\n      a & /*$$props*/\n      256 && n !== (n = Ge(`a9s-handle ${/*$$props*/\n      l[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\") && d(t, \"class\", n), a & /*x, handleSize*/\n      33 && o !== (o = /*x*/\n      l[0] - /*handleSize*/\n      l[5] / 2) && d(t, \"x\", o), a & /*y, handleSize*/\n      34 && i !== (i = /*y*/\n      l[1] - /*handleSize*/\n      l[5] / 2) && d(t, \"y\", i), a & /*handleSize*/\n      32 && d(\n        t,\n        \"width\",\n        /*handleSize*/\n        l[5]\n      ), a & /*handleSize*/\n      32 && d(\n        t,\n        \"height\",\n        /*handleSize*/\n        l[5]\n      );\n    },\n    d(l) {\n      l && k(t), s = !1, r();\n    }\n  };\n}\nfunction Ao(e) {\n  let t, n, o, i, s, r, l, a, c;\n  return {\n    c() {\n      t = U(\"g\"), n = U(\"circle\"), i = U(\"rect\"), d(\n        n,\n        \"cx\",\n        /*x*/\n        e[0]\n      ), d(\n        n,\n        \"cy\",\n        /*y*/\n        e[1]\n      ), d(n, \"r\", o = /*radius*/\n      e[3] / /*scale*/\n      e[2]), d(n, \"class\", \"a9s-touch-halo svelte-1sgkh33\"), ze(\n        n,\n        \"touched\",\n        /*touched*/\n        e[4]\n      ), d(i, \"class\", s = Ge(`a9s-handle ${/*$$props*/\n      e[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\"), d(i, \"x\", r = /*x*/\n      e[0] - /*handleSize*/\n      e[5] / 2), d(i, \"y\", l = /*y*/\n      e[1] - /*handleSize*/\n      e[5] / 2), d(\n        i,\n        \"width\",\n        /*handleSize*/\n        e[5]\n      ), d(\n        i,\n        \"height\",\n        /*handleSize*/\n        e[5]\n      ), d(t, \"class\", \"a9s-touch-handle\");\n    },\n    m(u, f) {\n      B(u, t, f), se(t, n), se(t, i), a || (c = [\n        F(\n          n,\n          \"pointerdown\",\n          /*pointerdown_handler*/\n          e[10]\n        ),\n        F(\n          n,\n          \"pointerdown\",\n          /*onPointerDown*/\n          e[6]\n        ),\n        F(\n          n,\n          \"pointerup\",\n          /*onPointerUp*/\n          e[7]\n        ),\n        F(\n          i,\n          \"pointerdown\",\n          /*pointerdown_handler_1*/\n          e[9]\n        ),\n        F(\n          i,\n          \"pointerdown\",\n          /*onPointerDown*/\n          e[6]\n        ),\n        F(\n          i,\n          \"pointerup\",\n          /*onPointerUp*/\n          e[7]\n        )\n      ], a = !0);\n    },\n    p(u, f) {\n      f & /*x*/\n      1 && d(\n        n,\n        \"cx\",\n        /*x*/\n        u[0]\n      ), f & /*y*/\n      2 && d(\n        n,\n        \"cy\",\n        /*y*/\n        u[1]\n      ), f & /*radius, scale*/\n      12 && o !== (o = /*radius*/\n      u[3] / /*scale*/\n      u[2]) && d(n, \"r\", o), f & /*touched*/\n      16 && ze(\n        n,\n        \"touched\",\n        /*touched*/\n        u[4]\n      ), f & /*$$props*/\n      256 && s !== (s = Ge(`a9s-handle ${/*$$props*/\n      u[8].class || \"\"}`.trim()) + \" svelte-1sgkh33\") && d(i, \"class\", s), f & /*x, handleSize*/\n      33 && r !== (r = /*x*/\n      u[0] - /*handleSize*/\n      u[5] / 2) && d(i, \"x\", r), f & /*y, handleSize*/\n      34 && l !== (l = /*y*/\n      u[1] - /*handleSize*/\n      u[5] / 2) && d(i, \"y\", l), f & /*handleSize*/\n      32 && d(\n        i,\n        \"width\",\n        /*handleSize*/\n        u[5]\n      ), f & /*handleSize*/\n      32 && d(\n        i,\n        \"height\",\n        /*handleSize*/\n        u[5]\n      );\n    },\n    d(u) {\n      u && k(t), a = !1, ae(c);\n    }\n  };\n}\nfunction So(e) {\n  let t;\n  function n(s, r) {\n    return bo ? Ao : Eo;\n  }\n  let i = n()(e);\n  return {\n    c() {\n      i.c(), t = ce();\n    },\n    m(s, r) {\n      i.m(s, r), B(s, t, r);\n    },\n    p(s, [r]) {\n      i.p(s, r);\n    },\n    i: V,\n    o: V,\n    d(s) {\n      s && k(t), i.d(s);\n    }\n  };\n}\nfunction To(e, t, n) {\n  let o, { x: i } = t, { y: s } = t, { scale: r } = t, { radius: l = 30 } = t, a = !1;\n  const c = (m) => {\n    m.pointerType === \"touch\" && n(4, a = !0);\n  }, u = () => n(4, a = !1);\n  function f(m) {\n    ue.call(this, e, m);\n  }\n  function h(m) {\n    ue.call(this, e, m);\n  }\n  function g(m) {\n    ue.call(this, e, m);\n  }\n  return e.$$set = (m) => {\n    n(8, t = nt(nt({}, t), gt(m))), \"x\" in m && n(0, i = m.x), \"y\" in m && n(1, s = m.y), \"scale\" in m && n(2, r = m.scale), \"radius\" in m && n(3, l = m.radius);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*scale*/\n    4 && n(5, o = 10 / r);\n  }, t = gt(t), [\n    i,\n    s,\n    r,\n    l,\n    a,\n    o,\n    c,\n    u,\n    t,\n    f,\n    h,\n    g\n  ];\n}\nclass Le extends te {\n  constructor(t) {\n    super(), ee(this, t, To, So, W, { x: 0, y: 1, scale: 2, radius: 3 });\n  }\n}\nfunction Mo(e) {\n  let t, n, o, i, s, r, l, a, c, u, f, h, g, m, _, w, y, E, b, A, L, D, R, p, T, S, M, O, X, Z, ge, me, Me, ie, I, z, H, J, fe, ne, N, qe, ut;\n  return ie = new Le({\n    props: {\n      class: \"a9s-corner-handle-topleft\",\n      x: (\n        /*geom*/\n        e[4].x\n      ),\n      y: (\n        /*geom*/\n        e[4].y\n      ),\n      scale: (\n        /*viewportScale*/\n        e[3]\n      )\n    }\n  }), ie.$on(\"pointerdown\", function() {\n    q(\n      /*grab*/\n      e[9](\"TOP_LEFT\")\n    ) && e[9](\"TOP_LEFT\").apply(this, arguments);\n  }), z = new Le({\n    props: {\n      class: \"a9s-corner-handle-topright\",\n      x: (\n        /*geom*/\n        e[4].x + /*geom*/\n        e[4].w\n      ),\n      y: (\n        /*geom*/\n        e[4].y\n      ),\n      scale: (\n        /*viewportScale*/\n        e[3]\n      )\n    }\n  }), z.$on(\"pointerdown\", function() {\n    q(\n      /*grab*/\n      e[9](\"TOP_RIGHT\")\n    ) && e[9](\"TOP_RIGHT\").apply(this, arguments);\n  }), J = new Le({\n    props: {\n      class: \"a9s-corner-handle-bottomright\",\n      x: (\n        /*geom*/\n        e[4].x + /*geom*/\n        e[4].w\n      ),\n      y: (\n        /*geom*/\n        e[4].y + /*geom*/\n        e[4].h\n      ),\n      scale: (\n        /*viewportScale*/\n        e[3]\n      )\n    }\n  }), J.$on(\"pointerdown\", function() {\n    q(\n      /*grab*/\n      e[9](\"BOTTOM_RIGHT\")\n    ) && e[9](\"BOTTOM_RIGHT\").apply(this, arguments);\n  }), ne = new Le({\n    props: {\n      class: \"a9s-corner-handle-bottomleft\",\n      x: (\n        /*geom*/\n        e[4].x\n      ),\n      y: (\n        /*geom*/\n        e[4].y + /*geom*/\n        e[4].h\n      ),\n      scale: (\n        /*viewportScale*/\n        e[3]\n      )\n    }\n  }), ne.$on(\"pointerdown\", function() {\n    q(\n      /*grab*/\n      e[9](\"BOTTOM_LEFT\")\n    ) && e[9](\"BOTTOM_LEFT\").apply(this, arguments);\n  }), {\n    c() {\n      t = U(\"rect\"), l = oe(), a = U(\"rect\"), g = oe(), m = U(\"rect\"), E = oe(), b = U(\"rect\"), R = oe(), p = U(\"rect\"), O = oe(), X = U(\"rect\"), Me = oe(), $(ie.$$.fragment), I = oe(), $(z.$$.fragment), H = oe(), $(J.$$.fragment), fe = oe(), $(ne.$$.fragment), d(t, \"class\", \"a9s-outer\"), d(t, \"style\", n = /*computedStyle*/\n      e[1] ? \"display:none;\" : void 0), d(t, \"x\", o = /*geom*/\n      e[4].x), d(t, \"y\", i = /*geom*/\n      e[4].y), d(t, \"width\", s = /*geom*/\n      e[4].w), d(t, \"height\", r = /*geom*/\n      e[4].h), d(a, \"class\", \"a9s-inner a9s-shape-handle\"), d(\n        a,\n        \"style\",\n        /*computedStyle*/\n        e[1]\n      ), d(a, \"x\", c = /*geom*/\n      e[4].x), d(a, \"y\", u = /*geom*/\n      e[4].y), d(a, \"width\", f = /*geom*/\n      e[4].w), d(a, \"height\", h = /*geom*/\n      e[4].h), d(m, \"class\", \"a9s-edge-handle a9s-edge-handle-top\"), d(m, \"x\", _ = /*geom*/\n      e[4].x), d(m, \"y\", w = /*geom*/\n      e[4].y), d(m, \"height\", 1), d(m, \"width\", y = /*geom*/\n      e[4].w), d(b, \"class\", \"a9s-edge-handle a9s-edge-handle-right\"), d(b, \"x\", A = /*geom*/\n      e[4].x + /*geom*/\n      e[4].w), d(b, \"y\", L = /*geom*/\n      e[4].y), d(b, \"height\", D = /*geom*/\n      e[4].h), d(b, \"width\", 1), d(p, \"class\", \"a9s-edge-handle a9s-edge-handle-bottom\"), d(p, \"x\", T = /*geom*/\n      e[4].x), d(p, \"y\", S = /*geom*/\n      e[4].y + /*geom*/\n      e[4].h), d(p, \"height\", 1), d(p, \"width\", M = /*geom*/\n      e[4].w), d(X, \"class\", \"a9s-edge-handle a9s-edge-handle-left\"), d(X, \"x\", Z = /*geom*/\n      e[4].x), d(X, \"y\", ge = /*geom*/\n      e[4].y), d(X, \"height\", me = /*geom*/\n      e[4].h), d(X, \"width\", 1);\n    },\n    m(Y, v) {\n      B(Y, t, v), B(Y, l, v), B(Y, a, v), B(Y, g, v), B(Y, m, v), B(Y, E, v), B(Y, b, v), B(Y, R, v), B(Y, p, v), B(Y, O, v), B(Y, X, v), B(Y, Me, v), Q(ie, Y, v), B(Y, I, v), Q(z, Y, v), B(Y, H, v), Q(J, Y, v), B(Y, fe, v), Q(ne, Y, v), N = !0, qe || (ut = [\n        F(t, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"SHAPE\")\n          ) && e[9](\"SHAPE\").apply(this, arguments);\n        }),\n        F(a, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"SHAPE\")\n          ) && e[9](\"SHAPE\").apply(this, arguments);\n        }),\n        F(m, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"TOP\")\n          ) && e[9](\"TOP\").apply(this, arguments);\n        }),\n        F(b, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"RIGHT\")\n          ) && e[9](\"RIGHT\").apply(this, arguments);\n        }),\n        F(p, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"BOTTOM\")\n          ) && e[9](\"BOTTOM\").apply(this, arguments);\n        }),\n        F(X, \"pointerdown\", function() {\n          q(\n            /*grab*/\n            e[9](\"LEFT\")\n          ) && e[9](\"LEFT\").apply(this, arguments);\n        })\n      ], qe = !0);\n    },\n    p(Y, v) {\n      e = Y, (!N || v & /*computedStyle*/\n      2 && n !== (n = /*computedStyle*/\n      e[1] ? \"display:none;\" : void 0)) && d(t, \"style\", n), (!N || v & /*geom*/\n      16 && o !== (o = /*geom*/\n      e[4].x)) && d(t, \"x\", o), (!N || v & /*geom*/\n      16 && i !== (i = /*geom*/\n      e[4].y)) && d(t, \"y\", i), (!N || v & /*geom*/\n      16 && s !== (s = /*geom*/\n      e[4].w)) && d(t, \"width\", s), (!N || v & /*geom*/\n      16 && r !== (r = /*geom*/\n      e[4].h)) && d(t, \"height\", r), (!N || v & /*computedStyle*/\n      2) && d(\n        a,\n        \"style\",\n        /*computedStyle*/\n        e[1]\n      ), (!N || v & /*geom*/\n      16 && c !== (c = /*geom*/\n      e[4].x)) && d(a, \"x\", c), (!N || v & /*geom*/\n      16 && u !== (u = /*geom*/\n      e[4].y)) && d(a, \"y\", u), (!N || v & /*geom*/\n      16 && f !== (f = /*geom*/\n      e[4].w)) && d(a, \"width\", f), (!N || v & /*geom*/\n      16 && h !== (h = /*geom*/\n      e[4].h)) && d(a, \"height\", h), (!N || v & /*geom*/\n      16 && _ !== (_ = /*geom*/\n      e[4].x)) && d(m, \"x\", _), (!N || v & /*geom*/\n      16 && w !== (w = /*geom*/\n      e[4].y)) && d(m, \"y\", w), (!N || v & /*geom*/\n      16 && y !== (y = /*geom*/\n      e[4].w)) && d(m, \"width\", y), (!N || v & /*geom*/\n      16 && A !== (A = /*geom*/\n      e[4].x + /*geom*/\n      e[4].w)) && d(b, \"x\", A), (!N || v & /*geom*/\n      16 && L !== (L = /*geom*/\n      e[4].y)) && d(b, \"y\", L), (!N || v & /*geom*/\n      16 && D !== (D = /*geom*/\n      e[4].h)) && d(b, \"height\", D), (!N || v & /*geom*/\n      16 && T !== (T = /*geom*/\n      e[4].x)) && d(p, \"x\", T), (!N || v & /*geom*/\n      16 && S !== (S = /*geom*/\n      e[4].y + /*geom*/\n      e[4].h)) && d(p, \"y\", S), (!N || v & /*geom*/\n      16 && M !== (M = /*geom*/\n      e[4].w)) && d(p, \"width\", M), (!N || v & /*geom*/\n      16 && Z !== (Z = /*geom*/\n      e[4].x)) && d(X, \"x\", Z), (!N || v & /*geom*/\n      16 && ge !== (ge = /*geom*/\n      e[4].y)) && d(X, \"y\", ge), (!N || v & /*geom*/\n      16 && me !== (me = /*geom*/\n      e[4].h)) && d(X, \"height\", me);\n      const Ye = {};\n      v & /*geom*/\n      16 && (Ye.x = /*geom*/\n      e[4].x), v & /*geom*/\n      16 && (Ye.y = /*geom*/\n      e[4].y), v & /*viewportScale*/\n      8 && (Ye.scale = /*viewportScale*/\n      e[3]), ie.$set(Ye);\n      const De = {};\n      v & /*geom*/\n      16 && (De.x = /*geom*/\n      e[4].x + /*geom*/\n      e[4].w), v & /*geom*/\n      16 && (De.y = /*geom*/\n      e[4].y), v & /*viewportScale*/\n      8 && (De.scale = /*viewportScale*/\n      e[3]), z.$set(De);\n      const Xe = {};\n      v & /*geom*/\n      16 && (Xe.x = /*geom*/\n      e[4].x + /*geom*/\n      e[4].w), v & /*geom*/\n      16 && (Xe.y = /*geom*/\n      e[4].y + /*geom*/\n      e[4].h), v & /*viewportScale*/\n      8 && (Xe.scale = /*viewportScale*/\n      e[3]), J.$set(Xe);\n      const Ce = {};\n      v & /*geom*/\n      16 && (Ce.x = /*geom*/\n      e[4].x), v & /*geom*/\n      16 && (Ce.y = /*geom*/\n      e[4].y + /*geom*/\n      e[4].h), v & /*viewportScale*/\n      8 && (Ce.scale = /*viewportScale*/\n      e[3]), ne.$set(Ce);\n    },\n    i(Y) {\n      N || (P(ie.$$.fragment, Y), P(z.$$.fragment, Y), P(J.$$.fragment, Y), P(ne.$$.fragment, Y), N = !0);\n    },\n    o(Y) {\n      C(ie.$$.fragment, Y), C(z.$$.fragment, Y), C(J.$$.fragment, Y), C(ne.$$.fragment, Y), N = !1;\n    },\n    d(Y) {\n      Y && (k(t), k(l), k(a), k(g), k(m), k(E), k(b), k(R), k(p), k(O), k(X), k(Me), k(I), k(H), k(fe)), x(ie, Y), x(z, Y), x(J, Y), x(ne, Y), qe = !1, ae(ut);\n    }\n  };\n}\nfunction vo(e) {\n  let t, n;\n  return t = new Qt({\n    props: {\n      shape: (\n        /*shape*/\n        e[0]\n      ),\n      transform: (\n        /*transform*/\n        e[2]\n      ),\n      editor: (\n        /*editor*/\n        e[5]\n      ),\n      $$slots: {\n        default: [\n          Mo,\n          ({ grab: o }) => ({ 9: o }),\n          ({ grab: o }) => o ? 512 : 0\n        ]\n      },\n      $$scope: { ctx: e }\n    }\n  }), t.$on(\n    \"grab\",\n    /*grab_handler*/\n    e[6]\n  ), t.$on(\n    \"change\",\n    /*change_handler*/\n    e[7]\n  ), t.$on(\n    \"release\",\n    /*release_handler*/\n    e[8]\n  ), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, [i]) {\n      const s = {};\n      i & /*shape*/\n      1 && (s.shape = /*shape*/\n      o[0]), i & /*transform*/\n      4 && (s.transform = /*transform*/\n      o[2]), i & /*$$scope, geom, viewportScale, grab, computedStyle*/\n      1562 && (s.$$scope = { dirty: i, ctx: o }), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction Lo(e, t, n) {\n  let o, { shape: i } = t, { computedStyle: s } = t, { transform: r } = t, { viewportScale: l = 1 } = t;\n  const a = (h, g, m) => {\n    const _ = h.geometry.bounds;\n    let [w, y] = [_.minX, _.minY], [E, b] = [_.maxX, _.maxY];\n    const [A, L] = m;\n    if (g === \"SHAPE\")\n      w += A, E += A, y += L, b += L;\n    else {\n      switch (g) {\n        case \"TOP\":\n        case \"TOP_LEFT\":\n        case \"TOP_RIGHT\": {\n          y += L;\n          break;\n        }\n        case \"BOTTOM\":\n        case \"BOTTOM_LEFT\":\n        case \"BOTTOM_RIGHT\": {\n          b += L;\n          break;\n        }\n      }\n      switch (g) {\n        case \"LEFT\":\n        case \"TOP_LEFT\":\n        case \"BOTTOM_LEFT\": {\n          w += A;\n          break;\n        }\n        case \"RIGHT\":\n        case \"TOP_RIGHT\":\n        case \"BOTTOM_RIGHT\": {\n          E += A;\n          break;\n        }\n      }\n    }\n    const D = Math.min(w, E), R = Math.min(y, b), p = Math.abs(E - w), T = Math.abs(b - y);\n    return {\n      ...h,\n      geometry: {\n        x: D,\n        y: R,\n        w: p,\n        h: T,\n        bounds: {\n          minX: D,\n          minY: R,\n          maxX: D + p,\n          maxY: R + T\n        }\n      }\n    };\n  };\n  function c(h) {\n    ue.call(this, e, h);\n  }\n  function u(h) {\n    ue.call(this, e, h);\n  }\n  function f(h) {\n    ue.call(this, e, h);\n  }\n  return e.$$set = (h) => {\n    \"shape\" in h && n(0, i = h.shape), \"computedStyle\" in h && n(1, s = h.computedStyle), \"transform\" in h && n(2, r = h.transform), \"viewportScale\" in h && n(3, l = h.viewportScale);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*shape*/\n    1 && n(4, o = i.geometry);\n  }, [\n    i,\n    s,\n    r,\n    l,\n    o,\n    a,\n    c,\n    u,\n    f\n  ];\n}\nclass ko extends te {\n  constructor(t) {\n    super(), ee(this, t, Lo, vo, W, {\n      shape: 0,\n      computedStyle: 1,\n      transform: 2,\n      viewportScale: 3\n    });\n  }\n}\nconst Zt = /* @__PURE__ */ new Map([\n  [j.RECTANGLE, ko],\n  [j.POLYGON, po]\n]), Oo = (e) => Zt.get(e.type), Bo = (e, t) => Zt.set(e, t), Io = (e) => ({}), St = (e) => ({ grab: (\n  /*onGrab*/\n  e[0]\n) });\nfunction Po(e) {\n  let t, n, o, i;\n  const s = (\n    /*#slots*/\n    e[7].default\n  ), r = rn(\n    s,\n    e,\n    /*$$scope*/\n    e[6],\n    St\n  );\n  return {\n    c() {\n      t = U(\"g\"), r && r.c(), d(t, \"class\", \"a9s-annotation selected\");\n    },\n    m(l, a) {\n      B(l, t, a), r && r.m(t, null), n = !0, o || (i = [\n        F(\n          t,\n          \"pointerup\",\n          /*onRelease*/\n          e[2]\n        ),\n        F(\n          t,\n          \"pointermove\",\n          /*onPointerMove*/\n          e[1]\n        )\n      ], o = !0);\n    },\n    p(l, [a]) {\n      r && r.p && (!n || a & /*$$scope*/\n      64) && an(\n        r,\n        s,\n        l,\n        /*$$scope*/\n        l[6],\n        n ? ln(\n          s,\n          /*$$scope*/\n          l[6],\n          a,\n          Io\n        ) : cn(\n          /*$$scope*/\n          l[6]\n        ),\n        St\n      );\n    },\n    i(l) {\n      n || (P(r, l), n = !0);\n    },\n    o(l) {\n      C(r, l), n = !1;\n    },\n    d(l) {\n      l && k(t), r && r.d(l), o = !1, ae(i);\n    }\n  };\n}\nfunction Yo(e, t, n) {\n  let { $$slots: o = {}, $$scope: i } = t;\n  const s = Te();\n  let { shape: r } = t, { editor: l } = t, { transform: a } = t, c, u, f;\n  const h = (_) => (w) => {\n    c = _, u = a.elementToImage(w.offsetX, w.offsetY), f = r, w.target.setPointerCapture(w.pointerId), s(\"grab\", w);\n  }, g = (_) => {\n    if (c) {\n      const [w, y] = a.elementToImage(_.offsetX, _.offsetY), E = [w - u[0], y - u[1]];\n      n(3, r = l(f, c, E)), s(\"change\", r);\n    }\n  }, m = (_) => {\n    _.target.releasePointerCapture(_.pointerId), c = void 0, f = r, s(\"release\", _);\n  };\n  return e.$$set = (_) => {\n    \"shape\" in _ && n(3, r = _.shape), \"editor\" in _ && n(4, l = _.editor), \"transform\" in _ && n(5, a = _.transform), \"$$scope\" in _ && n(6, i = _.$$scope);\n  }, [h, g, m, r, l, a, i, o];\n}\nclass Qt extends te {\n  constructor(t) {\n    super(), ee(this, t, Yo, Po, W, { shape: 3, editor: 4, transform: 5 });\n  }\n}\nconst je = (e, t) => {\n  const n = typeof t == \"function\" ? t(e) : t;\n  if (n) {\n    const { fill: o, fillOpacity: i } = n;\n    let s = \"\";\n    return o && (s += `fill:${o};stroke:${o};`), s += `fill-opacity:${i || \"0.25\"};`, s;\n  }\n};\nfunction Do(e, t, n) {\n  let o;\n  const i = Te();\n  let { annotation: s } = t, { editor: r } = t, { style: l } = t, { target: a } = t, { transform: c } = t, { viewportScale: u } = t, f;\n  return Pe(() => (n(6, f = new r({\n    target: a,\n    props: {\n      shape: s.target.selector,\n      computedStyle: o,\n      transform: c,\n      viewportScale: u\n    }\n  })), f.$on(\"change\", (h) => {\n    f.$$set({ shape: h.detail }), i(\"change\", h.detail);\n  }), f.$on(\"grab\", (h) => i(\"grab\", h.detail)), f.$on(\"release\", (h) => i(\"release\", h.detail)), () => {\n    f.$destroy();\n  })), e.$$set = (h) => {\n    \"annotation\" in h && n(0, s = h.annotation), \"editor\" in h && n(1, r = h.editor), \"style\" in h && n(2, l = h.style), \"target\" in h && n(3, a = h.target), \"transform\" in h && n(4, c = h.transform), \"viewportScale\" in h && n(5, u = h.viewportScale);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*annotation, style*/\n    5 && (o = je(s, l)), e.$$.dirty & /*annotation, editorComponent*/\n    65 && s && (f == null || f.$set({ shape: s.target.selector })), e.$$.dirty & /*editorComponent, transform*/\n    80 && f && f.$set({ transform: c }), e.$$.dirty & /*editorComponent, viewportScale*/\n    96 && f && f.$set({ viewportScale: u });\n  }, [s, r, l, a, c, u, f];\n}\nclass Xo extends te {\n  constructor(t) {\n    super(), ee(this, t, Do, null, W, {\n      annotation: 0,\n      editor: 1,\n      style: 2,\n      target: 3,\n      transform: 4,\n      viewportScale: 5\n    });\n  }\n}\nfunction Co(e, t, n) {\n  const o = Te();\n  let { drawingMode: i } = t, { target: s } = t, { tool: r } = t, { transform: l } = t, { viewportScale: a } = t, c;\n  return Pe(() => {\n    const u = s.closest(\"svg\"), f = [], h = (g, m, _) => {\n      u == null || u.addEventListener(g, m, _), f.push(() => u == null ? void 0 : u.removeEventListener(g, m, _));\n    };\n    return n(5, c = new r({\n      target: s,\n      props: {\n        addEventListener: h,\n        drawingMode: i,\n        transform: l,\n        viewportScale: a\n      }\n    })), c.$on(\"create\", (g) => o(\"create\", g.detail)), () => {\n      f.forEach((g) => g()), c.$destroy();\n    };\n  }), e.$$set = (u) => {\n    \"drawingMode\" in u && n(0, i = u.drawingMode), \"target\" in u && n(1, s = u.target), \"tool\" in u && n(2, r = u.tool), \"transform\" in u && n(3, l = u.transform), \"viewportScale\" in u && n(4, a = u.viewportScale);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*toolComponent, transform*/\n    40 && c && c.$set({ transform: l }), e.$$.dirty & /*toolComponent, viewportScale*/\n    48 && c && c.$set({ viewportScale: a });\n  }, [i, s, r, l, a, c];\n}\nclass Ro extends te {\n  constructor(t) {\n    super(), ee(this, t, Co, null, W, {\n      drawingMode: 0,\n      target: 1,\n      tool: 2,\n      transform: 3,\n      viewportScale: 4\n    });\n  }\n}\nfunction Tt(e) {\n  let t, n;\n  return {\n    c() {\n      t = U(\"rect\"), n = U(\"rect\"), d(t, \"class\", \"a9s-outer\"), d(\n        t,\n        \"x\",\n        /*x*/\n        e[1]\n      ), d(\n        t,\n        \"y\",\n        /*y*/\n        e[2]\n      ), d(\n        t,\n        \"width\",\n        /*w*/\n        e[3]\n      ), d(\n        t,\n        \"height\",\n        /*h*/\n        e[4]\n      ), d(n, \"class\", \"a9s-inner\"), d(\n        n,\n        \"x\",\n        /*x*/\n        e[1]\n      ), d(\n        n,\n        \"y\",\n        /*y*/\n        e[2]\n      ), d(\n        n,\n        \"width\",\n        /*w*/\n        e[3]\n      ), d(\n        n,\n        \"height\",\n        /*h*/\n        e[4]\n      );\n    },\n    m(o, i) {\n      B(o, t, i), B(o, n, i);\n    },\n    p(o, i) {\n      i & /*x*/\n      2 && d(\n        t,\n        \"x\",\n        /*x*/\n        o[1]\n      ), i & /*y*/\n      4 && d(\n        t,\n        \"y\",\n        /*y*/\n        o[2]\n      ), i & /*w*/\n      8 && d(\n        t,\n        \"width\",\n        /*w*/\n        o[3]\n      ), i & /*h*/\n      16 && d(\n        t,\n        \"height\",\n        /*h*/\n        o[4]\n      ), i & /*x*/\n      2 && d(\n        n,\n        \"x\",\n        /*x*/\n        o[1]\n      ), i & /*y*/\n      4 && d(\n        n,\n        \"y\",\n        /*y*/\n        o[2]\n      ), i & /*w*/\n      8 && d(\n        n,\n        \"width\",\n        /*w*/\n        o[3]\n      ), i & /*h*/\n      16 && d(\n        n,\n        \"height\",\n        /*h*/\n        o[4]\n      );\n    },\n    d(o) {\n      o && (k(t), k(n));\n    }\n  };\n}\nfunction Uo(e) {\n  let t, n = (\n    /*origin*/\n    e[0] && Tt(e)\n  );\n  return {\n    c() {\n      t = U(\"g\"), n && n.c(), d(t, \"class\", \"a9s-annotation a9s-rubberband\");\n    },\n    m(o, i) {\n      B(o, t, i), n && n.m(t, null);\n    },\n    p(o, [i]) {\n      /*origin*/\n      o[0] ? n ? n.p(o, i) : (n = Tt(o), n.c(), n.m(t, null)) : n && (n.d(1), n = null);\n    },\n    i: V,\n    o: V,\n    d(o) {\n      o && k(t), n && n.d();\n    }\n  };\n}\nfunction No(e, t, n) {\n  const o = Te();\n  let { addEventListener: i } = t, { drawingMode: s } = t, { transform: r } = t, l, a, c, u, f, h, g;\n  const m = (E) => {\n    const b = E;\n    l = performance.now(), s === \"drag\" && (n(0, a = r.elementToImage(b.offsetX, b.offsetY)), c = a, n(1, u = a[0]), n(2, f = a[1]), n(3, h = 1), n(4, g = 1));\n  }, _ = (E) => {\n    const b = E;\n    a && (c = r.elementToImage(b.offsetX, b.offsetY), n(1, u = Math.min(c[0], a[0])), n(2, f = Math.min(c[1], a[1])), n(3, h = Math.abs(c[0] - a[0])), n(4, g = Math.abs(c[1] - a[1])));\n  }, w = (E) => {\n    const b = E, A = performance.now() - l;\n    if (s === \"click\") {\n      if (A > 300)\n        return;\n      b.stopPropagation(), a ? y() : (n(0, a = r.elementToImage(b.offsetX, b.offsetY)), c = a, n(1, u = a[0]), n(2, f = a[1]), n(3, h = 1), n(4, g = 1));\n    } else\n      a && (A > 300 || h * g > 100 ? (b.stopPropagation(), y()) : (n(0, a = void 0), c = void 0));\n  }, y = () => {\n    if (h * g > 15) {\n      const E = {\n        type: j.RECTANGLE,\n        geometry: {\n          bounds: {\n            minX: u,\n            minY: f,\n            maxX: u + h,\n            maxY: f + g\n          },\n          x: u,\n          y: f,\n          w: h,\n          h: g\n        }\n      };\n      o(\"create\", E);\n    }\n    n(0, a = void 0), c = void 0;\n  };\n  return Pe(() => {\n    i(\"pointerdown\", m), i(\"pointermove\", _), i(\"pointerup\", w, !0);\n  }), e.$$set = (E) => {\n    \"addEventListener\" in E && n(5, i = E.addEventListener), \"drawingMode\" in E && n(6, s = E.drawingMode), \"transform\" in E && n(7, r = E.transform);\n  }, [a, u, f, h, g, i, s, r];\n}\nclass Vo extends te {\n  constructor(t) {\n    super(), ee(this, t, No, Uo, W, {\n      addEventListener: 5,\n      drawingMode: 6,\n      transform: 7\n    });\n  }\n}\nfunction xe(e) {\n  const t = e.slice(), n = (\n    /*isClosable*/\n    (t[2] ? (\n      /*points*/\n      t[0]\n    ) : [\n      .../*points*/\n      t[0],\n      /*cursor*/\n      t[1]\n    ]).map((o) => o.join(\",\")).join(\" \")\n  );\n  return t[16] = n, t;\n}\nfunction Mt(e) {\n  let t, n, o, i, s, r = (\n    /*isClosable*/\n    e[2] && vt(e)\n  );\n  return {\n    c() {\n      t = U(\"polygon\"), o = U(\"polygon\"), r && r.c(), s = ce(), d(t, \"class\", \"a9s-outer\"), d(t, \"points\", n = /*coords*/\n      e[16]), d(o, \"class\", \"a9s-inner\"), d(o, \"points\", i = /*coords*/\n      e[16]);\n    },\n    m(l, a) {\n      B(l, t, a), B(l, o, a), r && r.m(l, a), B(l, s, a);\n    },\n    p(l, a) {\n      a & /*isClosable, points, cursor*/\n      7 && n !== (n = /*coords*/\n      l[16]) && d(t, \"points\", n), a & /*isClosable, points, cursor*/\n      7 && i !== (i = /*coords*/\n      l[16]) && d(o, \"points\", i), /*isClosable*/\n      l[2] ? r ? r.p(l, a) : (r = vt(l), r.c(), r.m(s.parentNode, s)) : r && (r.d(1), r = null);\n    },\n    d(l) {\n      l && (k(t), k(o), k(s)), r && r.d(l);\n    }\n  };\n}\nfunction vt(e) {\n  let t, n, o;\n  return {\n    c() {\n      t = U(\"rect\"), d(t, \"class\", \"a9s-corner-handle\"), d(t, \"x\", n = /*points*/\n      e[0][0][0] - /*handleSize*/\n      e[3] / 2), d(t, \"y\", o = /*points*/\n      e[0][0][1] - /*handleSize*/\n      e[3] / 2), d(\n        t,\n        \"height\",\n        /*handleSize*/\n        e[3]\n      ), d(\n        t,\n        \"width\",\n        /*handleSize*/\n        e[3]\n      );\n    },\n    m(i, s) {\n      B(i, t, s);\n    },\n    p(i, s) {\n      s & /*points, handleSize*/\n      9 && n !== (n = /*points*/\n      i[0][0][0] - /*handleSize*/\n      i[3] / 2) && d(t, \"x\", n), s & /*points, handleSize*/\n      9 && o !== (o = /*points*/\n      i[0][0][1] - /*handleSize*/\n      i[3] / 2) && d(t, \"y\", o), s & /*handleSize*/\n      8 && d(\n        t,\n        \"height\",\n        /*handleSize*/\n        i[3]\n      ), s & /*handleSize*/\n      8 && d(\n        t,\n        \"width\",\n        /*handleSize*/\n        i[3]\n      );\n    },\n    d(i) {\n      i && k(t);\n    }\n  };\n}\nfunction Go(e) {\n  let t, n = (\n    /*cursor*/\n    e[1] && Mt(xe(e))\n  );\n  return {\n    c() {\n      t = U(\"g\"), n && n.c(), d(t, \"class\", \"a9s-annotation a9s-rubberband\");\n    },\n    m(o, i) {\n      B(o, t, i), n && n.m(t, null);\n    },\n    p(o, [i]) {\n      /*cursor*/\n      o[1] ? n ? n.p(xe(o), i) : (n = Mt(xe(o)), n.c(), n.m(t, null)) : n && (n.d(1), n = null);\n    },\n    i: V,\n    o: V,\n    d(o) {\n      o && k(t), n && n.d();\n    }\n  };\n}\nconst zo = 20, Ho = 1500;\nfunction Fo(e, t, n) {\n  let o;\n  const i = Te();\n  let { addEventListener: s } = t, { drawingMode: r } = t, { transform: l } = t, { viewportScale: a = 1 } = t, c, u = [], f, h, g = !1;\n  const m = (b) => {\n    const A = b, { timeStamp: L, offsetX: D, offsetY: R } = A;\n    if (c = { timeStamp: L, offsetX: D, offsetY: R }, r === \"drag\" && u.length === 0) {\n      const p = l.elementToImage(A.offsetX, A.offsetY);\n      u.push(p), n(1, f = p);\n    }\n  }, _ = (b) => {\n    const A = b;\n    if (h && clearTimeout(h), u.length > 0) {\n      if (n(1, f = l.elementToImage(A.offsetX, A.offsetY)), u.length > 2) {\n        const L = Qe(f, u[0]) * a;\n        n(2, g = L < zo);\n      }\n      A.pointerType === \"touch\" && (h = setTimeout(\n        () => {\n          y();\n        },\n        Ho\n      ));\n    }\n  }, w = (b) => {\n    const A = b;\n    if (h && clearTimeout(h), r === \"click\") {\n      const L = A.timeStamp - c.timeStamp, D = Qe([c.offsetX, c.offsetY], [A.offsetX, A.offsetY]);\n      if (L > 300 || D > 15)\n        return;\n      if (g)\n        E();\n      else if (u.length === 0) {\n        const R = l.elementToImage(A.offsetX, A.offsetY);\n        u.push(R), n(1, f = R);\n      } else\n        u.push(f);\n    } else {\n      if (u.length === 1 && Qe(u[0], f) <= 4) {\n        n(0, u = []), n(1, f = void 0);\n        return;\n      }\n      A.stopImmediatePropagation(), g ? E() : u.push(f);\n    }\n  }, y = () => {\n    if (!f)\n      return;\n    const b = [...u, f], A = {\n      type: j.POLYGON,\n      geometry: { bounds: Fe(b), points: b }\n    };\n    st(A) > 4 && (n(0, u = []), n(1, f = void 0), i(\"create\", A));\n  }, E = () => {\n    const b = {\n      type: j.POLYGON,\n      geometry: {\n        bounds: Fe(u),\n        points: [...u]\n      }\n    };\n    n(0, u = []), n(1, f = void 0), i(\"create\", b);\n  };\n  return Pe(() => {\n    s(\"pointerdown\", m, !0), s(\"pointermove\", _), s(\"pointerup\", w, !0), s(\"dblclick\", y, !0);\n  }), e.$$set = (b) => {\n    \"addEventListener\" in b && n(4, s = b.addEventListener), \"drawingMode\" in b && n(5, r = b.drawingMode), \"transform\" in b && n(6, l = b.transform), \"viewportScale\" in b && n(7, a = b.viewportScale);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*viewportScale*/\n    128 && n(3, o = 10 / a);\n  }, [\n    u,\n    f,\n    g,\n    o,\n    s,\n    r,\n    l,\n    a\n  ];\n}\nclass jo extends te {\n  constructor(t) {\n    super(), ee(this, t, Fo, Go, W, {\n      addEventListener: 4,\n      drawingMode: 5,\n      transform: 6,\n      viewportScale: 7\n    });\n  }\n}\nconst ft = /* @__PURE__ */ new Map([\n  [\"rectangle\", { tool: Vo }],\n  [\"polygon\", { tool: jo }]\n]), xt = () => [...ft.keys()], $t = (e) => ft.get(e), qo = (e, t, n) => ft.set(e, { tool: t, opts: n });\nfunction Ko(e) {\n  let t, n, o, i, s;\n  return {\n    c() {\n      t = U(\"g\"), n = U(\"ellipse\"), i = U(\"ellipse\"), d(n, \"class\", \"a9s-outer\"), d(n, \"style\", o = /*computedStyle*/\n      e[1] ? \"display:none;\" : void 0), d(\n        n,\n        \"cx\",\n        /*cx*/\n        e[2]\n      ), d(\n        n,\n        \"cy\",\n        /*cy*/\n        e[3]\n      ), d(\n        n,\n        \"rx\",\n        /*rx*/\n        e[4]\n      ), d(\n        n,\n        \"ry\",\n        /*ry*/\n        e[5]\n      ), d(i, \"class\", \"a9s-inner\"), d(\n        i,\n        \"style\",\n        /*computedStyle*/\n        e[1]\n      ), d(\n        i,\n        \"cx\",\n        /*cx*/\n        e[2]\n      ), d(\n        i,\n        \"cy\",\n        /*cy*/\n        e[3]\n      ), d(\n        i,\n        \"rx\",\n        /*rx*/\n        e[4]\n      ), d(\n        i,\n        \"ry\",\n        /*ry*/\n        e[5]\n      ), d(t, \"data-id\", s = /*annotation*/\n      e[0].id);\n    },\n    m(r, l) {\n      B(r, t, l), se(t, n), se(t, i);\n    },\n    p(r, [l]) {\n      l & /*computedStyle*/\n      2 && o !== (o = /*computedStyle*/\n      r[1] ? \"display:none;\" : void 0) && d(n, \"style\", o), l & /*computedStyle*/\n      2 && d(\n        i,\n        \"style\",\n        /*computedStyle*/\n        r[1]\n      ), l & /*annotation*/\n      1 && s !== (s = /*annotation*/\n      r[0].id) && d(t, \"data-id\", s);\n    },\n    i: V,\n    o: V,\n    d(r) {\n      r && k(t);\n    }\n  };\n}\nfunction Wo(e, t, n) {\n  let o, { annotation: i } = t, { geom: s } = t, { style: r } = t;\n  const { cx: l, cy: a, rx: c, ry: u } = s;\n  return e.$$set = (f) => {\n    \"annotation\" in f && n(0, i = f.annotation), \"geom\" in f && n(6, s = f.geom), \"style\" in f && n(7, r = f.style);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*annotation, style*/\n    129 && n(1, o = je(i, r));\n  }, [i, o, l, a, c, u, s, r];\n}\nclass Jo extends te {\n  constructor(t) {\n    super(), ee(this, t, Wo, Ko, W, { annotation: 0, geom: 6, style: 7 });\n  }\n}\nfunction Zo(e) {\n  let t, n, o, i, s;\n  return {\n    c() {\n      t = U(\"g\"), n = U(\"polygon\"), i = U(\"polygon\"), d(n, \"class\", \"a9s-outer\"), d(n, \"style\", o = /*computedStyle*/\n      e[1] ? \"display:none;\" : void 0), d(\n        n,\n        \"points\",\n        /*points*/\n        e[2].map(Qo).join(\" \")\n      ), d(i, \"class\", \"a9s-inner\"), d(\n        i,\n        \"style\",\n        /*computedStyle*/\n        e[1]\n      ), d(\n        i,\n        \"points\",\n        /*points*/\n        e[2].map(xo).join(\" \")\n      ), d(t, \"data-id\", s = /*annotation*/\n      e[0].id);\n    },\n    m(r, l) {\n      B(r, t, l), se(t, n), se(t, i);\n    },\n    p(r, [l]) {\n      l & /*computedStyle*/\n      2 && o !== (o = /*computedStyle*/\n      r[1] ? \"display:none;\" : void 0) && d(n, \"style\", o), l & /*computedStyle*/\n      2 && d(\n        i,\n        \"style\",\n        /*computedStyle*/\n        r[1]\n      ), l & /*annotation*/\n      1 && s !== (s = /*annotation*/\n      r[0].id) && d(t, \"data-id\", s);\n    },\n    i: V,\n    o: V,\n    d(r) {\n      r && k(t);\n    }\n  };\n}\nconst Qo = (e) => e.join(\",\"), xo = (e) => e.join(\",\");\nfunction $o(e, t, n) {\n  let o, { annotation: i } = t, { geom: s } = t, { style: r } = t;\n  const { points: l } = s;\n  return e.$$set = (a) => {\n    \"annotation\" in a && n(0, i = a.annotation), \"geom\" in a && n(3, s = a.geom), \"style\" in a && n(4, r = a.style);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*annotation, style*/\n    17 && n(1, o = je(i, r));\n  }, [i, o, l, s, r];\n}\nclass ei extends te {\n  constructor(t) {\n    super(), ee(this, t, $o, Zo, W, { annotation: 0, geom: 3, style: 4 });\n  }\n}\nfunction ti(e) {\n  let t, n, o, i, s;\n  return {\n    c() {\n      t = U(\"g\"), n = U(\"rect\"), i = U(\"rect\"), d(n, \"class\", \"a9s-outer\"), d(n, \"style\", o = /*computedStyle*/\n      e[5] ? \"display:none;\" : void 0), d(\n        n,\n        \"x\",\n        /*x*/\n        e[4]\n      ), d(\n        n,\n        \"y\",\n        /*y*/\n        e[3]\n      ), d(\n        n,\n        \"width\",\n        /*w*/\n        e[2]\n      ), d(\n        n,\n        \"height\",\n        /*h*/\n        e[1]\n      ), d(i, \"class\", \"a9s-inner\"), d(\n        i,\n        \"style\",\n        /*computedStyle*/\n        e[5]\n      ), d(\n        i,\n        \"x\",\n        /*x*/\n        e[4]\n      ), d(\n        i,\n        \"y\",\n        /*y*/\n        e[3]\n      ), d(\n        i,\n        \"width\",\n        /*w*/\n        e[2]\n      ), d(\n        i,\n        \"height\",\n        /*h*/\n        e[1]\n      ), d(t, \"data-id\", s = /*annotation*/\n      e[0].id);\n    },\n    m(r, l) {\n      B(r, t, l), se(t, n), se(t, i);\n    },\n    p(r, [l]) {\n      l & /*computedStyle*/\n      32 && o !== (o = /*computedStyle*/\n      r[5] ? \"display:none;\" : void 0) && d(n, \"style\", o), l & /*x*/\n      16 && d(\n        n,\n        \"x\",\n        /*x*/\n        r[4]\n      ), l & /*y*/\n      8 && d(\n        n,\n        \"y\",\n        /*y*/\n        r[3]\n      ), l & /*w*/\n      4 && d(\n        n,\n        \"width\",\n        /*w*/\n        r[2]\n      ), l & /*h*/\n      2 && d(\n        n,\n        \"height\",\n        /*h*/\n        r[1]\n      ), l & /*computedStyle*/\n      32 && d(\n        i,\n        \"style\",\n        /*computedStyle*/\n        r[5]\n      ), l & /*x*/\n      16 && d(\n        i,\n        \"x\",\n        /*x*/\n        r[4]\n      ), l & /*y*/\n      8 && d(\n        i,\n        \"y\",\n        /*y*/\n        r[3]\n      ), l & /*w*/\n      4 && d(\n        i,\n        \"width\",\n        /*w*/\n        r[2]\n      ), l & /*h*/\n      2 && d(\n        i,\n        \"height\",\n        /*h*/\n        r[1]\n      ), l & /*annotation*/\n      1 && s !== (s = /*annotation*/\n      r[0].id) && d(t, \"data-id\", s);\n    },\n    i: V,\n    o: V,\n    d(r) {\n      r && k(t);\n    }\n  };\n}\nfunction ni(e, t, n) {\n  let o, i, s, r, l, { annotation: a } = t, { geom: c } = t, { style: u } = t;\n  return e.$$set = (f) => {\n    \"annotation\" in f && n(0, a = f.annotation), \"geom\" in f && n(6, c = f.geom), \"style\" in f && n(7, u = f.style);\n  }, e.$$.update = () => {\n    e.$$.dirty & /*annotation, style*/\n    129 && n(5, o = je(a, u)), e.$$.dirty & /*geom*/\n    64 && n(4, { x: i, y: s, w: r, h: l } = c, i, (n(3, s), n(6, c)), (n(2, r), n(6, c)), (n(1, l), n(6, c)));\n  }, [a, l, r, s, i, o, c, u];\n}\nclass oi extends te {\n  constructor(t) {\n    super(), ee(this, t, ni, ti, W, { annotation: 0, geom: 6, style: 7 });\n  }\n}\nconst Yi = {\n  elementToImage: (e, t) => [e, t]\n}, ii = (e) => ({\n  elementToImage: (t, n) => {\n    const o = e.getBoundingClientRect(), i = e.createSVGPoint();\n    i.x = t + o.x, i.y = n + o.y;\n    const { x: s, y: r } = i.matrixTransform(e.getScreenCTM().inverse());\n    return [s, r];\n  }\n}), si = 250, ri = (e, t) => {\n  const n = Te();\n  let o;\n  return { onPointerDown: () => o = performance.now(), onPointerUp: (r) => {\n    if (performance.now() - o < si) {\n      const { x: a, y: c } = li(r, e), u = t.getAt(a, c);\n      u ? n(\"click\", { originalEvent: r, annotation: u }) : n(\"click\", { originalEvent: r });\n    }\n  } };\n}, li = (e, t) => {\n  const n = t.createSVGPoint(), o = t.getBoundingClientRect(), i = e.clientX - o.x, s = e.clientY - o.y, { left: r, top: l } = t.getBoundingClientRect();\n  return n.x = i + r, n.y = s + l, n.matrixTransform(t.getScreenCTM().inverse());\n}, { Boolean: en } = fn;\nfunction Lt(e, t, n) {\n  const o = e.slice();\n  return o[30] = t[n], o;\n}\nfunction kt(e, t, n) {\n  const o = e.slice();\n  return o[33] = t[n], o;\n}\nfunction $e(e) {\n  const t = e.slice(), n = (\n    /*annotation*/\n    t[33].target.selector\n  );\n  return t[36] = n, t;\n}\nfunction Ot(e) {\n  let t = (\n    /*annotation*/\n    e[33].id\n  ), n, o, i = Bt(e);\n  return {\n    c() {\n      i.c(), n = ce();\n    },\n    m(s, r) {\n      i.m(s, r), B(s, n, r), o = !0;\n    },\n    p(s, r) {\n      r[0] & /*$store*/\n      8192 && W(t, t = /*annotation*/\n      s[33].id) ? (re(), C(i, 1, 1, V), le(), i = Bt(s), i.c(), P(i, 1), i.m(n.parentNode, n)) : i.p(s, r);\n    },\n    i(s) {\n      o || (P(i), o = !0);\n    },\n    o(s) {\n      C(i), o = !1;\n    },\n    d(s) {\n      s && k(n), i.d(s);\n    }\n  };\n}\nfunction ai(e) {\n  let t, n;\n  return t = new ei({\n    props: {\n      annotation: (\n        /*annotation*/\n        e[33]\n      ),\n      geom: (\n        /*selector*/\n        e[36].geometry\n      ),\n      style: (\n        /*style*/\n        e[1]\n      )\n    }\n  }), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, i) {\n      const s = {};\n      i[0] & /*$store*/\n      8192 && (s.annotation = /*annotation*/\n      o[33]), i[0] & /*$store*/\n      8192 && (s.geom = /*selector*/\n      o[36].geometry), i[0] & /*style*/\n      2 && (s.style = /*style*/\n      o[1]), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction ci(e) {\n  let t, n;\n  return t = new oi({\n    props: {\n      annotation: (\n        /*annotation*/\n        e[33]\n      ),\n      geom: (\n        /*selector*/\n        e[36].geometry\n      ),\n      style: (\n        /*style*/\n        e[1]\n      )\n    }\n  }), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, i) {\n      const s = {};\n      i[0] & /*$store*/\n      8192 && (s.annotation = /*annotation*/\n      o[33]), i[0] & /*$store*/\n      8192 && (s.geom = /*selector*/\n      o[36].geometry), i[0] & /*style*/\n      2 && (s.style = /*style*/\n      o[1]), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction fi(e) {\n  let t, n;\n  return t = new Jo({\n    props: {\n      annotation: (\n        /*annotation*/\n        e[33]\n      ),\n      geom: (\n        /*selector*/\n        e[36].geometry\n      ),\n      style: (\n        /*style*/\n        e[1]\n      )\n    }\n  }), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, i) {\n      const s = {};\n      i[0] & /*$store*/\n      8192 && (s.annotation = /*annotation*/\n      o[33]), i[0] & /*$store*/\n      8192 && (s.geom = /*selector*/\n      o[36].geometry), i[0] & /*style*/\n      2 && (s.style = /*style*/\n      o[1]), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction Bt(e) {\n  let t, n, o, i;\n  const s = [fi, ci, ai], r = [];\n  function l(a, c) {\n    return (\n      /*selector*/\n      a[36].type === j.ELLIPSE ? 0 : (\n        /*selector*/\n        a[36].type === j.RECTANGLE ? 1 : (\n          /*selector*/\n          a[36].type === j.POLYGON ? 2 : -1\n        )\n      )\n    );\n  }\n  return ~(t = l(e)) && (n = r[t] = s[t](e)), {\n    c() {\n      n && n.c(), o = ce();\n    },\n    m(a, c) {\n      ~t && r[t].m(a, c), B(a, o, c), i = !0;\n    },\n    p(a, c) {\n      let u = t;\n      t = l(a), t === u ? ~t && r[t].p(a, c) : (n && (re(), C(r[u], 1, 1, () => {\n        r[u] = null;\n      }), le()), ~t ? (n = r[t], n ? n.p(a, c) : (n = r[t] = s[t](a), n.c()), P(n, 1), n.m(o.parentNode, o)) : n = null);\n    },\n    i(a) {\n      i || (P(n), i = !0);\n    },\n    o(a) {\n      C(n), i = !1;\n    },\n    d(a) {\n      a && k(o), ~t && r[t].d(a);\n    }\n  };\n}\nfunction It(e) {\n  let t = !/*isEditable*/\n  e[7](\n    /*annotation*/\n    e[33]\n  ), n, o, i = t && Ot($e(e));\n  return {\n    c() {\n      i && i.c(), n = ce();\n    },\n    m(s, r) {\n      i && i.m(s, r), B(s, n, r), o = !0;\n    },\n    p(s, r) {\n      r[0] & /*isEditable, $store*/\n      8320 && (t = !/*isEditable*/\n      s[7](\n        /*annotation*/\n        s[33]\n      )), t ? i ? (i.p($e(s), r), r[0] & /*isEditable, $store*/\n      8320 && P(i, 1)) : (i = Ot($e(s)), i.c(), P(i, 1), i.m(n.parentNode, n)) : i && (re(), C(i, 1, 1, () => {\n        i = null;\n      }), le());\n    },\n    i(s) {\n      o || (P(i), o = !0);\n    },\n    o(s) {\n      C(i), o = !1;\n    },\n    d(s) {\n      s && k(n), i && i.d(s);\n    }\n  };\n}\nfunction Pt(e) {\n  let t, n, o, i;\n  const s = [di, ui], r = [];\n  function l(a, c) {\n    return (\n      /*editableAnnotations*/\n      a[6] ? 0 : (\n        /*tool*/\n        a[12] && /*drawingEnabled*/\n        a[0] ? 1 : -1\n      )\n    );\n  }\n  return ~(t = l(e)) && (n = r[t] = s[t](e)), {\n    c() {\n      n && n.c(), o = ce();\n    },\n    m(a, c) {\n      ~t && r[t].m(a, c), B(a, o, c), i = !0;\n    },\n    p(a, c) {\n      let u = t;\n      t = l(a), t === u ? ~t && r[t].p(a, c) : (n && (re(), C(r[u], 1, 1, () => {\n        r[u] = null;\n      }), le()), ~t ? (n = r[t], n ? n.p(a, c) : (n = r[t] = s[t](a), n.c()), P(n, 1), n.m(o.parentNode, o)) : n = null);\n    },\n    i(a) {\n      i || (P(n), i = !0);\n    },\n    o(a) {\n      C(n), i = !1;\n    },\n    d(a) {\n      a && k(o), ~t && r[t].d(a);\n    }\n  };\n}\nfunction ui(e) {\n  let t = (\n    /*toolName*/\n    e[2]\n  ), n, o, i = Yt(e);\n  return {\n    c() {\n      i.c(), n = ce();\n    },\n    m(s, r) {\n      i.m(s, r), B(s, n, r), o = !0;\n    },\n    p(s, r) {\n      r[0] & /*toolName*/\n      4 && W(t, t = /*toolName*/\n      s[2]) ? (re(), C(i, 1, 1, V), le(), i = Yt(s), i.c(), P(i, 1), i.m(n.parentNode, n)) : i.p(s, r);\n    },\n    i(s) {\n      o || (P(i), o = !0);\n    },\n    o(s) {\n      C(i), o = !1;\n    },\n    d(s) {\n      s && k(n), i.d(s);\n    }\n  };\n}\nfunction di(e) {\n  let t, n, o = Se(\n    /*editableAnnotations*/\n    e[6]\n  ), i = [];\n  for (let r = 0; r < o.length; r += 1)\n    i[r] = Xt(Lt(e, o, r));\n  const s = (r) => C(i[r], 1, 1, () => {\n    i[r] = null;\n  });\n  return {\n    c() {\n      for (let r = 0; r < i.length; r += 1)\n        i[r].c();\n      t = ce();\n    },\n    m(r, l) {\n      for (let a = 0; a < i.length; a += 1)\n        i[a] && i[a].m(r, l);\n      B(r, t, l), n = !0;\n    },\n    p(r, l) {\n      if (l[0] & /*editableAnnotations, drawingEl, getEditor, style, transform, $scale, onChangeSelected*/\n      803922) {\n        o = Se(\n          /*editableAnnotations*/\n          r[6]\n        );\n        let a;\n        for (a = 0; a < o.length; a += 1) {\n          const c = Lt(r, o, a);\n          i[a] ? (i[a].p(c, l), P(i[a], 1)) : (i[a] = Xt(c), i[a].c(), P(i[a], 1), i[a].m(t.parentNode, t));\n        }\n        for (re(), a = o.length; a < i.length; a += 1)\n          s(a);\n        le();\n      }\n    },\n    i(r) {\n      if (!n) {\n        for (let l = 0; l < o.length; l += 1)\n          P(i[l]);\n        n = !0;\n      }\n    },\n    o(r) {\n      i = i.filter(en);\n      for (let l = 0; l < i.length; l += 1)\n        C(i[l]);\n      n = !1;\n    },\n    d(r) {\n      r && k(t), rt(i, r);\n    }\n  };\n}\nfunction Yt(e) {\n  let t, n;\n  return t = new Ro({\n    props: {\n      target: (\n        /*drawingEl*/\n        e[4]\n      ),\n      tool: (\n        /*tool*/\n        e[12]\n      ),\n      drawingMode: (\n        /*drawingMode*/\n        e[11]\n      ),\n      transform: (\n        /*transform*/\n        e[10]\n      ),\n      viewportScale: (\n        /*$scale*/\n        e[14]\n      )\n    }\n  }), t.$on(\n    \"create\",\n    /*onSelectionCreated*/\n    e[17]\n  ), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, i) {\n      const s = {};\n      i[0] & /*drawingEl*/\n      16 && (s.target = /*drawingEl*/\n      o[4]), i[0] & /*tool*/\n      4096 && (s.tool = /*tool*/\n      o[12]), i[0] & /*drawingMode*/\n      2048 && (s.drawingMode = /*drawingMode*/\n      o[11]), i[0] & /*transform*/\n      1024 && (s.transform = /*transform*/\n      o[10]), i[0] & /*$scale*/\n      16384 && (s.viewportScale = /*$scale*/\n      o[14]), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction Dt(e) {\n  let t, n;\n  return t = new Xo({\n    props: {\n      target: (\n        /*drawingEl*/\n        e[4]\n      ),\n      editor: (\n        /*getEditor*/\n        e[19](\n          /*editable*/\n          e[30].target.selector\n        )\n      ),\n      annotation: (\n        /*editable*/\n        e[30]\n      ),\n      style: (\n        /*style*/\n        e[1]\n      ),\n      transform: (\n        /*transform*/\n        e[10]\n      ),\n      viewportScale: (\n        /*$scale*/\n        e[14]\n      )\n    }\n  }), t.$on(\"change\", function() {\n    q(\n      /*onChangeSelected*/\n      e[18](\n        /*editable*/\n        e[30]\n      )\n    ) && e[18](\n      /*editable*/\n      e[30]\n    ).apply(this, arguments);\n  }), {\n    c() {\n      $(t.$$.fragment);\n    },\n    m(o, i) {\n      Q(t, o, i), n = !0;\n    },\n    p(o, i) {\n      e = o;\n      const s = {};\n      i[0] & /*drawingEl*/\n      16 && (s.target = /*drawingEl*/\n      e[4]), i[0] & /*editableAnnotations*/\n      64 && (s.editor = /*getEditor*/\n      e[19](\n        /*editable*/\n        e[30].target.selector\n      )), i[0] & /*editableAnnotations*/\n      64 && (s.annotation = /*editable*/\n      e[30]), i[0] & /*style*/\n      2 && (s.style = /*style*/\n      e[1]), i[0] & /*transform*/\n      1024 && (s.transform = /*transform*/\n      e[10]), i[0] & /*$scale*/\n      16384 && (s.viewportScale = /*$scale*/\n      e[14]), t.$set(s);\n    },\n    i(o) {\n      n || (P(t.$$.fragment, o), n = !0);\n    },\n    o(o) {\n      C(t.$$.fragment, o), n = !1;\n    },\n    d(o) {\n      x(t, o);\n    }\n  };\n}\nfunction Xt(e) {\n  let t = (\n    /*editable*/\n    e[30].id\n  ), n, o, i = Dt(e);\n  return {\n    c() {\n      i.c(), n = ce();\n    },\n    m(s, r) {\n      i.m(s, r), B(s, n, r), o = !0;\n    },\n    p(s, r) {\n      r[0] & /*editableAnnotations*/\n      64 && W(t, t = /*editable*/\n      s[30].id) ? (re(), C(i, 1, 1, V), le(), i = Dt(s), i.c(), P(i, 1), i.m(n.parentNode, n)) : i.p(s, r);\n    },\n    i(s) {\n      o || (P(i), o = !0);\n    },\n    o(s) {\n      C(i), o = !1;\n    },\n    d(s) {\n      s && k(n), i.d(s);\n    }\n  };\n}\nfunction hi(e) {\n  let t, n, o, i, s, r, l = Se(\n    /*$store*/\n    e[13]\n  ), a = [];\n  for (let f = 0; f < l.length; f += 1)\n    a[f] = It(kt(e, l, f));\n  const c = (f) => C(a[f], 1, 1, () => {\n    a[f] = null;\n  });\n  let u = (\n    /*drawingEl*/\n    e[4] && Pt(e)\n  );\n  return {\n    c() {\n      t = U(\"svg\"), n = U(\"g\");\n      for (let f = 0; f < a.length; f += 1)\n        a[f].c();\n      o = U(\"g\"), u && u.c(), d(o, \"class\", \"drawing\"), d(t, \"class\", \"a9s-annotationlayer\"), ze(\n        t,\n        \"drawing\",\n        /*tool*/\n        e[12]\n      );\n    },\n    m(f, h) {\n      B(f, t, h), se(t, n);\n      for (let g = 0; g < a.length; g += 1)\n        a[g] && a[g].m(n, null);\n      se(t, o), u && u.m(o, null), e[26](o), e[27](t), i = !0, s || (r = [\n        F(t, \"pointerup\", function() {\n          q(\n            /*onPointerUp*/\n            e[8]\n          ) && e[8].apply(this, arguments);\n        }),\n        F(t, \"pointerdown\", function() {\n          q(\n            /*onPointerDown*/\n            e[9]\n          ) && e[9].apply(this, arguments);\n        })\n      ], s = !0);\n    },\n    p(f, h) {\n      if (e = f, h[0] & /*$store, style, isEditable*/\n      8322) {\n        l = Se(\n          /*$store*/\n          e[13]\n        );\n        let g;\n        for (g = 0; g < l.length; g += 1) {\n          const m = kt(e, l, g);\n          a[g] ? (a[g].p(m, h), P(a[g], 1)) : (a[g] = It(m), a[g].c(), P(a[g], 1), a[g].m(n, null));\n        }\n        for (re(), g = l.length; g < a.length; g += 1)\n          c(g);\n        le();\n      }\n      /*drawingEl*/\n      e[4] ? u ? (u.p(e, h), h[0] & /*drawingEl*/\n      16 && P(u, 1)) : (u = Pt(e), u.c(), P(u, 1), u.m(o, null)) : u && (re(), C(u, 1, 1, () => {\n        u = null;\n      }), le()), (!i || h[0] & /*tool*/\n      4096) && ze(\n        t,\n        \"drawing\",\n        /*tool*/\n        e[12]\n      );\n    },\n    i(f) {\n      if (!i) {\n        for (let h = 0; h < l.length; h += 1)\n          P(a[h]);\n        P(u), i = !0;\n      }\n    },\n    o(f) {\n      a = a.filter(en);\n      for (let h = 0; h < a.length; h += 1)\n        C(a[h]);\n      C(u), i = !1;\n    },\n    d(f) {\n      f && k(t), rt(a, f), u && u.d(), e[26](null), e[27](null), s = !1, ae(r);\n    }\n  };\n}\nfunction gi(e, t, n) {\n  let o, i, s, r, l, a, c, u, f, h, g = V, m = () => (g(), g = Vt(p, (I) => n(14, h = I)), p);\n  e.$$.on_destroy.push(() => g());\n  let { drawingEnabled: _ } = t, { image: w } = t, { preferredDrawingMode: y } = t, { state: E } = t, { style: b = void 0 } = t, { toolName: A = xt()[0] } = t, { user: L } = t, D, R, p;\n  Pe(() => m(n(5, p = wo(w, R))));\n  const { selection: T, store: S } = E;\n  ht(e, T, (I) => n(25, u = I)), ht(e, S, (I) => n(13, f = I));\n  let M, O;\n  const X = (I) => {\n    M && S.unobserve(M);\n    const z = I.filter(({ editable: H }) => H).map(({ id: H }) => H);\n    z.length > 0 ? (n(6, O = z.map((H) => S.getAnnotation(H)).filter(Boolean)), M = (H) => {\n      const { updated: J } = H.changes;\n      n(6, O = J == null ? void 0 : J.map((fe) => fe.newValue));\n    }, S.observe(M, { annotations: z })) : n(6, O = void 0);\n  }, Z = (I) => {\n    const z = qt(), H = {\n      id: z,\n      bodies: [],\n      target: {\n        annotation: z,\n        selector: I.detail,\n        creator: L,\n        created: /* @__PURE__ */ new Date()\n      }\n    };\n    S.addAnnotation(H), T.setSelected(H.id);\n  }, ge = (I) => (z) => {\n    var ne;\n    const { target: H } = I, J = 10 * 60 * 1e3, fe = ((ne = H.creator) == null ? void 0 : ne.id) !== L.id || !H.created || (/* @__PURE__ */ new Date()).getTime() - H.created.getTime() > J;\n    S.updateTarget({\n      ...H,\n      selector: z.detail,\n      created: fe ? H.created : /* @__PURE__ */ new Date(),\n      updated: fe ? /* @__PURE__ */ new Date() : void 0,\n      updatedBy: fe ? L : void 0\n    });\n  }, me = (I) => Oo(I);\n  function Me(I) {\n    He[I ? \"unshift\" : \"push\"](() => {\n      D = I, n(4, D);\n    });\n  }\n  function ie(I) {\n    He[I ? \"unshift\" : \"push\"](() => {\n      R = I, n(3, R);\n    });\n  }\n  return e.$$set = (I) => {\n    \"drawingEnabled\" in I && n(0, _ = I.drawingEnabled), \"image\" in I && n(20, w = I.image), \"preferredDrawingMode\" in I && n(21, y = I.preferredDrawingMode), \"state\" in I && n(22, E = I.state), \"style\" in I && n(1, b = I.style), \"toolName\" in I && n(2, A = I.toolName), \"user\" in I && n(23, L = I.user);\n  }, e.$$.update = () => {\n    e.$$.dirty[0] & /*toolName*/\n    4 && n(12, { tool: o, opts: i } = $t(A) || { tool: void 0, opts: void 0 }, o, (n(24, i), n(2, A))), e.$$.dirty[0] & /*opts, preferredDrawingMode*/\n    18874368 && n(11, s = (i == null ? void 0 : i.drawingMode) || y), e.$$.dirty[0] & /*svgEl*/\n    8 && n(10, r = ii(R)), e.$$.dirty[0] & /*svgEl*/\n    8 && n(9, { onPointerDown: l, onPointerUp: a } = ri(R, S), l, (n(8, a), n(3, R))), e.$$.dirty[0] & /*$selection*/\n    33554432 && n(7, c = (I) => u.selected.find((z) => z.id === I.id && z.editable)), e.$$.dirty[0] & /*$selection*/\n    33554432 && X(u.selected);\n  }, [\n    _,\n    b,\n    A,\n    R,\n    D,\n    p,\n    O,\n    c,\n    a,\n    l,\n    r,\n    s,\n    o,\n    f,\n    h,\n    T,\n    S,\n    Z,\n    ge,\n    me,\n    w,\n    y,\n    E,\n    L,\n    i,\n    u,\n    Me,\n    ie\n  ];\n}\nclass mi extends te {\n  constructor(t) {\n    super(), ee(\n      this,\n      t,\n      gi,\n      hi,\n      W,\n      {\n        drawingEnabled: 0,\n        image: 20,\n        preferredDrawingMode: 21,\n        state: 22,\n        style: 1,\n        toolName: 2,\n        user: 23\n      },\n      null,\n      [-1, -1]\n    );\n  }\n}\nfunction pi(e, t, n, o, i) {\n  tn(e, t, n || 0, o || e.length - 1, i || yi);\n}\nfunction tn(e, t, n, o, i) {\n  for (; o > n; ) {\n    if (o - n > 600) {\n      var s = o - n + 1, r = t - n + 1, l = Math.log(s), a = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * a * (s - a) / s) * (r - s / 2 < 0 ? -1 : 1), u = Math.max(n, Math.floor(t - r * a / s + c)), f = Math.min(o, Math.floor(t + (s - r) * a / s + c));\n      tn(e, t, u, f, i);\n    }\n    var h = e[t], g = n, m = o;\n    for (ve(e, n, t), i(e[o], h) > 0 && ve(e, n, o); g < m; ) {\n      for (ve(e, g, m), g++, m--; i(e[g], h) < 0; )\n        g++;\n      for (; i(e[m], h) > 0; )\n        m--;\n    }\n    i(e[n], h) === 0 ? ve(e, n, m) : (m++, ve(e, m, o)), m <= t && (n = m + 1), t <= m && (o = m - 1);\n  }\n}\nfunction ve(e, t, n) {\n  var o = e[t];\n  e[t] = e[n], e[n] = o;\n}\nfunction yi(e, t) {\n  return e < t ? -1 : e > t ? 1 : 0;\n}\nclass _i {\n  constructor(t = 9) {\n    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();\n  }\n  all() {\n    return this._all(this.data, []);\n  }\n  search(t) {\n    let n = this.data;\n    const o = [];\n    if (!Ne(t, n))\n      return o;\n    const i = this.toBBox, s = [];\n    for (; n; ) {\n      for (let r = 0; r < n.children.length; r++) {\n        const l = n.children[r], a = n.leaf ? i(l) : l;\n        Ne(t, a) && (n.leaf ? o.push(l) : tt(t, a) ? this._all(l, o) : s.push(l));\n      }\n      n = s.pop();\n    }\n    return o;\n  }\n  collides(t) {\n    let n = this.data;\n    if (!Ne(t, n))\n      return !1;\n    const o = [];\n    for (; n; ) {\n      for (let i = 0; i < n.children.length; i++) {\n        const s = n.children[i], r = n.leaf ? this.toBBox(s) : s;\n        if (Ne(t, r)) {\n          if (n.leaf || tt(t, r))\n            return !0;\n          o.push(s);\n        }\n      }\n      n = o.pop();\n    }\n    return !1;\n  }\n  load(t) {\n    if (!(t && t.length))\n      return this;\n    if (t.length < this._minEntries) {\n      for (let o = 0; o < t.length; o++)\n        this.insert(t[o]);\n      return this;\n    }\n    let n = this._build(t.slice(), 0, t.length - 1, 0);\n    if (!this.data.children.length)\n      this.data = n;\n    else if (this.data.height === n.height)\n      this._splitRoot(this.data, n);\n    else {\n      if (this.data.height < n.height) {\n        const o = this.data;\n        this.data = n, n = o;\n      }\n      this._insert(n, this.data.height - n.height - 1, !0);\n    }\n    return this;\n  }\n  insert(t) {\n    return t && this._insert(t, this.data.height - 1), this;\n  }\n  clear() {\n    return this.data = Ee([]), this;\n  }\n  remove(t, n) {\n    if (!t)\n      return this;\n    let o = this.data;\n    const i = this.toBBox(t), s = [], r = [];\n    let l, a, c;\n    for (; o || s.length; ) {\n      if (o || (o = s.pop(), a = s[s.length - 1], l = r.pop(), c = !0), o.leaf) {\n        const u = wi(t, o.children, n);\n        if (u !== -1)\n          return o.children.splice(u, 1), s.push(o), this._condense(s), this;\n      }\n      !c && !o.leaf && tt(o, i) ? (s.push(o), r.push(l), l = 0, a = o, o = o.children[0]) : a ? (l++, o = a.children[l], c = !1) : o = null;\n    }\n    return this;\n  }\n  toBBox(t) {\n    return t;\n  }\n  compareMinX(t, n) {\n    return t.minX - n.minX;\n  }\n  compareMinY(t, n) {\n    return t.minY - n.minY;\n  }\n  toJSON() {\n    return this.data;\n  }\n  fromJSON(t) {\n    return this.data = t, this;\n  }\n  _all(t, n) {\n    const o = [];\n    for (; t; )\n      t.leaf ? n.push(...t.children) : o.push(...t.children), t = o.pop();\n    return n;\n  }\n  _build(t, n, o, i) {\n    const s = o - n + 1;\n    let r = this._maxEntries, l;\n    if (s <= r)\n      return l = Ee(t.slice(n, o + 1)), we(l, this.toBBox), l;\n    i || (i = Math.ceil(Math.log(s) / Math.log(r)), r = Math.ceil(s / Math.pow(r, i - 1))), l = Ee([]), l.leaf = !1, l.height = i;\n    const a = Math.ceil(s / r), c = a * Math.ceil(Math.sqrt(r));\n    Ct(t, n, o, c, this.compareMinX);\n    for (let u = n; u <= o; u += c) {\n      const f = Math.min(u + c - 1, o);\n      Ct(t, u, f, a, this.compareMinY);\n      for (let h = u; h <= f; h += a) {\n        const g = Math.min(h + a - 1, f);\n        l.children.push(this._build(t, h, g, i - 1));\n      }\n    }\n    return we(l, this.toBBox), l;\n  }\n  _chooseSubtree(t, n, o, i) {\n    for (; i.push(n), !(n.leaf || i.length - 1 === o); ) {\n      let s = 1 / 0, r = 1 / 0, l;\n      for (let a = 0; a < n.children.length; a++) {\n        const c = n.children[a], u = et(c), f = Ai(t, c) - u;\n        f < r ? (r = f, s = u < s ? u : s, l = c) : f === r && u < s && (s = u, l = c);\n      }\n      n = l || n.children[0];\n    }\n    return n;\n  }\n  _insert(t, n, o) {\n    const i = o ? t : this.toBBox(t), s = [], r = this._chooseSubtree(i, this.data, n, s);\n    for (r.children.push(t), Oe(r, i); n >= 0 && s[n].children.length > this._maxEntries; )\n      this._split(s, n), n--;\n    this._adjustParentBBoxes(i, s, n);\n  }\n  // split overflowed node into two\n  _split(t, n) {\n    const o = t[n], i = o.children.length, s = this._minEntries;\n    this._chooseSplitAxis(o, s, i);\n    const r = this._chooseSplitIndex(o, s, i), l = Ee(o.children.splice(r, o.children.length - r));\n    l.height = o.height, l.leaf = o.leaf, we(o, this.toBBox), we(l, this.toBBox), n ? t[n - 1].children.push(l) : this._splitRoot(o, l);\n  }\n  _splitRoot(t, n) {\n    this.data = Ee([t, n]), this.data.height = t.height + 1, this.data.leaf = !1, we(this.data, this.toBBox);\n  }\n  _chooseSplitIndex(t, n, o) {\n    let i, s = 1 / 0, r = 1 / 0;\n    for (let l = n; l <= o - n; l++) {\n      const a = ke(t, 0, l, this.toBBox), c = ke(t, l, o, this.toBBox), u = Si(a, c), f = et(a) + et(c);\n      u < s ? (s = u, i = l, r = f < r ? f : r) : u === s && f < r && (r = f, i = l);\n    }\n    return i || o - n;\n  }\n  // sorts node children by the best axis for split\n  _chooseSplitAxis(t, n, o) {\n    const i = t.leaf ? this.compareMinX : bi, s = t.leaf ? this.compareMinY : Ei, r = this._allDistMargin(t, n, o, i), l = this._allDistMargin(t, n, o, s);\n    r < l && t.children.sort(i);\n  }\n  // total margin of all possible split distributions where each node is at least m full\n  _allDistMargin(t, n, o, i) {\n    t.children.sort(i);\n    const s = this.toBBox, r = ke(t, 0, n, s), l = ke(t, o - n, o, s);\n    let a = Ue(r) + Ue(l);\n    for (let c = n; c < o - n; c++) {\n      const u = t.children[c];\n      Oe(r, t.leaf ? s(u) : u), a += Ue(r);\n    }\n    for (let c = o - n - 1; c >= n; c--) {\n      const u = t.children[c];\n      Oe(l, t.leaf ? s(u) : u), a += Ue(l);\n    }\n    return a;\n  }\n  _adjustParentBBoxes(t, n, o) {\n    for (let i = o; i >= 0; i--)\n      Oe(n[i], t);\n  }\n  _condense(t) {\n    for (let n = t.length - 1, o; n >= 0; n--)\n      t[n].children.length === 0 ? n > 0 ? (o = t[n - 1].children, o.splice(o.indexOf(t[n]), 1)) : this.clear() : we(t[n], this.toBBox);\n  }\n}\nfunction wi(e, t, n) {\n  if (!n)\n    return t.indexOf(e);\n  for (let o = 0; o < t.length; o++)\n    if (n(e, t[o]))\n      return o;\n  return -1;\n}\nfunction we(e, t) {\n  ke(e, 0, e.children.length, t, e);\n}\nfunction ke(e, t, n, o, i) {\n  i || (i = Ee(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;\n  for (let s = t; s < n; s++) {\n    const r = e.children[s];\n    Oe(i, e.leaf ? o(r) : r);\n  }\n  return i;\n}\nfunction Oe(e, t) {\n  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;\n}\nfunction bi(e, t) {\n  return e.minX - t.minX;\n}\nfunction Ei(e, t) {\n  return e.minY - t.minY;\n}\nfunction et(e) {\n  return (e.maxX - e.minX) * (e.maxY - e.minY);\n}\nfunction Ue(e) {\n  return e.maxX - e.minX + (e.maxY - e.minY);\n}\nfunction Ai(e, t) {\n  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));\n}\nfunction Si(e, t) {\n  const n = Math.max(e.minX, t.minX), o = Math.max(e.minY, t.minY), i = Math.min(e.maxX, t.maxX), s = Math.min(e.maxY, t.maxY);\n  return Math.max(0, i - n) * Math.max(0, s - o);\n}\nfunction tt(e, t) {\n  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;\n}\nfunction Ne(e, t) {\n  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;\n}\nfunction Ee(e) {\n  return {\n    children: e,\n    height: 1,\n    leaf: !0,\n    minX: 1 / 0,\n    minY: 1 / 0,\n    maxX: -1 / 0,\n    maxY: -1 / 0\n  };\n}\nfunction Ct(e, t, n, o, i) {\n  const s = [t, n];\n  for (; s.length; ) {\n    if (n = s.pop(), t = s.pop(), n - t <= o)\n      continue;\n    const r = t + Math.ceil((n - t) / o / 2) * o;\n    pi(e, r, t, n, i), s.push(t, r, r, n);\n  }\n}\nconst Ti = () => {\n  const e = new _i(), t = /* @__PURE__ */ new Map(), n = () => [...t.values()], o = () => {\n    e.clear(), t.clear();\n  }, i = (f) => {\n    const { minX: h, minY: g, maxX: m, maxY: _ } = f.selector.geometry.bounds, w = { minX: h, minY: g, maxX: m, maxY: _, target: f };\n    e.insert(w), t.set(f.annotation, w);\n  }, s = (f) => {\n    const h = t.get(f.annotation);\n    h && e.remove(h), t.delete(f.annotation);\n  };\n  return {\n    all: n,\n    clear: o,\n    getAt: (f, h) => {\n      const m = e.search({\n        minX: f,\n        minY: h,\n        maxX: f,\n        maxY: h\n      }).map((_) => _.target).filter((_) => _.selector.type === j.RECTANGLE || wn(_.selector, f, h));\n      if (m.length > 0)\n        return m.sort((_, w) => st(_.selector) - st(w.selector)), m[0];\n    },\n    getIntersecting: (f, h, g, m) => e.search({\n      minX: f,\n      minY: h,\n      maxX: f + g,\n      maxY: h + m\n    }).map((_) => _.target),\n    insert: i,\n    remove: s,\n    set: (f, h = !0) => {\n      h && o();\n      const g = f.map((m) => {\n        const { minX: _, minY: w, maxX: y, maxY: E } = m.selector.geometry.bounds;\n        return { minX: _, minY: w, maxX: y, maxY: E, target: m };\n      });\n      g.forEach((m) => t.set(m.target.annotation, m)), e.load(g);\n    },\n    size: () => e.all().length,\n    update: (f, h) => {\n      s(f), i(h);\n    }\n  };\n}, Mi = (e) => {\n  const t = Kn(), n = Ti(), o = Rn(t, e.pointerSelectAction), i = Cn(t), s = xn();\n  return t.observe(({ changes: a }) => {\n    n.set((a.created || []).map((c) => c.target), !1), (a.deleted || []).forEach((c) => n.remove(c.target)), (a.updated || []).forEach(({ oldValue: c, newValue: u }) => n.update(c.target, u.target));\n  }), {\n    store: {\n      ...t,\n      getAt: (a, c) => {\n        const u = n.getAt(a, c);\n        return u ? t.getAnnotation(u.annotation) : void 0;\n      },\n      getIntersecting: (a, c, u, f) => n.getIntersecting(a, c, u, f).map((h) => t.getAnnotation(h.annotation))\n    },\n    selection: o,\n    hover: i,\n    viewport: s\n  };\n}, vi = (e) => {\n  const t = Mi(e);\n  return {\n    ...t,\n    store: Wn(t.store)\n  };\n}, Li = (e) => {\n  let t, n;\n  if (e.nodeName === \"CANVAS\")\n    t = e, n = t.getContext(\"2d\", { willReadFrequently: !0 });\n  else {\n    const i = e;\n    t = document.createElement(\"canvas\"), t.width = i.width, t.height = i.height, n = t.getContext(\"2d\", { willReadFrequently: !0 }), n.drawImage(i, 0, 0, i.width, i.height);\n  }\n  let o = 0;\n  for (let i = 1; i < 10; i++)\n    for (let s = 1; s < 10; s++) {\n      const r = Math.round(s * t.width / 10), l = Math.round(i * t.height / 10), a = n.getImageData(r, l, 1, 1).data, c = (0.299 * a[0] + 0.587 * a[1] + 0.114 * a[2]) / 255;\n      o += c;\n    }\n  return o / 81;\n}, ki = (e) => {\n  const t = Li(e), n = t > 0.6 ? \"dark\" : \"light\";\n  return console.log(`[Annotorious] Image brightness: ${t.toFixed(1)}. Setting ${n} theme.`), n;\n}, Rt = (e, t, n) => t.setAttribute(\"data-theme\", n === \"auto\" ? ki(e) : n), Oi = (e, t) => ({\n  ...e,\n  drawingEnabled: e.drawingEnabled === void 0 ? t.drawingEnabled : e.drawingEnabled,\n  drawingMode: e.drawingMode || t.drawingMode,\n  pointerSelectAction: e.pointerSelectAction || t.pointerSelectAction,\n  theme: e.theme || t.theme\n}), Ut = navigator.userAgent.indexOf(\"Mac OS X\") !== -1, Bi = (e, t) => {\n  const n = t || document, o = (r) => {\n    const l = r;\n    l.key === \"z\" && l.ctrlKey ? e.undo() : l.key === \"y\" && l.ctrlKey && e.redo();\n  }, i = (r) => {\n    const l = r;\n    l.key === \"z\" && l.metaKey && (l.shiftKey ? e.redo() : e.undo());\n  }, s = () => {\n    Ut ? n.removeEventListener(\"keydown\", i) : n.removeEventListener(\"keydown\", o);\n  };\n  return Ut ? n.addEventListener(\"keydown\", i) : n.addEventListener(\"keydown\", o), {\n    destroy: s\n  };\n}, Di = (e, t = {}) => {\n  if (!e)\n    throw \"Missing argument: image\";\n  const n = typeof e == \"string\" ? document.getElementById(e) : e, o = Oi(t, {\n    drawingEnabled: !0,\n    drawingMode: \"drag\",\n    pointerSelectAction: Kt.EDIT,\n    theme: \"light\"\n  }), i = vi(o), { selection: s, store: r } = i, l = Qn(r), a = $n(\n    i,\n    l,\n    o.adapter,\n    o.autoSave\n  ), c = document.createElement(\"DIV\");\n  c.style.position = \"relative\", c.style.display = \"inline-block\", n.style.display = \"block\", n.parentNode.insertBefore(c, n), c.appendChild(n);\n  const u = Bi(l);\n  let f = ro();\n  Rt(n, c, o.theme);\n  const h = new mi({\n    target: c,\n    props: {\n      drawingEnabled: !!o.drawingEnabled,\n      image: n,\n      preferredDrawingMode: o.drawingMode,\n      state: i,\n      style: o.style,\n      user: f\n    }\n  });\n  h.$on(\"click\", (p) => {\n    const { originalEvent: T, annotation: S } = p.detail;\n    S ? s.clickSelect(S.id, T) : s.isEmpty() || s.clear();\n  });\n  const g = to(i, l, o.adapter), m = () => {\n    h.$destroy(), c.parentNode.insertBefore(n, c), c.parentNode.removeChild(c), u.destroy(), l.destroy();\n  }, _ = () => f, w = (p, T, S) => qo(p, T, S), y = (p, T) => Bo(p, T), E = (p) => {\n    if (!$t(p))\n      throw `No drawing tool named ${p}`;\n    h.$set({ toolName: p });\n  }, b = (p) => h.$set({ drawingEnabled: p }), A = (p) => {\n    console.warn(\"Filter not implemented yet\");\n  }, L = (p) => h.$set({ style: p }), D = (p) => Rt(n, c, p), R = (p) => {\n    f = p, h.$set({ user: p });\n  };\n  return {\n    ...g,\n    destroy: m,\n    getUser: _,\n    listDrawingTools: xt,\n    on: a.on,\n    off: a.off,\n    registerDrawingTool: w,\n    registerShapeEditor: y,\n    setDrawingEnabled: b,\n    setDrawingTool: E,\n    setFilter: A,\n    setStyle: L,\n    setTheme: D,\n    setUser: R,\n    state: i\n  };\n};\nexport {\n  Qt as Editor,\n  Xo as EditorMount,\n  Le as Handle,\n  Yi as IdentityTransform,\n  po as PolygonEditor,\n  ko as RectangleEditor,\n  An as RectangleUtil,\n  Vo as RubberbandRectangle,\n  mi as SVGAnnotationLayer,\n  j as ShapeType,\n  Ro as ToolMount,\n  Pi as W3CImageFormat,\n  ri as addEventListeners,\n  Fe as boundsFromPoints,\n  st as computeArea,\n  Di as createImageAnnotator,\n  Mi as createImageAnnotatorState,\n  ii as createSVGTransform,\n  vi as createSvelteImageAnnotatorState,\n  ki as detectTheme,\n  Qe as distance,\n  wo as enableResponsive,\n  Oi as fillDefaults,\n  Oo as getEditor,\n  $t as getTool,\n  Bi as initKeyboardCommands,\n  wn as intersects,\n  bo as isTouch,\n  xt as listDrawingTools,\n  Sn as parseFragmentSelector,\n  On as parseSVGSelector,\n  fo as parseW3CImageAnnotation,\n  Bo as registerEditor,\n  at as registerShapeUtil,\n  qo as registerTool,\n  Li as sampleBrightness,\n  Tn as serializeFragmentSelector,\n  Bn as serializeSVGSelector,\n  uo as serializeW3CImageAnnotation,\n  Rt as setTheme\n};\n//# sourceMappingURL=annotorious.es.js.map\n","import { ShapeType } from '@annotorious/annotorious';\nimport type { ImageAnnotation, PolygonGeometry, RectangleGeometry, Shape } from '@annotorious/annotorious';\nimport type { PageMetadata } from '@annotorious/formats';\nimport type OpenSeadragon from 'openseadragon';\n\nexport interface ImageDimensions {\n\n  height: number;\n\n  width: number;\n\n}\n\nexport const getImageDimensions = (\n  viewer: OpenSeadragon.Viewer\n): Promise<ImageDimensions> => new Promise(resolve => {\n  if (viewer.world.getItemAt(0)?.source) {\n    // Image already loaded - resolve immediately\n    const { x, y } = viewer.world.getItemAt(0).source.dimensions;\n    resolve({ width: x, height: y });\n  } else {\n    // Attach onOpen handler and resolve then\n    const getDimensions = () => {\n      const { x, y } = viewer.world.getItemAt(0).source.dimensions;\n\n      viewer.removeHandler('open', getDimensions);\n\n      resolve({ width: x, height: y });\n    }\n\n    viewer.addHandler('open', getDimensions);\n  }\n});\n\nconst scaleShape = (shape: Shape, kx: number, ky: number): Shape => {\n  const { bounds } = shape.geometry;\n\n  const minX = bounds.minX * kx;\n  const minY = bounds.minY * ky;\n  const maxX = bounds.maxX * kx;\n  const maxY = bounds.maxY * ky;\n\n  if (shape.type === ShapeType.RECTANGLE) {\n    return {\n      type: ShapeType.RECTANGLE,\n      geometry: {\n        bounds: { minX, minY, maxX, maxY },\n        x: minX,\n        y: minY,\n        w: maxX - minX, \n        h: maxY - minY\n      } as RectangleGeometry\n    }\n  } else if (shape.type === ShapeType.POLYGON) {\n    return {\n      type: ShapeType.POLYGON,\n      geometry: {\n        bounds: { minX, minY, maxX, maxY },\n        points: (shape.geometry as PolygonGeometry)\n          .points.map(([x, y]) => ([x * kx, y * ky]))\n      } as PolygonGeometry\n    }\n  } else  {\n    console.error('Unsupported shape type', shape);\n    return shape;\n  }\n}\n\nexport const scaleAnnotations = (\n  a: ImageAnnotation[], \n  page: PageMetadata, \n  dim: ImageDimensions\n): {\n  scaled: ImageAnnotation[],\n  scaleX: number,\n  scaleY: number\n} => {\n  const pageWidth = page.width;\n  const pageHeight = page.height;\n\n  const imgWidth = dim.width;\n  const imgHeight = dim.height;\n\n  if (pageWidth && pageHeight) {\n    const scaleX = imgWidth / pageWidth;\n    const scaleY = imgHeight / pageHeight;\n\n    if (scaleX === 1 && scaleY === 1) {\n      // No need to scale\n      return { scaled: a, scaleX, scaleY };\n    } else {\n      console.log('[TextLayerExtension] Page and image are different size - scaling annotations');\n\n      const scaled = a.map(annotation => ({\n        ...annotation,\n        target: {\n          ...annotation.target,\n          selector: scaleShape(annotation.target.selector, scaleX, scaleY)\n        }\n      }));\n\n      return { scaled, scaleX, scaleY };\n    }\n  } else {\n    console.warn('[TextLayerExtension] Cannot scale annotations without page dimensions');\n    return { scaled: a, scaleX: 1, scaleY: 1 };\n  }\n}\n","<script lang=\"ts\">\n  import type { ImageAnnotation, ImageAnnotatorState, StoreChangeEvent } from '@annotorious/annotorious';\n  import { onMount } from 'svelte';\n  import { FillBoundsLabel, FixedPageSizeLabel, FixedScreenSizeLabel } from './Label';\n  import type { TextLayerOpts } from './Types';\n  import { getImageDimensions } from './ImageDimensions';\n    \n  /** props **/\n  export let state: ImageAnnotatorState;\n  export let viewer: OpenSeadragon.Viewer;\n  export let opts: TextLayerOpts;\n  export let visible: boolean = true;\n  export let captureEvents: boolean = false;\n\n  const { store } = state;\n\n  let transform: string;\n\n  let scale: number;\n\n  let annotations: ImageAnnotation[] = [];\n\n  let width: number;\n\n  let height: number;\n\n  $: fontSize = opts.fontSize || 16;\n\n  const redraw = () => {\n    const viewportBounds = viewer.viewport.viewportToImageRectangle(viewer.viewport.getBounds(true));\n\n    const containerWidth = viewer.viewport.getContainerSize().x;\n    const zoom = viewer.viewport.getZoom(true);\n    scale = zoom * containerWidth / viewer.world.getContentFactor();\n\n    // @ts-ignore note: getRotation(true <- realtime value) only since OSD 4!\n    let rotation = Math.PI * viewer.viewport.getRotation(true) / 180;\n    if (rotation < 0)\n      rotation += 2 * Math.PI;\n    \n    if (rotation > 2 * Math.PI)\n      rotation -= 2 * Math.PI;\n\n    const flipped = viewer.viewport.getFlip();\n\n    const dx = flipped ? \n      // @ts-ignore\n      viewer.viewport._containerInnerSize.x + viewportBounds.x * scale :\n      - viewportBounds.x * scale;\n\n    const dy = - viewportBounds.y * scale;\n\n    let offsetX: number, offsetY: number;\n\n    if (rotation > 0 && rotation <= Math.PI / 2) {\n      offsetX = viewportBounds.height * scale;\n      offsetY = 0;\n    } else if (rotation > Math.PI / 2 && rotation <= Math.PI) {\n      offsetX = viewportBounds.width * scale;\n      offsetY = viewportBounds.height * scale;\n    } else if (rotation > Math.PI && rotation <= Math.PI * 1.5) {\n      offsetX = 0;\n      offsetY = viewportBounds.width * scale;\n    } else {\n      offsetX = 0;\n      offsetY = 0;\n    }\n\n    const tx = Math.round(100 * (offsetX + dx * Math.cos(rotation) - dy * Math.sin(rotation))) / 100;\n    const ty = Math.round(100 * (offsetY + dx * Math.sin(rotation) + dy * Math.cos(rotation))) / 100;\n    \n    transform = `translate(${tx}px, ${ty}px) rotate(${rotation}rad) scaleX(${flipped ? - scale : scale}) scaleY(${scale})`;\n  }\n\n  onMount(() => {\n    getImageDimensions(viewer).then(dimensions => {\n      width = dimensions.width;\n      height = dimensions.height;\n    });\n\n    viewer.addHandler('update-viewport', redraw);\n\n    const onStoreChange = ((event: StoreChangeEvent<ImageAnnotation>) => {\n      annotations = event.state;\n      redraw();\n    });\n\n    store.observe(onStoreChange);\n\n    const onCopy = (evt: ClipboardEvent) => {\n      const unformatted = document.getSelection()!.toString();\n\n      // @ts-ignore\n      const clipboardData = evt.clipboardData || window.clipboardData;  \n      clipboardData.setData('text/plain', unformatted);\n      clipboardData.setData('text/html', unformatted);\n\n      evt.preventDefault();\n    }\n\n    document.addEventListener('copy', onCopy);\n\n    return () => {\n      viewer.removeHandler('update-viewport', redraw);\n\n      store.unobserve(onStoreChange);\n\n      document.removeEventListener('copy', onCopy);\n    }\n  });\n</script>\n\n{#if visible}\n  <div \n    style={`transform:${transform}; width: ${width}px; height: ${height}px; font-size: ${fontSize}px;`}\n    class=\"a9s-annotationlayer a9s-osd-textlayer\"\n    class:fixed-screen-size={opts.mode === 'fixedScreenSize' || (!opts.mode)}\n    class:fixed-page-size={opts.mode === 'fixedPageSize'}\n    class:fill-bounds={opts.mode === 'fillBounds'}\n    class:bottomleft={opts.position !== 'topleft'}\n    class:topleft={opts.position === 'topleft'}\n    class:pointer-events={captureEvents}>\n    {#if opts.mode === 'fixedScreenSize' || (!opts.mode)}\n      {#each annotations as annotation}\n        <FixedScreenSizeLabel \n          annotation={annotation} \n          opts={opts} \n          imageSize={[width, height]}\n          scale={scale} />\n      {/each}\n    {:else if opts.mode === 'fixedPageSize'}\n      {#each annotations as annotation}\n        <FixedPageSizeLabel \n          annotation={annotation} \n          opts={opts} />\n      {/each}\n    {:else if opts.mode === 'fillBounds'}\n      {#each annotations as annotation}\n        <FillBoundsLabel \n          annotation={annotation} \n          opts={opts} />\n      {/each}\n    {/if}\n  </div>\n{/if}","import type { ImageAnnotation, ImageAnnotatorState } from '@annotorious/annotorious';\nimport type { OpenSeadragonAnnotator } from '@annotorious/openseadragon';\nimport { parseALTO } from '@annotorious/formats';\nimport type { OCRFormat, TextLayerOpts } from './Types';\nimport OpenSeadragonTextLayer from './TextLayer.svelte';\nimport { getImageDimensions, scaleAnnotations } from './ImageDimensions';\n\nimport './textLayerExtension.css';\n\nexport const mountExtension = (\n  anno: OpenSeadragonAnnotator<ImageAnnotation>, \n  opts: TextLayerOpts\n) => {\n  // @ts-ignore\n  const { viewer, state } = anno;\n\n  let _visible = opts.defaultVisible === undefined ? true : opts.defaultVisible;\n\n  let _locked = false;\n\n  // @ts-ignore\n  const textLayer = new OpenSeadragonTextLayer({\n    target: viewer.element.querySelector('.openseadragon-canvas')!,\n    props: { state: state as ImageAnnotatorState, viewer, opts, visible: _visible }\n  });\n\n  const isVisible = () => _visible;\n\n  const isLocked = () => _locked;\n\n  const loadOCR = (url: string, format: OCRFormat = 'ALTO') => fetch(url)\n    .then(res => res.text())\n    .then(xml => {\n      const { annotations, metadata } = parseALTO(xml);\n\n      getImageDimensions(viewer).then(dimensions => {\n        const { scaled, scaleY, scaleX } = scaleAnnotations(annotations, metadata, dimensions);\n\n        if (!opts.fontSize && metadata.avgLineWidth && metadata.avgCharsPerLine) {\n          // No user-defined font size - automatic!\n          // const fontSize = metadata.averageLineHeight * scaleY * 0.5;\n          const fontSize = 0.8 * scaleX * (metadata.avgLineWidth / metadata.avgCharsPerLine);\n\n          textLayer.$set({ opts: { ...opts, fontSize }});\n        }\n\n        anno.setAnnotations(scaled);\n      });\n    });\n\n  const setLocked = (locked: boolean) => {\n    _locked = locked;\n    viewer.setMouseNavEnabled(!locked);\n\n    // @ts-ignore\n    textLayer.$set({ captureEvents: locked });\n  }\n\n  const setVisible = (visible: boolean) => {\n    _visible = visible;\n\n    textLayer.$set({ visible });\n  }\n\n  const unmount = () => textLayer.$destroy();\n\n  return {\n    isLocked,\n    isVisible,\n    loadOCR,\n    setLocked,\n    setVisible,\n    unmount\n  }\n\n}"],"names":["transcriptionLabel","annotation","_a","b","ht","nn","en","L","on","n","rn","_t","gt","e","On","R","It","An","a","c","l","d","g","y","p","h","Ln","Pn","Gn","Un","te","f","u","$","x","ne","o","r","s","N","U","W","A","v","J","Z","O","E","I","noop","run","fn","blank_object","run_all","fns","is_function","thing","safe_not_equal","is_empty","obj","append","target","node","insert","anchor","detach","destroy_each","iterations","detaching","i","element","name","text","data","empty","attr","attribute","value","children","set_data","toggle_class","toggle","current_component","set_current_component","component","get_current_component","onMount","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","update_scheduled","schedule_update","flush","add_render_callback","seen_callbacks","flushidx","saved_component","update","callback","$$","dirty","flush_render_callbacks","filtered","targets","outroing","outros","group_outros","check_outros","transition_in","block","local","transition_out","ensure_array_like","array_like_or_iterator","create_component","mount_component","fragment","after_update","new_on_destroy","destroy_component","make_dirty","init","options","instance","create_fragment","not_equal","props","append_styles","parent_component","ready","ret","rest","nodes","SvelteComponent","__publicField","type","callbacks","index","PUBLIC_VERSION","ctx","div","span","create_if_block","ref","$$props","opts","$$value","$$invalidate","left","top","width","height","scaleX","scaleY","label","div_style_value","getStyle","size","offsetX","offsetY","w","cx","cy","scale","imageSize","bottom","t","Ke","V","nt","Nt","dt","ae","q","sn","Gt","ln","an","cn","Ge","se","B","k","rt","zt","oe","ce","F","un","ze","dn","Ie","Be","Ht","Te","ue","be","He","Ae","mt","hn","ot","gn","Ft","it","We","pe","mn","pn","Ve","de","re","le","P","C","Se","Q","yn","ee","m","_n","j","at","Fe","bn","En","K","Nn","wt","bt","Le","ho","_","Et","At","go","Qt","mo","po","bo","Eo","Ao","So","To","Mo","D","T","S","M","X","ge","me","Me","ie","z","H","fe","qe","ut","Y","Ye","De","Xe","Ce","vo","Lo","ko","Io","St","Po","Yo","getImageDimensions","viewer","resolve","getDimensions","scaleShape","shape","kx","ky","bounds","minX","minY","maxX","maxY","ShapeType","scaleAnnotations","page","dim","pageWidth","pageHeight","imgWidth","imgHeight","current","each_blocks","fixedscreensizelabel_changes","state","visible","captureEvents","store","transform","annotations","redraw","viewportBounds","containerWidth","zoom","rotation","flipped","dx","dy","tx","ty","dimensions","onStoreChange","event","onCopy","evt","unformatted","clipboardData","fontSize","mountExtension","anno","_visible","_locked","textLayer","OpenSeadragonTextLayer","url","format","res","xml","metadata","parseALTO","scaled","locked"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,14]}